
power-management.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000075b0  08000000  08000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  20000000  080075b0  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .configSection 00000a3c  080075c4  080075c4  000175c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000564c  20000014  20000014  00018014  2**2
                  ALLOC
  4 .debug_info   00016d3f  00000000  00000000  00018000  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00004668  00000000  00000000  0002ed3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000bcd7  00000000  00000000  000333a7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000016c8  00000000  00000000  0003f07e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 000019d8  00000000  00000000  00040746  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000756a  00000000  00000000  0004211e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005b2b  00000000  00000000  00049688  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      000000e0  00000000  00000000  0004f1b3  2**0
                  CONTENTS, READONLY
 12 .ARM.attributes 00000033  00000000  00000000  0004f293  2**0
                  CONTENTS, READONLY
 13 .debug_frame  0000324c  00000000  00000000  0004f2c8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000000 <vector_table>:
 8000000:	00 00 01 20 99 73 00 08 1d 02 00 08 23 02 00 08     ... .s......#...
 8000010:	95 73 00 08 29 02 00 08 2f 02 00 08 00 00 00 00     .s..).../.......
	...
 800002c:	35 02 00 08 97 73 00 08 00 00 00 00 39 02 00 08     5....s......9...
 800003c:	3d 02 00 08 95 73 00 08 95 73 00 08 95 73 00 08     =....s...s...s..
 800004c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800005c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800006c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800007c:	95 73 00 08 95 73 00 08 95 73 00 08 15 2a 00 08     .s...s...s...*..
 800008c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800009c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 80000ac:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 80000bc:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 80000cc:	95 73 00 08 95 73 00 08 95 29 00 08 95 73 00 08     .s...s...)...s..
 80000dc:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 80000ec:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 80000fc:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800010c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800011c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800012c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800013c:	95 73 00 08 95 73 00 08 95 73 00 08 95 73 00 08     .s...s...s...s..
 800014c:	95 73 00 08                                         .s..

08000150 <main>:
extern void disk_timerproc();

/*--------------------------------------------------------------------------*/

int main(void)
{
 8000150:	b530      	push	{r4, r5, lr}
    setGlobalDefaults();        /* From objdic */
    prvSetupHardware();         /* From hardware */
    initComms();                /* From comms */

/* Start the watchdog task. */
	xTaskCreate(prvWatchdogTask, (signed portCHAR * ) "Watchdog", \
 8000152:	2400      	movs	r4, #0
extern void disk_timerproc();

/*--------------------------------------------------------------------------*/

int main(void)
{
 8000154:	b085      	sub	sp, #20
    setGlobalDefaults();        /* From objdic */
 8000156:	f002 fe59 	bl	8002e0c <setGlobalDefaults>
    prvSetupHardware();         /* From hardware */
 800015a:	f002 faa3 	bl	80026a4 <prvSetupHardware>
    initComms();                /* From comms */
 800015e:	f000 f87b 	bl	8000258 <initComms>

/* Start the watchdog task. */
	xTaskCreate(prvWatchdogTask, (signed portCHAR * ) "Watchdog", \
 8000162:	2280      	movs	r2, #128	; 0x80
 8000164:	4623      	mov	r3, r4
 8000166:	9400      	str	r4, [sp, #0]
 8000168:	9401      	str	r4, [sp, #4]
 800016a:	9402      	str	r4, [sp, #8]
 800016c:	9403      	str	r4, [sp, #12]
 800016e:	491f      	ldr	r1, [pc, #124]	; (80001ec <main+0x9c>)
 8000170:	481f      	ldr	r0, [pc, #124]	; (80001f0 <main+0xa0>)
 8000172:	f005 f8b5 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, WATCHDOG_TASK_PRIORITY, NULL);

/* Start the communications task. */
	xTaskCreate(prvCommsTask, (signed portCHAR * ) "Communications", \
 8000176:	2302      	movs	r3, #2
 8000178:	e88d 0018 	stmia.w	sp, {r3, r4}
 800017c:	2280      	movs	r2, #128	; 0x80
 800017e:	4623      	mov	r3, r4
 8000180:	9402      	str	r4, [sp, #8]
 8000182:	9403      	str	r4, [sp, #12]
 8000184:	491b      	ldr	r1, [pc, #108]	; (80001f4 <main+0xa4>)
 8000186:	481c      	ldr	r0, [pc, #112]	; (80001f8 <main+0xa8>)
 8000188:	f005 f8aa 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, COMMS_TASK_PRIORITY, NULL);

/* Start the file management task. */
	xTaskCreate(prvFileTask, (signed portCHAR * ) "File", \
 800018c:	2280      	movs	r2, #128	; 0x80
 800018e:	4623      	mov	r3, r4
 8000190:	9400      	str	r4, [sp, #0]
 8000192:	9401      	str	r4, [sp, #4]
 8000194:	9402      	str	r4, [sp, #8]
 8000196:	9403      	str	r4, [sp, #12]
 8000198:	4918      	ldr	r1, [pc, #96]	; (80001fc <main+0xac>)
 800019a:	4819      	ldr	r0, [pc, #100]	; (8000200 <main+0xb0>)
 800019c:	f005 f8a0 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, FILE_TASK_PRIORITY, NULL);

/* Start the measurement task. */
	xTaskCreate(prvMeasurementTask, (signed portCHAR * ) "Measurement", \
 80001a0:	2303      	movs	r3, #3
 80001a2:	e88d 0018 	stmia.w	sp, {r3, r4}
 80001a6:	2280      	movs	r2, #128	; 0x80
 80001a8:	4623      	mov	r3, r4
                configMINIMAL_STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL);

/* Start the monitor task. */
	xTaskCreate(prvMonitorTask, (signed portCHAR * ) "Monitor", \
 80001aa:	2501      	movs	r5, #1
/* Start the file management task. */
	xTaskCreate(prvFileTask, (signed portCHAR * ) "File", \
                configMINIMAL_STACK_SIZE, NULL, FILE_TASK_PRIORITY, NULL);

/* Start the measurement task. */
	xTaskCreate(prvMeasurementTask, (signed portCHAR * ) "Measurement", \
 80001ac:	9402      	str	r4, [sp, #8]
 80001ae:	9403      	str	r4, [sp, #12]
 80001b0:	4914      	ldr	r1, [pc, #80]	; (8000204 <main+0xb4>)
 80001b2:	4815      	ldr	r0, [pc, #84]	; (8000208 <main+0xb8>)
 80001b4:	f005 f894 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL);

/* Start the monitor task. */
	xTaskCreate(prvMonitorTask, (signed portCHAR * ) "Monitor", \
 80001b8:	2280      	movs	r2, #128	; 0x80
 80001ba:	4623      	mov	r3, r4
 80001bc:	9500      	str	r5, [sp, #0]
 80001be:	9401      	str	r4, [sp, #4]
 80001c0:	9402      	str	r4, [sp, #8]
 80001c2:	9403      	str	r4, [sp, #12]
 80001c4:	4911      	ldr	r1, [pc, #68]	; (800020c <main+0xbc>)
 80001c6:	4812      	ldr	r0, [pc, #72]	; (8000210 <main+0xc0>)
 80001c8:	f005 f88a 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, MONITOR_TASK_PRIORITY, NULL);

/* Start the charger task. */
	xTaskCreate(prvChargerTask, (signed portCHAR * ) "Charger", \
 80001cc:	4911      	ldr	r1, [pc, #68]	; (8000214 <main+0xc4>)
 80001ce:	2280      	movs	r2, #128	; 0x80
 80001d0:	4623      	mov	r3, r4
 80001d2:	9500      	str	r5, [sp, #0]
 80001d4:	9401      	str	r4, [sp, #4]
 80001d6:	9402      	str	r4, [sp, #8]
 80001d8:	9403      	str	r4, [sp, #12]
 80001da:	480f      	ldr	r0, [pc, #60]	; (8000218 <main+0xc8>)
 80001dc:	f005 f880 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, CHARGER_TASK_PRIORITY, NULL);

/* Start the scheduler. */
	vTaskStartScheduler();
 80001e0:	f005 f97a 	bl	80054d8 <vTaskStartScheduler>

/* Will only get here if there was not enough heap space to create the
idle task. */
	return -1;
}
 80001e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80001e8:	b005      	add	sp, #20
 80001ea:	bd30      	pop	{r4, r5, pc}
 80001ec:	0800748c 	.word	0x0800748c
 80001f0:	08003371 	.word	0x08003371
 80001f4:	08007495 	.word	0x08007495
 80001f8:	08000561 	.word	0x08000561
 80001fc:	080074a4 	.word	0x080074a4
 8000200:	08000ec1 	.word	0x08000ec1
 8000204:	080074a9 	.word	0x080074a9
 8000208:	08002ffd 	.word	0x08002ffd
 800020c:	080074b5 	.word	0x080074b5
 8000210:	080016e9 	.word	0x080016e9
 8000214:	080074bd 	.word	0x080074bd
 8000218:	08002129 	.word	0x08002129

0800021c <nmi_handler>:
/* These trap serious execution errors and reset the application by means
of the CM3 system reset command. */

/*-----------------------------------------------------------*/
void nmi_handler(void)
{
 800021c:	b508      	push	{r3, lr}
    scb_reset_system();
 800021e:	f007 f91f 	bl	8007460 <scb_reset_system>

08000222 <hard_fault_handler>:
}

/*-----------------------------------------------------------*/
void hard_fault_handler(void)
{
 8000222:	b508      	push	{r3, lr}
    scb_reset_system();
 8000224:	f007 f91c 	bl	8007460 <scb_reset_system>

08000228 <bus_fault_handler>:
    scb_reset_system();
}

/*-----------------------------------------------------------*/
void bus_fault_handler(void)
{
 8000228:	b508      	push	{r3, lr}
    scb_reset_system();
 800022a:	f007 f919 	bl	8007460 <scb_reset_system>

0800022e <usage_fault_handler>:
}

/*-----------------------------------------------------------*/
void usage_fault_handler(void)
{
 800022e:	b508      	push	{r3, lr}
    scb_reset_system();
 8000230:	f007 f916 	bl	8007460 <scb_reset_system>

08000234 <sv_call_handler>:
extern void vPortSVCHandler( void );

/*-----------------------------------------------------------*/
void sv_call_handler(void)
{
  	vPortSVCHandler();
 8000234:	f005 bffe 	b.w	8006234 <vPortSVCHandler>

08000238 <pend_sv_handler>:

/*-----------------------------------------------------------*/

void pend_sv_handler(void)
{
  	xPortPendSVHandler();
 8000238:	f006 b840 	b.w	80062bc <xPortPendSVHandler>

0800023c <sys_tick_handler>:
This also updates the status of any inserted SD card.

Can be used to provide a RTC.
*/
void sys_tick_handler(void)
{
 800023c:	b508      	push	{r3, lr}

	disk_timerproc();
 800023e:	f004 ff4d 	bl	80050dc <disk_timerproc>
		cnttime = 0;
		updateTimeCount();
	}
*/
  	xPortSysTickHandler();
}
 8000242:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    {
		cnttime = 0;
		updateTimeCount();
	}
*/
  	xPortSysTickHandler();
 8000246:	f006 b857 	b.w	80062f8 <xPortSysTickHandler>
	...

0800024c <resetCallback>:
global is used until this is fixed.
*/

void resetCallback(xTimerHandle resetHandle)
{
    overCurrentRelease(intf);
 800024c:	4b01      	ldr	r3, [pc, #4]	; (8000254 <resetCallback+0x8>)
 800024e:	7818      	ldrb	r0, [r3, #0]
 8000250:	f002 b9e0 	b.w	8002614 <overCurrentRelease>
 8000254:	20000031 	.word	0x20000031

08000258 <initComms>:

This initializes the queues and semaphores used by the task.
*/

void initComms(void)
{
 8000258:	b510      	push	{r4, lr}
/* Setup the queues to use */
	commsSendQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
 800025a:	2101      	movs	r1, #1
 800025c:	2200      	movs	r2, #0
 800025e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000262:	f005 fcd5 	bl	8005c10 <xQueueGenericCreate>
 8000266:	4b12      	ldr	r3, [pc, #72]	; (80002b0 <initComms+0x58>)
	commsReceiveQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
 8000268:	2101      	movs	r1, #1
*/

void initComms(void)
{
/* Setup the queues to use */
	commsSendQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
 800026a:	6018      	str	r0, [r3, #0]
	commsReceiveQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
 800026c:	2200      	movs	r2, #0
 800026e:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000272:	f005 fccd 	bl	8005c10 <xQueueGenericCreate>
 8000276:	490f      	ldr	r1, [pc, #60]	; (80002b4 <initComms+0x5c>)
    commsSendSemaphore = xSemaphoreCreateBinary();
 8000278:	2203      	movs	r2, #3

void initComms(void)
{
/* Setup the queues to use */
	commsSendQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
	commsReceiveQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
 800027a:	6008      	str	r0, [r1, #0]
    commsSendSemaphore = xSemaphoreCreateBinary();
 800027c:	2100      	movs	r1, #0
 800027e:	2001      	movs	r0, #1
 8000280:	f005 fcc6 	bl	8005c10 <xQueueGenericCreate>
 8000284:	4a0c      	ldr	r2, [pc, #48]	; (80002b8 <initComms+0x60>)
    xSemaphoreGive(commsSendSemaphore);
 8000286:	2100      	movs	r1, #0
 8000288:	460b      	mov	r3, r1
void initComms(void)
{
/* Setup the queues to use */
	commsSendQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
	commsReceiveQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
    commsSendSemaphore = xSemaphoreCreateBinary();
 800028a:	6010      	str	r0, [r2, #0]
    xSemaphoreGive(commsSendSemaphore);
 800028c:	460a      	mov	r2, r1
 800028e:	f005 fcdf 	bl	8005c50 <xQueueGenericSend>
    commsEmptySemaphore = xSemaphoreCreateBinary();
 8000292:	2100      	movs	r1, #0
 8000294:	2203      	movs	r2, #3
 8000296:	2001      	movs	r0, #1
 8000298:	f005 fcba 	bl	8005c10 <xQueueGenericCreate>
 800029c:	4b07      	ldr	r3, [pc, #28]	; (80002bc <initComms+0x64>)
    xSemaphoreGive(commsEmptySemaphore);
 800029e:	2100      	movs	r1, #0
/* Setup the queues to use */
	commsSendQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
	commsReceiveQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
    commsSendSemaphore = xSemaphoreCreateBinary();
    xSemaphoreGive(commsSendSemaphore);
    commsEmptySemaphore = xSemaphoreCreateBinary();
 80002a0:	6018      	str	r0, [r3, #0]
    xSemaphoreGive(commsEmptySemaphore);
 80002a2:	460a      	mov	r2, r1
 80002a4:	460b      	mov	r3, r1
}
 80002a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	commsSendQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
	commsReceiveQueue = xQueueCreate(COMMS_QUEUE_SIZE,1);
    commsSendSemaphore = xSemaphoreCreateBinary();
    xSemaphoreGive(commsSendSemaphore);
    commsEmptySemaphore = xSemaphoreCreateBinary();
    xSemaphoreGive(commsEmptySemaphore);
 80002aa:	f005 bcd1 	b.w	8005c50 <xQueueGenericSend>
 80002ae:	bf00      	nop
 80002b0:	2000001c 	.word	0x2000001c
 80002b4:	20000014 	.word	0x20000014
 80002b8:	20000020 	.word	0x20000020
 80002bc:	20000034 	.word	0x20000034

080002c0 <commsPrintChar>:

@param[in] char *ch: pointer to character to be printed.
*/

void commsPrintChar(char *ch)
{
 80002c0:	b538      	push	{r3, r4, r5, lr}
 80002c2:	4605      	mov	r5, r0
    commsEnableTxInterrupt(false);
 80002c4:	2000      	movs	r0, #0
 80002c6:	f002 fb13 	bl	80028f0 <commsEnableTxInterrupt>
  	while (xQueueSendToBack(commsSendQueue,ch,COMMS_SEND_TIMEOUT) != pdTRUE)
 80002ca:	4c0b      	ldr	r4, [pc, #44]	; (80002f8 <commsPrintChar+0x38>)
 80002cc:	22c8      	movs	r2, #200	; 0xc8
 80002ce:	2300      	movs	r3, #0
 80002d0:	6820      	ldr	r0, [r4, #0]
 80002d2:	4629      	mov	r1, r5
 80002d4:	f005 fcbc 	bl	8005c50 <xQueueGenericSend>
 80002d8:	2801      	cmp	r0, #1
 80002da:	d009      	beq.n	80002f0 <commsPrintChar+0x30>
    {
        xQueueReset(commsSendQueue);
 80002dc:	2100      	movs	r1, #0
 80002de:	6820      	ldr	r0, [r4, #0]
 80002e0:	f005 fc68 	bl	8005bb4 <xQueueGenericReset>
        commsEnableTxInterrupt(true);
 80002e4:	2001      	movs	r0, #1
 80002e6:	f002 fb03 	bl	80028f0 <commsEnableTxInterrupt>
        taskYIELD();
 80002ea:	f005 ffb3 	bl	8006254 <vPortYield>
 80002ee:	e7ec      	b.n	80002ca <commsPrintChar+0xa>
    }
    commsEnableTxInterrupt(true);
}
 80002f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    {
        xQueueReset(commsSendQueue);
        commsEnableTxInterrupt(true);
        taskYIELD();
    }
    commsEnableTxInterrupt(true);
 80002f4:	f002 bafc 	b.w	80028f0 <commsEnableTxInterrupt>
 80002f8:	2000001c 	.word	0x2000001c

080002fc <commsPrintString>:

@param[in] char *ch: pointer to string to be printed.
*/

void commsPrintString(char *ch)
{
 80002fc:	b538      	push	{r3, r4, r5, lr}
    if (uxQueueSpacesAvailable(commsSendQueue) >= stringLength(ch))
 80002fe:	4b09      	ldr	r3, [pc, #36]	; (8000324 <commsPrintString+0x28>)

@param[in] char *ch: pointer to string to be printed.
*/

void commsPrintString(char *ch)
{
 8000300:	4604      	mov	r4, r0
    if (uxQueueSpacesAvailable(commsSendQueue) >= stringLength(ch))
 8000302:	6818      	ldr	r0, [r3, #0]
 8000304:	f005 fdee 	bl	8005ee4 <uxQueueSpacesAvailable>
 8000308:	4605      	mov	r5, r0
 800030a:	4620      	mov	r0, r4
 800030c:	f002 fbd6 	bl	8002abc <stringLength>
 8000310:	4285      	cmp	r5, r0
 8000312:	d306      	bcc.n	8000322 <commsPrintString+0x26>
 8000314:	4620      	mov	r0, r4
  	    while(*ch) commsPrintChar(ch++);
 8000316:	7801      	ldrb	r1, [r0, #0]
 8000318:	3401      	adds	r4, #1
 800031a:	b111      	cbz	r1, 8000322 <commsPrintString+0x26>
 800031c:	f7ff ffd0 	bl	80002c0 <commsPrintChar>
 8000320:	e7f8      	b.n	8000314 <commsPrintString+0x18>
 8000322:	bd38      	pop	{r3, r4, r5, pc}
 8000324:	2000001c 	.word	0x2000001c

08000328 <sendStringLowPriority>:
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendStringLowPriority(char* ident, char* string)
{
 8000328:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if ((ident[0] == 'D') && !configData.config.debugMessageSend) return;
 800032c:	7803      	ldrb	r3, [r0, #0]
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendStringLowPriority(char* ident, char* string)
{
 800032e:	4605      	mov	r5, r0
    if ((ident[0] == 'D') && !configData.config.debugMessageSend) return;
 8000330:	2b44      	cmp	r3, #68	; 0x44
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendStringLowPriority(char* ident, char* string)
{
 8000332:	460e      	mov	r6, r1
    if ((ident[0] == 'D') && !configData.config.debugMessageSend) return;
 8000334:	d104      	bne.n	8000340 <sendStringLowPriority+0x18>
 8000336:	4822      	ldr	r0, [pc, #136]	; (80003c0 <sendStringLowPriority+0x98>)
 8000338:	f890 102b 	ldrb.w	r1, [r0, #43]	; 0x2b
 800033c:	2900      	cmp	r1, #0
 800033e:	d03c      	beq.n	80003ba <sendStringLowPriority+0x92>
/* If any characters are on the send queue, block on the commsEmptySemaphore
which is released by the ISR after the last character has been sent. One
message is then sent. The calling task cannot queue more than one message. */
/* Hold indefinitely as the message must not be abandoned */
    if (uxQueueSpacesAvailable(commsSendQueue) >=
 8000340:	4a20      	ldr	r2, [pc, #128]	; (80003c4 <sendStringLowPriority+0x9c>)
 8000342:	6810      	ldr	r0, [r2, #0]
 8000344:	f005 fdce 	bl	8005ee4 <uxQueueSpacesAvailable>
 8000348:	4604      	mov	r4, r0
        stringLength(ident)+stringLength(string)+3)
 800034a:	4628      	mov	r0, r5
 800034c:	f002 fbb6 	bl	8002abc <stringLength>
 8000350:	4607      	mov	r7, r0
 8000352:	4630      	mov	r0, r6
 8000354:	f002 fbb2 	bl	8002abc <stringLength>
 8000358:	183b      	adds	r3, r7, r0
 800035a:	1cdf      	adds	r7, r3, #3
    if ((ident[0] == 'D') && !configData.config.debugMessageSend) return;
/* If any characters are on the send queue, block on the commsEmptySemaphore
which is released by the ISR after the last character has been sent. One
message is then sent. The calling task cannot queue more than one message. */
/* Hold indefinitely as the message must not be abandoned */
    if (uxQueueSpacesAvailable(commsSendQueue) >=
 800035c:	42bc      	cmp	r4, r7
 800035e:	d201      	bcs.n	8000364 <sendStringLowPriority+0x3c>
 8000360:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        stringLength(ident)+stringLength(string)+3)
    {
        while (uxQueueMessagesWaiting(commsSendQueue) > 0)
 8000364:	4c17      	ldr	r4, [pc, #92]	; (80003c4 <sendStringLowPriority+0x9c>)
 8000366:	6820      	ldr	r0, [r4, #0]
 8000368:	f005 fdb3 	bl	8005ed2 <uxQueueMessagesWaiting>
 800036c:	4604      	mov	r4, r0
 800036e:	b140      	cbz	r0, 8000382 <sendStringLowPriority+0x5a>
            xSemaphoreTake(commsEmptySemaphore,portMAX_DELAY);
 8000370:	4815      	ldr	r0, [pc, #84]	; (80003c8 <sendStringLowPriority+0xa0>)
 8000372:	2100      	movs	r1, #0
 8000374:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000378:	460b      	mov	r3, r1
 800037a:	6800      	ldr	r0, [r0, #0]
 800037c:	f005 fcff 	bl	8005d7e <xQueueGenericReceive>
 8000380:	e7f0      	b.n	8000364 <sendStringLowPriority+0x3c>
        xSemaphoreTake(commsSendSemaphore,portMAX_DELAY);
 8000382:	4f12      	ldr	r7, [pc, #72]	; (80003cc <sendStringLowPriority+0xa4>)
 8000384:	4621      	mov	r1, r4
 8000386:	4623      	mov	r3, r4
 8000388:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800038c:	6838      	ldr	r0, [r7, #0]
 800038e:	f005 fcf6 	bl	8005d7e <xQueueGenericReceive>
        commsPrintString(ident);
 8000392:	4628      	mov	r0, r5
 8000394:	f7ff ffb2 	bl	80002fc <commsPrintString>
        commsPrintString(",");
 8000398:	480d      	ldr	r0, [pc, #52]	; (80003d0 <sendStringLowPriority+0xa8>)
 800039a:	f7ff ffaf 	bl	80002fc <commsPrintString>
        commsPrintString(string);
 800039e:	4630      	mov	r0, r6
 80003a0:	f7ff ffac 	bl	80002fc <commsPrintString>
        commsPrintString("\r\n");
 80003a4:	480b      	ldr	r0, [pc, #44]	; (80003d4 <sendStringLowPriority+0xac>)
 80003a6:	f7ff ffa9 	bl	80002fc <commsPrintString>
        xSemaphoreGive(commsSendSemaphore);
 80003aa:	6838      	ldr	r0, [r7, #0]
 80003ac:	4621      	mov	r1, r4
 80003ae:	4622      	mov	r2, r4
 80003b0:	4623      	mov	r3, r4
    }
}
 80003b2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        xSemaphoreTake(commsSendSemaphore,portMAX_DELAY);
        commsPrintString(ident);
        commsPrintString(",");
        commsPrintString(string);
        commsPrintString("\r\n");
        xSemaphoreGive(commsSendSemaphore);
 80003b6:	f005 bc4b 	b.w	8005c50 <xQueueGenericSend>
 80003ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80003be:	bf00      	nop
 80003c0:	200008c8 	.word	0x200008c8
 80003c4:	2000001c 	.word	0x2000001c
 80003c8:	20000034 	.word	0x20000034
 80003cc:	20000020 	.word	0x20000020
 80003d0:	0800751d 	.word	0x0800751d
 80003d4:	080074c5 	.word	0x080074c5

080003d8 <sendString>:
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendString(char* ident, char* string)
{
 80003d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (configData.config.measurementSend)
 80003dc:	4b1a      	ldr	r3, [pc, #104]	; (8000448 <sendString+0x70>)
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendString(char* ident, char* string)
{
 80003de:	4606      	mov	r6, r0
    if (configData.config.measurementSend)
 80003e0:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendString(char* ident, char* string)
{
 80003e4:	460d      	mov	r5, r1
    if (configData.config.measurementSend)
 80003e6:	2800      	cmp	r0, #0
 80003e8:	d02b      	beq.n	8000442 <sendString+0x6a>
    {
        if (uxQueueSpacesAvailable(commsSendQueue) >=
 80003ea:	4918      	ldr	r1, [pc, #96]	; (800044c <sendString+0x74>)
 80003ec:	6808      	ldr	r0, [r1, #0]
 80003ee:	f005 fd79 	bl	8005ee4 <uxQueueSpacesAvailable>
 80003f2:	4604      	mov	r4, r0
            stringLength(ident)+stringLength(string)+3)
 80003f4:	4630      	mov	r0, r6
 80003f6:	f002 fb61 	bl	8002abc <stringLength>
 80003fa:	4607      	mov	r7, r0
 80003fc:	4628      	mov	r0, r5
 80003fe:	f002 fb5d 	bl	8002abc <stringLength>
 8000402:	183a      	adds	r2, r7, r0
 8000404:	1cd7      	adds	r7, r2, #3

void sendString(char* ident, char* string)
{
    if (configData.config.measurementSend)
    {
        if (uxQueueSpacesAvailable(commsSendQueue) >=
 8000406:	42bc      	cmp	r4, r7
 8000408:	d31b      	bcc.n	8000442 <sendString+0x6a>
            stringLength(ident)+stringLength(string)+3)
        {
            if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_DELAY)) return;
 800040a:	4c11      	ldr	r4, [pc, #68]	; (8000450 <sendString+0x78>)
 800040c:	2100      	movs	r1, #0
 800040e:	6820      	ldr	r0, [r4, #0]
 8000410:	2264      	movs	r2, #100	; 0x64
 8000412:	460b      	mov	r3, r1
 8000414:	f005 fcb3 	bl	8005d7e <xQueueGenericReceive>
 8000418:	b198      	cbz	r0, 8000442 <sendString+0x6a>
            commsPrintString(ident);
 800041a:	4630      	mov	r0, r6
 800041c:	f7ff ff6e 	bl	80002fc <commsPrintString>
            commsPrintString(",");
 8000420:	480c      	ldr	r0, [pc, #48]	; (8000454 <sendString+0x7c>)
 8000422:	f7ff ff6b 	bl	80002fc <commsPrintString>
            commsPrintString(string);
 8000426:	4628      	mov	r0, r5
 8000428:	f7ff ff68 	bl	80002fc <commsPrintString>
            commsPrintString("\r\n");
 800042c:	480a      	ldr	r0, [pc, #40]	; (8000458 <sendString+0x80>)
 800042e:	f7ff ff65 	bl	80002fc <commsPrintString>
            xSemaphoreGive(commsSendSemaphore);
 8000432:	2100      	movs	r1, #0
 8000434:	6820      	ldr	r0, [r4, #0]
 8000436:	460a      	mov	r2, r1
 8000438:	460b      	mov	r3, r1
        }
    }
}
 800043a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_DELAY)) return;
            commsPrintString(ident);
            commsPrintString(",");
            commsPrintString(string);
            commsPrintString("\r\n");
            xSemaphoreGive(commsSendSemaphore);
 800043e:	f005 bc07 	b.w	8005c50 <xQueueGenericSend>
 8000442:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000446:	bf00      	nop
 8000448:	200008c8 	.word	0x200008c8
 800044c:	2000001c 	.word	0x2000001c
 8000450:	20000020 	.word	0x20000020
 8000454:	0800751d 	.word	0x0800751d
 8000458:	080074c5 	.word	0x080074c5

0800045c <commsPrintInt>:

@param[in] int32_t value: integer value to be printed.
*/

void commsPrintInt(int32_t value)
{
 800045c:	b510      	push	{r4, lr}
 800045e:	b088      	sub	sp, #32
	uint8_t i=0;
	char buffer[25];
    intToAscii(value, buffer);
 8000460:	a901      	add	r1, sp, #4
 8000462:	f002 faed 	bl	8002a40 <intToAscii>
    if (uxQueueSpacesAvailable(commsSendQueue) >= stringLength(buffer))
 8000466:	4b0c      	ldr	r3, [pc, #48]	; (8000498 <commsPrintInt+0x3c>)
 8000468:	6818      	ldr	r0, [r3, #0]
 800046a:	f005 fd3b 	bl	8005ee4 <uxQueueSpacesAvailable>
 800046e:	4604      	mov	r4, r0
 8000470:	a801      	add	r0, sp, #4
 8000472:	f002 fb23 	bl	8002abc <stringLength>
 8000476:	4284      	cmp	r4, r0
 8000478:	d30c      	bcc.n	8000494 <commsPrintInt+0x38>
 800047a:	2400      	movs	r4, #0
	    while (buffer[i] > 0)
 800047c:	aa08      	add	r2, sp, #32
 800047e:	1910      	adds	r0, r2, r4
 8000480:	f810 1c1c 	ldrb.w	r1, [r0, #-28]
 8000484:	b131      	cbz	r1, 8000494 <commsPrintInt+0x38>
	    {
	        commsPrintChar(&buffer[i]);
 8000486:	ab01      	add	r3, sp, #4
 8000488:	1918      	adds	r0, r3, r4
            i++;
 800048a:	3401      	adds	r4, #1
	char buffer[25];
    intToAscii(value, buffer);
    if (uxQueueSpacesAvailable(commsSendQueue) >= stringLength(buffer))
	    while (buffer[i] > 0)
	    {
	        commsPrintChar(&buffer[i]);
 800048c:	f7ff ff18 	bl	80002c0 <commsPrintChar>
            i++;
 8000490:	b2e4      	uxtb	r4, r4
 8000492:	e7f3      	b.n	800047c <commsPrintInt+0x20>
	    }
}
 8000494:	b008      	add	sp, #32
 8000496:	bd10      	pop	{r4, pc}
 8000498:	2000001c 	.word	0x2000001c

0800049c <sendResponse>:
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendResponse(char* ident, int32_t parameter)
{
 800049c:	b570      	push	{r4, r5, r6, lr}
    if (configData.config.measurementSend)
 800049e:	4b11      	ldr	r3, [pc, #68]	; (80004e4 <sendResponse+0x48>)
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendResponse(char* ident, int32_t parameter)
{
 80004a0:	4606      	mov	r6, r0
    if (configData.config.measurementSend)
 80004a2:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
@param[in] char* ident. Response identifier string
@param[in] int32_t parameter. Single integer parameter.
*/

void sendResponse(char* ident, int32_t parameter)
{
 80004a6:	460d      	mov	r5, r1
    if (configData.config.measurementSend)
 80004a8:	b1d8      	cbz	r0, 80004e2 <sendResponse+0x46>
    {
        if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_DELAY)) return;
 80004aa:	4c0f      	ldr	r4, [pc, #60]	; (80004e8 <sendResponse+0x4c>)
 80004ac:	2100      	movs	r1, #0
 80004ae:	6820      	ldr	r0, [r4, #0]
 80004b0:	2264      	movs	r2, #100	; 0x64
 80004b2:	460b      	mov	r3, r1
 80004b4:	f005 fc63 	bl	8005d7e <xQueueGenericReceive>
 80004b8:	b198      	cbz	r0, 80004e2 <sendResponse+0x46>
        commsPrintString(ident);
 80004ba:	4630      	mov	r0, r6
 80004bc:	f7ff ff1e 	bl	80002fc <commsPrintString>
        commsPrintString(",");
 80004c0:	480a      	ldr	r0, [pc, #40]	; (80004ec <sendResponse+0x50>)
 80004c2:	f7ff ff1b 	bl	80002fc <commsPrintString>
        commsPrintInt(parameter);
 80004c6:	4628      	mov	r0, r5
 80004c8:	f7ff ffc8 	bl	800045c <commsPrintInt>
        commsPrintString("\r\n");
 80004cc:	4808      	ldr	r0, [pc, #32]	; (80004f0 <sendResponse+0x54>)
 80004ce:	f7ff ff15 	bl	80002fc <commsPrintString>
        xSemaphoreGive(commsSendSemaphore);
 80004d2:	2100      	movs	r1, #0
 80004d4:	6820      	ldr	r0, [r4, #0]
 80004d6:	460a      	mov	r2, r1
 80004d8:	460b      	mov	r3, r1
    }
}
 80004da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_DELAY)) return;
        commsPrintString(ident);
        commsPrintString(",");
        commsPrintInt(parameter);
        commsPrintString("\r\n");
        xSemaphoreGive(commsSendSemaphore);
 80004de:	f005 bbb7 	b.w	8005c50 <xQueueGenericSend>
 80004e2:	bd70      	pop	{r4, r5, r6, pc}
 80004e4:	200008c8 	.word	0x200008c8
 80004e8:	20000020 	.word	0x20000020
 80004ec:	0800751d 	.word	0x0800751d
 80004f0:	080074c5 	.word	0x080074c5

080004f4 <dataMessageSend>:
@param int32_t param1: first parameter.
@param int32_t param2: second parameter.
*/

void dataMessageSend(char* ident, int32_t param1, int32_t param2)
{
 80004f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (configData.config.measurementSend)
 80004f8:	4b15      	ldr	r3, [pc, #84]	; (8000550 <dataMessageSend+0x5c>)
@param int32_t param1: first parameter.
@param int32_t param2: second parameter.
*/

void dataMessageSend(char* ident, int32_t param1, int32_t param2)
{
 80004fa:	4607      	mov	r7, r0
    if (configData.config.measurementSend)
 80004fc:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
@param int32_t param1: first parameter.
@param int32_t param2: second parameter.
*/

void dataMessageSend(char* ident, int32_t param1, int32_t param2)
{
 8000500:	460e      	mov	r6, r1
 8000502:	4615      	mov	r5, r2
    if (configData.config.measurementSend)
 8000504:	2800      	cmp	r0, #0
 8000506:	d021      	beq.n	800054c <dataMessageSend+0x58>
    {
        if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_DELAY)) return;
 8000508:	4c12      	ldr	r4, [pc, #72]	; (8000554 <dataMessageSend+0x60>)
 800050a:	2100      	movs	r1, #0
 800050c:	6820      	ldr	r0, [r4, #0]
 800050e:	2264      	movs	r2, #100	; 0x64
 8000510:	460b      	mov	r3, r1
 8000512:	f005 fc34 	bl	8005d7e <xQueueGenericReceive>
 8000516:	b1c8      	cbz	r0, 800054c <dataMessageSend+0x58>
        commsPrintString(ident);
 8000518:	4638      	mov	r0, r7
 800051a:	f7ff feef 	bl	80002fc <commsPrintString>
        commsPrintString(",");
 800051e:	480e      	ldr	r0, [pc, #56]	; (8000558 <dataMessageSend+0x64>)
 8000520:	f7ff feec 	bl	80002fc <commsPrintString>
        commsPrintInt(param1);
 8000524:	4630      	mov	r0, r6
 8000526:	f7ff ff99 	bl	800045c <commsPrintInt>
        commsPrintString(",");
 800052a:	480b      	ldr	r0, [pc, #44]	; (8000558 <dataMessageSend+0x64>)
 800052c:	f7ff fee6 	bl	80002fc <commsPrintString>
        commsPrintInt(param2);
 8000530:	4628      	mov	r0, r5
 8000532:	f7ff ff93 	bl	800045c <commsPrintInt>
        commsPrintString("\r\n");
 8000536:	4809      	ldr	r0, [pc, #36]	; (800055c <dataMessageSend+0x68>)
 8000538:	f7ff fee0 	bl	80002fc <commsPrintString>
        xSemaphoreGive(commsSendSemaphore);
 800053c:	2100      	movs	r1, #0
 800053e:	6820      	ldr	r0, [r4, #0]
 8000540:	460a      	mov	r2, r1
 8000542:	460b      	mov	r3, r1
    }
}
 8000544:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        commsPrintString(",");
        commsPrintInt(param1);
        commsPrintString(",");
        commsPrintInt(param2);
        commsPrintString("\r\n");
        xSemaphoreGive(commsSendSemaphore);
 8000548:	f005 bb82 	b.w	8005c50 <xQueueGenericSend>
 800054c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000550:	200008c8 	.word	0x200008c8
 8000554:	20000020 	.word	0x20000020
 8000558:	0800751d 	.word	0x0800751d
 800055c:	080074c5 	.word	0x080074c5

08000560 <prvCommsTask>:
This collects characters received over the communications interface and packages
them into a line for action as a command.
*/

void prvCommsTask( void *pvParameters )
{
 8000560:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
*/

static void initGlobals(void)
{
/* File name and handle variables are carried globally from the time of creation */
    writeFileName[0] = 0;
 8000564:	4ab3      	ldr	r2, [pc, #716]	; (8000834 <prvCommsTask+0x2d4>)
    readFileName[0] = 0;
    writeFileHandle = 0xFF;
    readFileHandle = 0xFF;
    configData.config.measurementSend = true;
 8000566:	4eb4      	ldr	r6, [pc, #720]	; (8000838 <prvCommsTask+0x2d8>)

static void initGlobals(void)
{
/* File name and handle variables are carried globally from the time of creation */
    writeFileName[0] = 0;
    readFileName[0] = 0;
 8000568:	48b4      	ldr	r0, [pc, #720]	; (800083c <prvCommsTask+0x2dc>)
    writeFileHandle = 0xFF;
 800056a:	49b5      	ldr	r1, [pc, #724]	; (8000840 <prvCommsTask+0x2e0>)
    readFileHandle = 0xFF;
 800056c:	4db5      	ldr	r5, [pc, #724]	; (8000844 <prvCommsTask+0x2e4>)
*/

static void initGlobals(void)
{
/* File name and handle variables are carried globally from the time of creation */
    writeFileName[0] = 0;
 800056e:	2300      	movs	r3, #0
    readFileName[0] = 0;
    writeFileHandle = 0xFF;
 8000570:	24ff      	movs	r4, #255	; 0xff
    readFileHandle = 0xFF;
    configData.config.measurementSend = true;
 8000572:	2701      	movs	r7, #1
This collects characters received over the communications interface and packages
them into a line for action as a command.
*/

void prvCommsTask( void *pvParameters )
{
 8000574:	b09a      	sub	sp, #104	; 0x68
*/

static void initGlobals(void)
{
/* File name and handle variables are carried globally from the time of creation */
    writeFileName[0] = 0;
 8000576:	7013      	strb	r3, [r2, #0]
    readFileName[0] = 0;
 8000578:	7003      	strb	r3, [r0, #0]
    writeFileHandle = 0xFF;
 800057a:	700c      	strb	r4, [r1, #0]
    readFileHandle = 0xFF;
 800057c:	702c      	strb	r4, [r5, #0]
    configData.config.measurementSend = true;
 800057e:	f886 702a 	strb.w	r7, [r6, #42]	; 0x2a
    configData.config.debugMessageSend = false;
 8000582:	f886 302b 	strb.w	r3, [r6, #43]	; 0x2b
    while(1)
    {
/* Build a command line string before actioning. the task will block
indefinitely waiting for input. */
        char character;
        xQueueReceive(commsReceiveQueue,&character,portMAX_DELAY);
 8000586:	4bb0      	ldr	r3, [pc, #704]	; (8000848 <prvCommsTask+0x2e8>)
 8000588:	f10d 010f 	add.w	r1, sp, #15
 800058c:	6818      	ldr	r0, [r3, #0]
 800058e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000592:	2300      	movs	r3, #0
 8000594:	f005 fbf3 	bl	8005d7e <xQueueGenericReceive>
        if ((character == 0x0D) || (characterPosition > 78))
 8000598:	f89d 000f 	ldrb.w	r0, [sp, #15]
 800059c:	4eab      	ldr	r6, [pc, #684]	; (800084c <prvCommsTask+0x2ec>)
 800059e:	280d      	cmp	r0, #13
 80005a0:	49ab      	ldr	r1, [pc, #684]	; (8000850 <prvCommsTask+0x2f0>)
 80005a2:	d003      	beq.n	80005ac <prvCommsTask+0x4c>
 80005a4:	7832      	ldrb	r2, [r6, #0]
 80005a6:	2a4e      	cmp	r2, #78	; 0x4e
 80005a8:	f240 843c 	bls.w	8000e24 <prvCommsTask+0x8c4>
        {
            line[characterPosition] = 0;
 80005ac:	7837      	ldrb	r7, [r6, #0]
 80005ae:	2400      	movs	r4, #0
 80005b0:	55cc      	strb	r4, [r1, r7]
*/

static void parseCommand(uint8_t* line)
{
/* ======================== Action commands ========================  */
    if (line[0] == 'a')
 80005b2:	780b      	ldrb	r3, [r1, #0]
indefinitely waiting for input. */
        char character;
        xQueueReceive(commsReceiveQueue,&character,portMAX_DELAY);
        if ((character == 0x0D) || (characterPosition > 78))
        {
            line[characterPosition] = 0;
 80005b4:	4da6      	ldr	r5, [pc, #664]	; (8000850 <prvCommsTask+0x2f0>)
*/

static void parseCommand(uint8_t* line)
{
/* ======================== Action commands ========================  */
    if (line[0] == 'a')
 80005b6:	2b61      	cmp	r3, #97	; 0x61
        char character;
        xQueueReceive(commsReceiveQueue,&character,portMAX_DELAY);
        if ((character == 0x0D) || (characterPosition > 78))
        {
            line[characterPosition] = 0;
            characterPosition = 0;
 80005b8:	7034      	strb	r4, [r6, #0]
*/

static void parseCommand(uint8_t* line)
{
/* ======================== Action commands ========================  */
    if (line[0] == 'a')
 80005ba:	d13f      	bne.n	800063c <prvCommsTask+0xdc>
S followed by battery (1-3, 0 = none) and load (1-2)/panel (3).
Each two-bit field represents a load or panel, and the setting is the
battery to be connected (no two batteries can be connected to a load/panel).
The final bit pattern of settings go into PB8-13.
Preserve the lower 8 bits. */
        switch (line[1])
 80005bc:	786b      	ldrb	r3, [r5, #1]
 80005be:	2b52      	cmp	r3, #82	; 0x52
 80005c0:	d01b      	beq.n	80005fa <prvCommsTask+0x9a>
 80005c2:	d806      	bhi.n	80005d2 <prvCommsTask+0x72>
 80005c4:	2b45      	cmp	r3, #69	; 0x45
 80005c6:	d1de      	bne.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Send an ident response */
        case 'E':
            {
                sendStringLowPriority("DD", "Battery Management System v0.1");
 80005c8:	48a2      	ldr	r0, [pc, #648]	; (8000854 <prvCommsTask+0x2f4>)
 80005ca:	49a3      	ldr	r1, [pc, #652]	; (8000858 <prvCommsTask+0x2f8>)
 80005cc:	f7ff feac 	bl	8000328 <sendStringLowPriority>
 80005d0:	e7d9      	b.n	8000586 <prvCommsTask+0x26>
S followed by battery (1-3, 0 = none) and load (1-2)/panel (3).
Each two-bit field represents a load or panel, and the setting is the
battery to be connected (no two batteries can be connected to a load/panel).
The final bit pattern of settings go into PB8-13.
Preserve the lower 8 bits. */
        switch (line[1])
 80005d2:	2b53      	cmp	r3, #83	; 0x53
 80005d4:	d004      	beq.n	80005e0 <prvCommsTask+0x80>
 80005d6:	2b57      	cmp	r3, #87	; 0x57
 80005d8:	d1d5      	bne.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Write the current configuration block to FLASH */
        case 'W':
            {
                writeConfigBlock();
 80005da:	f002 fbd3 	bl	8002d84 <writeConfigBlock>
 80005de:	e7d2      	b.n	8000586 <prvCommsTask+0x26>
Preserve the lower 8 bits. */
        switch (line[1])
        {
        case 'S':
            {
                uint8_t battery = line[2]-'0';
 80005e0:	78a8      	ldrb	r0, [r5, #2]
                uint8_t setting = line[3]-'0'-1;
 80005e2:	78ed      	ldrb	r5, [r5, #3]
Preserve the lower 8 bits. */
        switch (line[1])
        {
        case 'S':
            {
                uint8_t battery = line[2]-'0';
 80005e4:	3830      	subs	r0, #48	; 0x30
 80005e6:	b2c0      	uxtb	r0, r0
                uint8_t setting = line[3]-'0'-1;
                if ((battery < 4) && (setting < 4)) setSwitch(battery, setting);
 80005e8:	2803      	cmp	r0, #3
 80005ea:	d8cc      	bhi.n	8000586 <prvCommsTask+0x26>
        switch (line[1])
        {
        case 'S':
            {
                uint8_t battery = line[2]-'0';
                uint8_t setting = line[3]-'0'-1;
 80005ec:	3d31      	subs	r5, #49	; 0x31
 80005ee:	b2e9      	uxtb	r1, r5
                if ((battery < 4) && (setting < 4)) setSwitch(battery, setting);
 80005f0:	2903      	cmp	r1, #3
 80005f2:	d8c8      	bhi.n	8000586 <prvCommsTask+0x26>
 80005f4:	f001 ffbc 	bl	8002570 <setSwitch>
 80005f8:	e7c5      	b.n	8000586 <prvCommsTask+0x26>
released. The command is followed by an interface number 0-5 being batteries
1-3, loads 1-2 and module. */
        case 'R':
            {
                portTickType resetTime = 500;
                intf = line[2]-'0';
 80005fa:	78aa      	ldrb	r2, [r5, #2]
 80005fc:	4f97      	ldr	r7, [pc, #604]	; (800085c <prvCommsTask+0x2fc>)
 80005fe:	3a30      	subs	r2, #48	; 0x30
 8000600:	b2d3      	uxtb	r3, r2
                if (intf > NUM_IFS-1) break;
 8000602:	2b05      	cmp	r3, #5
released. The command is followed by an interface number 0-5 being batteries
1-3, loads 1-2 and module. */
        case 'R':
            {
                portTickType resetTime = 500;
                intf = line[2]-'0';
 8000604:	703b      	strb	r3, [r7, #0]
                if (intf > NUM_IFS-1) break;
 8000606:	d8be      	bhi.n	8000586 <prvCommsTask+0x26>
                xTimerHandle resetHandle
 8000608:	4995      	ldr	r1, [pc, #596]	; (8000860 <prvCommsTask+0x300>)
 800060a:	4896      	ldr	r0, [pc, #600]	; (8000864 <prvCommsTask+0x304>)
 800060c:	9100      	str	r1, [sp, #0]
 800060e:	4622      	mov	r2, r4
 8000610:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8000614:	f005 fcec 	bl	8005ff0 <xTimerCreate>
                    = xTimerCreate("Reset",resetTime,pdFALSE,(void *)intf,resetCallback);
                if(resetHandle == NULL) break;
 8000618:	4606      	mov	r6, r0
 800061a:	2800      	cmp	r0, #0
 800061c:	d0b3      	beq.n	8000586 <prvCommsTask+0x26>
                if (xTimerStart(resetHandle,0) != pdPASS) break;
 800061e:	f004 ff8d 	bl	800553c <xTaskGetTickCount>
 8000622:	9400      	str	r4, [sp, #0]
 8000624:	4602      	mov	r2, r0
 8000626:	4621      	mov	r1, r4
 8000628:	4630      	mov	r0, r6
 800062a:	4623      	mov	r3, r4
 800062c:	f005 fcfe 	bl	800602c <xTimerGenericCommand>
 8000630:	2801      	cmp	r0, #1
 8000632:	d1a8      	bne.n	8000586 <prvCommsTask+0x26>
                overCurrentReset(intf);
 8000634:	7838      	ldrb	r0, [r7, #0]
 8000636:	f001 ffc9 	bl	80025cc <overCurrentReset>
 800063a:	e7a4      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
        }
    }
/* ======================== Data request commands ================  */
    else if (line[0] == 'd')
 800063c:	2b64      	cmp	r3, #100	; 0x64
 800063e:	d147      	bne.n	80006d0 <prvCommsTask+0x170>
    {
        switch (line[1])
 8000640:	786b      	ldrb	r3, [r5, #1]
 8000642:	2b42      	cmp	r3, #66	; 0x42
 8000644:	d00c      	beq.n	8000660 <prvCommsTask+0x100>
 8000646:	2b53      	cmp	r3, #83	; 0x53
 8000648:	d19d      	bne.n	8000586 <prvCommsTask+0x26>
        {
/* S Ask for all switch settings to be sent as well as control settings. */
        case 'S':
            {
                sendResponse("dS",(int)getSwitchControlBits());
 800064a:	f001 ffb5 	bl	80025b8 <getSwitchControlBits>
 800064e:	4601      	mov	r1, r0
 8000650:	4885      	ldr	r0, [pc, #532]	; (8000868 <prvCommsTask+0x308>)
 8000652:	f7ff ff23 	bl	800049c <sendResponse>
                uint8_t controlByte = getControls();
 8000656:	f002 fcb5 	bl	8002fc4 <getControls>
                sendResponse("dD",controlByte);
 800065a:	b2c1      	uxtb	r1, r0
 800065c:	4883      	ldr	r0, [pc, #524]	; (800086c <prvCommsTask+0x30c>)
 800065e:	e3dd      	b.n	8000e1c <prvCommsTask+0x8bc>
                break;
            }
/* Bn Ask for battery parameters to be sent */
        case 'B':
            {
                char id[] = "pR0";
 8000660:	4a83      	ldr	r2, [pc, #524]	; (8000870 <prvCommsTask+0x310>)
                id[2] = line[2];
 8000662:	78ad      	ldrb	r5, [r5, #2]
                break;
            }
/* Bn Ask for battery parameters to be sent */
        case 'B':
            {
                char id[] = "pR0";
 8000664:	9206      	str	r2, [sp, #24]
                id[2] = line[2];
 8000666:	f88d 501a 	strb.w	r5, [sp, #26]
                uint8_t battery = line[2] - '1';
 800066a:	3d31      	subs	r5, #49	; 0x31
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
 800066c:	b2ef      	uxtb	r7, r5
 800066e:	4638      	mov	r0, r7
 8000670:	f002 fdfa 	bl	8003268 <getBatteryResistanceAv>
                id[1] = 'T';
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
 8000674:	4d70      	ldr	r5, [pc, #448]	; (8000838 <prvCommsTask+0x2d8>)
        case 'B':
            {
                char id[] = "pR0";
                id[2] = line[2];
                uint8_t battery = line[2] - '1';
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
 8000676:	4601      	mov	r1, r0
 8000678:	4622      	mov	r2, r4
 800067a:	a806      	add	r0, sp, #24
 800067c:	f7ff ff3a 	bl	80004f4 <dataMessageSend>
                id[1] = 'T';
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
 8000680:	19ee      	adds	r6, r5, r7
                                   (int32_t)configData.config.batteryCapacity[battery]);
 8000682:	eb05 0347 	add.w	r3, r5, r7, lsl #1
                char id[] = "pR0";
                id[2] = line[2];
                uint8_t battery = line[2] - '1';
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
                id[1] = 'T';
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
 8000686:	885a      	ldrh	r2, [r3, #2]
            {
                char id[] = "pR0";
                id[2] = line[2];
                uint8_t battery = line[2] - '1';
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
                id[1] = 'T';
 8000688:	2454      	movs	r4, #84	; 0x54
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
 800068a:	a806      	add	r0, sp, #24
 800068c:	7a31      	ldrb	r1, [r6, #8]
            {
                char id[] = "pR0";
                id[2] = line[2];
                uint8_t battery = line[2] - '1';
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
                id[1] = 'T';
 800068e:	f88d 4019 	strb.w	r4, [sp, #25]
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
 8000692:	f7ff ff2f 	bl	80004f4 <dataMessageSend>
                                   (int32_t)configData.config.batteryCapacity[battery]);
                id[1] = 'F';
                dataMessageSend(id,(int32_t)configData.config.floatStageCurrentScale[battery],
 8000696:	f107 040c 	add.w	r4, r7, #12
                uint8_t battery = line[2] - '1';
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
                id[1] = 'T';
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
                                   (int32_t)configData.config.batteryCapacity[battery]);
                id[1] = 'F';
 800069a:	2046      	movs	r0, #70	; 0x46
                dataMessageSend(id,(int32_t)configData.config.floatStageCurrentScale[battery],
                                   (int32_t)configData.config.floatVoltage[battery]);
 800069c:	eb05 0247 	add.w	r2, r5, r7, lsl #1
                uint8_t battery = line[2] - '1';
                dataMessageSend(id,getBatteryResistanceAv(battery),0);
                id[1] = 'T';
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
                                   (int32_t)configData.config.batteryCapacity[battery]);
                id[1] = 'F';
 80006a0:	f88d 0019 	strb.w	r0, [sp, #25]
                dataMessageSend(id,(int32_t)configData.config.floatStageCurrentScale[battery],
 80006a4:	f935 1014 	ldrsh.w	r1, [r5, r4, lsl #1]
 80006a8:	a806      	add	r0, sp, #24
 80006aa:	f9b2 2012 	ldrsh.w	r2, [r2, #18]
 80006ae:	f7ff ff21 	bl	80004f4 <dataMessageSend>
                                   (int32_t)configData.config.floatVoltage[battery]);
                id[1] = 'A';
                dataMessageSend(id,(int32_t)configData.config.bulkCurrentLimitScale[battery],
 80006b2:	eb05 0644 	add.w	r6, r5, r4, lsl #1
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
                                   (int32_t)configData.config.batteryCapacity[battery]);
                id[1] = 'F';
                dataMessageSend(id,(int32_t)configData.config.floatStageCurrentScale[battery],
                                   (int32_t)configData.config.floatVoltage[battery]);
                id[1] = 'A';
 80006b6:	2141      	movs	r1, #65	; 0x41
                dataMessageSend(id,(int32_t)configData.config.bulkCurrentLimitScale[battery],
                                   (int32_t)configData.config.absorptionVoltage[battery]);
 80006b8:	eb05 0747 	add.w	r7, r5, r7, lsl #1
                dataMessageSend(id,(int32_t)configData.config.batteryType[battery],
                                   (int32_t)configData.config.batteryCapacity[battery]);
                id[1] = 'F';
                dataMessageSend(id,(int32_t)configData.config.floatStageCurrentScale[battery],
                                   (int32_t)configData.config.floatVoltage[battery]);
                id[1] = 'A';
 80006bc:	f88d 1019 	strb.w	r1, [sp, #25]
                dataMessageSend(id,(int32_t)configData.config.bulkCurrentLimitScale[battery],
 80006c0:	a806      	add	r0, sp, #24
 80006c2:	f9b6 1006 	ldrsh.w	r1, [r6, #6]
 80006c6:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 80006ca:	f7ff ff13 	bl	80004f4 <dataMessageSend>
 80006ce:	e75a      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
        }
    }
/* ================ Parameter setting commands ================  */
    else if (line[0] == 'p')
 80006d0:	2b70      	cmp	r3, #112	; 0x70
 80006d2:	f040 80ef 	bne.w	80008b4 <prvCommsTask+0x354>
    {
        uint8_t battery = line[2]-'1';
 80006d6:	78a9      	ldrb	r1, [r5, #2]
        switch (line[1])
 80006d8:	786a      	ldrb	r2, [r5, #1]
        }
    }
/* ================ Parameter setting commands ================  */
    else if (line[0] == 'p')
    {
        uint8_t battery = line[2]-'1';
 80006da:	f1a1 0331 	sub.w	r3, r1, #49	; 0x31
        switch (line[1])
 80006de:	2a4d      	cmp	r2, #77	; 0x4d
        }
    }
/* ================ Parameter setting commands ================  */
    else if (line[0] == 'p')
    {
        uint8_t battery = line[2]-'1';
 80006e0:	b2de      	uxtb	r6, r3
        switch (line[1])
 80006e2:	d07b      	beq.n	80007dc <prvCommsTask+0x27c>
 80006e4:	d812      	bhi.n	800070c <prvCommsTask+0x1ac>
 80006e6:	2a44      	cmp	r2, #68	; 0x44
 80006e8:	d049      	beq.n	800077e <prvCommsTask+0x21e>
 80006ea:	d807      	bhi.n	80006fc <prvCommsTask+0x19c>
 80006ec:	2a41      	cmp	r2, #65	; 0x41
 80006ee:	d02d      	beq.n	800074c <prvCommsTask+0x1ec>
 80006f0:	2a43      	cmp	r2, #67	; 0x43
 80006f2:	f47f af48 	bne.w	8000586 <prvCommsTask+0x26>
                break;
            }
/* C Start a calibration sequence */
        case 'C':
            {
                startCalibration();
 80006f6:	f001 fcdb 	bl	80020b0 <startCalibration>
 80006fa:	e744      	b.n	8000586 <prvCommsTask+0x26>
    }
/* ================ Parameter setting commands ================  */
    else if (line[0] == 'p')
    {
        uint8_t battery = line[2]-'1';
        switch (line[1])
 80006fc:	2a48      	cmp	r2, #72	; 0x48
 80006fe:	d05e      	beq.n	80007be <prvCommsTask+0x25e>
 8000700:	2a49      	cmp	r2, #73	; 0x49
 8000702:	d060      	beq.n	80007c6 <prvCommsTask+0x266>
 8000704:	2a46      	cmp	r2, #70	; 0x46
 8000706:	f47f af3e 	bne.w	8000586 <prvCommsTask+0x26>
 800070a:	e04d      	b.n	80007a8 <prvCommsTask+0x248>
 800070c:	2a64      	cmp	r2, #100	; 0x64
 800070e:	d028      	beq.n	8000762 <prvCommsTask+0x202>
 8000710:	d808      	bhi.n	8000724 <prvCommsTask+0x1c4>
 8000712:	2a54      	cmp	r2, #84	; 0x54
 8000714:	f000 80b8 	beq.w	8000888 <prvCommsTask+0x328>
 8000718:	2a61      	cmp	r2, #97	; 0x61
 800071a:	d00b      	beq.n	8000734 <prvCommsTask+0x1d4>
 800071c:	2a53      	cmp	r2, #83	; 0x53
 800071e:	f47f af32 	bne.w	8000586 <prvCommsTask+0x26>
 8000722:	e083      	b.n	800082c <prvCommsTask+0x2cc>
 8000724:	2a72      	cmp	r2, #114	; 0x72
 8000726:	d067      	beq.n	80007f8 <prvCommsTask+0x298>
 8000728:	2a73      	cmp	r2, #115	; 0x73
 800072a:	d078      	beq.n	800081e <prvCommsTask+0x2be>
 800072c:	2a66      	cmp	r2, #102	; 0x66
 800072e:	f47f af2a 	bne.w	8000586 <prvCommsTask+0x26>
 8000732:	e02e      	b.n	8000792 <prvCommsTask+0x232>
        {
/* a-, a+ Turn autoTracking on or off */
        case 'a':
            {
                if (line[2] == '-') configData.config.autoTrack = false;
 8000734:	292d      	cmp	r1, #45	; 0x2d
 8000736:	d101      	bne.n	800073c <prvCommsTask+0x1dc>
 8000738:	2400      	movs	r4, #0
 800073a:	e003      	b.n	8000744 <prvCommsTask+0x1e4>
                else if (line[2] == '+') configData.config.autoTrack = true;
 800073c:	292b      	cmp	r1, #43	; 0x2b
 800073e:	f47f af22 	bne.w	8000586 <prvCommsTask+0x26>
 8000742:	2401      	movs	r4, #1
 8000744:	4d3c      	ldr	r5, [pc, #240]	; (8000838 <prvCommsTask+0x2d8>)
 8000746:	f885 402d 	strb.w	r4, [r5, #45]	; 0x2d
 800074a:	e71c      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Anxx Set battery absorption voltage limit, n is battery, xx is limit */
        case 'A':
            {
                if (battery < 3)
 800074c:	2e02      	cmp	r6, #2
 800074e:	f63f af1a 	bhi.w	8000586 <prvCommsTask+0x26>
                    configData.config.absorptionVoltage[battery] = asciiToInt((char*)line+3);
 8000752:	1ce8      	adds	r0, r5, #3
 8000754:	f002 f966 	bl	8002a24 <asciiToInt>
 8000758:	4c37      	ldr	r4, [pc, #220]	; (8000838 <prvCommsTask+0x2d8>)
 800075a:	eb04 0546 	add.w	r5, r4, r6, lsl #1
 800075e:	81a8      	strh	r0, [r5, #12]
 8000760:	e711      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* d Turn on debug messages */
        case 'd':
            {
                if (line[2] == '+') configData.config.debugMessageSend = true;
 8000762:	292b      	cmp	r1, #43	; 0x2b
 8000764:	d104      	bne.n	8000770 <prvCommsTask+0x210>
 8000766:	4e34      	ldr	r6, [pc, #208]	; (8000838 <prvCommsTask+0x2d8>)
 8000768:	2501      	movs	r5, #1
 800076a:	f886 502b 	strb.w	r5, [r6, #43]	; 0x2b
 800076e:	e70a      	b.n	8000586 <prvCommsTask+0x26>
                if (line[2] == '-') configData.config.debugMessageSend = false;
 8000770:	292d      	cmp	r1, #45	; 0x2d
 8000772:	f47f af08 	bne.w	8000586 <prvCommsTask+0x26>
 8000776:	4a30      	ldr	r2, [pc, #192]	; (8000838 <prvCommsTask+0x2d8>)
 8000778:	f882 402b 	strb.w	r4, [r2, #43]	; 0x2b
 800077c:	e703      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Dxx Set charger duty cycle (debug only) */
        case 'D':
            {
                uint8_t dutyCycle = asciiToInt((char*)line+2);
 800077e:	1ca8      	adds	r0, r5, #2
 8000780:	f002 f950 	bl	8002a24 <asciiToInt>
 8000784:	b2c0      	uxtb	r0, r0
                if (dutyCycle > 99) dutyCycle = 99;
                pwmSetDutyCycle(dutyCycle);
 8000786:	2863      	cmp	r0, #99	; 0x63
 8000788:	bf28      	it	cs
 800078a:	2063      	movcs	r0, #99	; 0x63
 800078c:	f001 ff78 	bl	8002680 <pwmSetDutyCycle>
 8000790:	e6f9      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* fnxx Set battery float current trigger, n is battery, xx is trigger */
        case 'f':
            {
                if (battery < 3)
 8000792:	2e02      	cmp	r6, #2
 8000794:	f63f aef7 	bhi.w	8000586 <prvCommsTask+0x26>
                    configData.config.floatStageCurrentScale[battery] = asciiToInt((char*)line+3);
 8000798:	4836      	ldr	r0, [pc, #216]	; (8000874 <prvCommsTask+0x314>)
 800079a:	f002 f943 	bl	8002a24 <asciiToInt>
 800079e:	4d26      	ldr	r5, [pc, #152]	; (8000838 <prvCommsTask+0x2d8>)
 80007a0:	360c      	adds	r6, #12
 80007a2:	f825 0016 	strh.w	r0, [r5, r6, lsl #1]
 80007a6:	e6ee      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Fnxx Set battery float voltage limit, n is battery, xx is limit */
        case 'F':
            {
                if (battery < 3)
 80007a8:	2e02      	cmp	r6, #2
 80007aa:	f63f aeec 	bhi.w	8000586 <prvCommsTask+0x26>
                    configData.config.floatVoltage[battery] = asciiToInt((char*)line+3);
 80007ae:	4831      	ldr	r0, [pc, #196]	; (8000874 <prvCommsTask+0x314>)
 80007b0:	f002 f938 	bl	8002a24 <asciiToInt>
 80007b4:	4f20      	ldr	r7, [pc, #128]	; (8000838 <prvCommsTask+0x2d8>)
 80007b6:	eb07 0146 	add.w	r1, r7, r6, lsl #1
 80007ba:	8248      	strh	r0, [r1, #18]
 80007bc:	e6e3      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Hxx Set time from an ISO formatted string. */
        case 'H':
            {
                setTimeFromString((char*)line+2);
 80007be:	1ca8      	adds	r0, r5, #2
 80007c0:	f002 fa64 	bl	8002c8c <setTimeFromString>
 80007c4:	e6df      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Inxx Set bulk current limit, n is battery, xx is limit */
        case 'I':
            {
                if (battery < 3)
 80007c6:	2e02      	cmp	r6, #2
 80007c8:	f63f aedd 	bhi.w	8000586 <prvCommsTask+0x26>
                    configData.config.bulkCurrentLimitScale[battery] = asciiToInt((char*)line+3);
 80007cc:	4829      	ldr	r0, [pc, #164]	; (8000874 <prvCommsTask+0x314>)
 80007ce:	f002 f929 	bl	8002a24 <asciiToInt>
 80007d2:	4b19      	ldr	r3, [pc, #100]	; (8000838 <prvCommsTask+0x2d8>)
 80007d4:	eb03 0646 	add.w	r6, r3, r6, lsl #1
 80007d8:	83f0      	strh	r0, [r6, #30]
 80007da:	e6d4      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* M-, M+ Turn on/off data messaging (mainly for debug) */
        case 'M':
            {
                if (line[2] == '-') configData.config.measurementSend = false;
 80007dc:	292d      	cmp	r1, #45	; 0x2d
 80007de:	d103      	bne.n	80007e8 <prvCommsTask+0x288>
 80007e0:	4915      	ldr	r1, [pc, #84]	; (8000838 <prvCommsTask+0x2d8>)
 80007e2:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
 80007e6:	e6ce      	b.n	8000586 <prvCommsTask+0x26>
                if (line[2] == '+') configData.config.measurementSend = true;
 80007e8:	292b      	cmp	r1, #43	; 0x2b
 80007ea:	f47f aecc 	bne.w	8000586 <prvCommsTask+0x26>
 80007ee:	4f12      	ldr	r7, [pc, #72]	; (8000838 <prvCommsTask+0x2d8>)
 80007f0:	2001      	movs	r0, #1
 80007f2:	f887 002a 	strb.w	r0, [r7, #42]	; 0x2a
 80007f6:	e6c6      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* r-, r+ Turn recording on or off */
        case 'r':
            {
                if (line[2] == '-') configData.config.recording = false;
 80007f8:	292d      	cmp	r1, #45	; 0x2d
 80007fa:	d103      	bne.n	8000804 <prvCommsTask+0x2a4>
 80007fc:	4b0e      	ldr	r3, [pc, #56]	; (8000838 <prvCommsTask+0x2d8>)
 80007fe:	f883 402c 	strb.w	r4, [r3, #44]	; 0x2c
 8000802:	e6c0      	b.n	8000586 <prvCommsTask+0x26>
                else if ((line[2] == '+') && (writeFileHandle < 0x0FF))
 8000804:	292b      	cmp	r1, #43	; 0x2b
 8000806:	f47f aebe 	bne.w	8000586 <prvCommsTask+0x26>
 800080a:	480d      	ldr	r0, [pc, #52]	; (8000840 <prvCommsTask+0x2e0>)
 800080c:	7807      	ldrb	r7, [r0, #0]
 800080e:	2fff      	cmp	r7, #255	; 0xff
 8000810:	f43f aeb9 	beq.w	8000586 <prvCommsTask+0x26>
                    configData.config.recording = true;
 8000814:	4c08      	ldr	r4, [pc, #32]	; (8000838 <prvCommsTask+0x2d8>)
 8000816:	2101      	movs	r1, #1
 8000818:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
 800081c:	e6b3      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* sn Set monitor strategy byte n */
        case 's':
            {
                configData.config.monitorStrategy = asciiToInt((char*)line+3);
 800081e:	1ce8      	adds	r0, r5, #3
 8000820:	f002 f900 	bl	8002a24 <asciiToInt>
 8000824:	4e04      	ldr	r6, [pc, #16]	; (8000838 <prvCommsTask+0x2d8>)
 8000826:	f886 002f 	strb.w	r0, [r6, #47]	; 0x2f
 800082a:	e6ac      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* S-, S+ Turn switch avoidance on or off */
        case 'S':
            {
                if (line[2] == '-') configData.config.switchAvoidance = false;
 800082c:	292d      	cmp	r1, #45	; 0x2d
 800082e:	d123      	bne.n	8000878 <prvCommsTask+0x318>
 8000830:	2000      	movs	r0, #0
 8000832:	e025      	b.n	8000880 <prvCommsTask+0x320>
 8000834:	2000003a 	.word	0x2000003a
 8000838:	200008c8 	.word	0x200008c8
 800083c:	20000024 	.word	0x20000024
 8000840:	20000039 	.word	0x20000039
 8000844:	20000032 	.word	0x20000032
 8000848:	20000014 	.word	0x20000014
 800084c:	20000038 	.word	0x20000038
 8000850:	20000096 	.word	0x20000096
 8000854:	080074e1 	.word	0x080074e1
 8000858:	080074e4 	.word	0x080074e4
 800085c:	20000031 	.word	0x20000031
 8000860:	0800024d 	.word	0x0800024d
 8000864:	080074db 	.word	0x080074db
 8000868:	08007503 	.word	0x08007503
 800086c:	08007506 	.word	0x08007506
 8000870:	00305270 	.word	0x00305270
 8000874:	20000099 	.word	0x20000099
                if (line[2] == '+') configData.config.switchAvoidance = true;
 8000878:	292b      	cmp	r1, #43	; 0x2b
 800087a:	f47f ae84 	bne.w	8000586 <prvCommsTask+0x26>
 800087e:	2001      	movs	r0, #1
 8000880:	4abc      	ldr	r2, [pc, #752]	; (8000b74 <prvCommsTask+0x614>)
 8000882:	f882 002e 	strb.w	r0, [r2, #46]	; 0x2e
 8000886:	e67e      	b.n	8000586 <prvCommsTask+0x26>
                break;
            }
/* Tntxx Set battery type and capacity, n is battery, t is type, xx is capacity */
        case 'T':
            {
                if (battery < 3)
 8000888:	2e02      	cmp	r6, #2
 800088a:	f63f ae7c 	bhi.w	8000586 <prvCommsTask+0x26>
                {
                    uint8_t type = line[3]-'0';
 800088e:	78ef      	ldrb	r7, [r5, #3]
 8000890:	3f30      	subs	r7, #48	; 0x30
 8000892:	b2f9      	uxtb	r1, r7
                    if (type < 3)
 8000894:	2902      	cmp	r1, #2
 8000896:	f63f ae76 	bhi.w	8000586 <prvCommsTask+0x26>
                    {
                        configData.config.batteryType[battery] = (battery_Type)type;
 800089a:	4cb6      	ldr	r4, [pc, #728]	; (8000b74 <prvCommsTask+0x614>)
                        configData.config.batteryCapacity[battery] = asciiToInt((char*)line+4);
 800089c:	48b6      	ldr	r0, [pc, #728]	; (8000b78 <prvCommsTask+0x618>)
                if (battery < 3)
                {
                    uint8_t type = line[3]-'0';
                    if (type < 3)
                    {
                        configData.config.batteryType[battery] = (battery_Type)type;
 800089e:	19a3      	adds	r3, r4, r6
 80008a0:	7219      	strb	r1, [r3, #8]
                        configData.config.batteryCapacity[battery] = asciiToInt((char*)line+4);
 80008a2:	f002 f8bf 	bl	8002a24 <asciiToInt>
 80008a6:	eb04 0246 	add.w	r2, r4, r6, lsl #1
 80008aa:	8050      	strh	r0, [r2, #2]
                        setBatteryChargeParameters(battery);
 80008ac:	4630      	mov	r0, r6
 80008ae:	f002 fa75 	bl	8002d9c <setBatteryChargeParameters>
 80008b2:	e668      	b.n	8000586 <prvCommsTask+0x26>
s           - Get status of open files and configData.config.recording flag
M           - Mount the SD card.
All commands return an error status byte at the end.
Only one file for writing and a second for reading is possible.
Data is not written to the file externally. */
    else if (line[0] == 'f')
 80008b4:	2b66      	cmp	r3, #102	; 0x66
 80008b6:	f47f ae66 	bne.w	8000586 <prvCommsTask+0x26>
    {
        switch (line[1])
 80008ba:	786e      	ldrb	r6, [r5, #1]
 80008bc:	2e4d      	cmp	r6, #77	; 0x4d
 80008be:	f000 828b 	beq.w	8000dd8 <prvCommsTask+0x878>
 80008c2:	d80d      	bhi.n	80008e0 <prvCommsTask+0x380>
 80008c4:	2e44      	cmp	r6, #68	; 0x44
 80008c6:	f000 81b2 	beq.w	8000c2e <prvCommsTask+0x6ce>
 80008ca:	d803      	bhi.n	80008d4 <prvCommsTask+0x374>
 80008cc:	2e43      	cmp	r6, #67	; 0x43
 80008ce:	f47f ae5a 	bne.w	8000586 <prvCommsTask+0x26>
 80008d2:	e0c2      	b.n	8000a5a <prvCommsTask+0x4fa>
 80008d4:	2e46      	cmp	r6, #70	; 0x46
 80008d6:	d011      	beq.n	80008fc <prvCommsTask+0x39c>
 80008d8:	2e47      	cmp	r6, #71	; 0x47
 80008da:	f47f ae54 	bne.w	8000586 <prvCommsTask+0x26>
 80008de:	e0f4      	b.n	8000aca <prvCommsTask+0x56a>
 80008e0:	2e57      	cmp	r6, #87	; 0x57
 80008e2:	d05c      	beq.n	800099e <prvCommsTask+0x43e>
 80008e4:	d803      	bhi.n	80008ee <prvCommsTask+0x38e>
 80008e6:	2e52      	cmp	r6, #82	; 0x52
 80008e8:	f47f ae4d 	bne.w	8000586 <prvCommsTask+0x26>
 80008ec:	e082      	b.n	80009f4 <prvCommsTask+0x494>
 80008ee:	2e58      	cmp	r6, #88	; 0x58
 80008f0:	f000 8254 	beq.w	8000d9c <prvCommsTask+0x83c>
 80008f4:	2e73      	cmp	r6, #115	; 0x73
 80008f6:	f47f ae46 	bne.w	8000586 <prvCommsTask+0x26>
 80008fa:	e212      	b.n	8000d22 <prvCommsTask+0x7c2>
            {
                uint8_t wordBuf;
                uint32_t freeClusters = 0;
                uint32_t sectorCluster = 0;
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 80008fc:	489f      	ldr	r0, [pc, #636]	; (8000b7c <prvCommsTask+0x61c>)
            case 'F':
            {
                uint8_t wordBuf;
                uint32_t freeClusters = 0;
                uint32_t sectorCluster = 0;
                uint8_t fileStatus = FR_INT_ERR;
 80008fe:	2202      	movs	r2, #2
 8000900:	f88d 2013 	strb.w	r2, [sp, #19]
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000904:	6800      	ldr	r0, [r0, #0]
 8000906:	4621      	mov	r1, r4
 8000908:	2264      	movs	r2, #100	; 0x64
 800090a:	4623      	mov	r3, r4
 800090c:	f005 fa37 	bl	8005d7e <xQueueGenericReceive>
 8000910:	2800      	cmp	r0, #0
 8000912:	f000 8280 	beq.w	8000e16 <prvCommsTask+0x8b6>
                {
                    sendFileCommand('F',0,line+2);
 8000916:	2046      	movs	r0, #70	; 0x46
 8000918:	2100      	movs	r1, #0
 800091a:	4a99      	ldr	r2, [pc, #612]	; (8000b80 <prvCommsTask+0x620>)
 800091c:	f000 fd5e 	bl	80013dc <sendFileCommand>
 8000920:	2600      	movs	r6, #0
        {
/* Return number of free clusters followed by the cluster size in bytes. */
            case 'F':
            {
                uint8_t wordBuf;
                uint32_t freeClusters = 0;
 8000922:	4637      	mov	r7, r6
                    sendFileCommand('F',0,line+2);
                    uint8_t i;
                    for (i=0; i<4; i++)
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
 8000924:	4b97      	ldr	r3, [pc, #604]	; (8000b84 <prvCommsTask+0x624>)
                {
                    sendFileCommand('F',0,line+2);
                    uint8_t i;
                    for (i=0; i<4; i++)
                    {
                        wordBuf = 0;
 8000926:	2400      	movs	r4, #0
 8000928:	a91a      	add	r1, sp, #104	; 0x68
 800092a:	f801 4d56 	strb.w	r4, [r1, #-86]!
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
 800092e:	6818      	ldr	r0, [r3, #0]
 8000930:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000934:	4623      	mov	r3, r4
 8000936:	f005 fa22 	bl	8005d7e <xQueueGenericReceive>
                        freeClusters |= (wordBuf << 8*i);
 800093a:	f89d 1012 	ldrb.w	r1, [sp, #18]
 800093e:	fa01 f106 	lsl.w	r1, r1, r6
 8000942:	3608      	adds	r6, #8
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
                {
                    sendFileCommand('F',0,line+2);
                    uint8_t i;
                    for (i=0; i<4; i++)
 8000944:	2e20      	cmp	r6, #32
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        freeClusters |= (wordBuf << 8*i);
 8000946:	ea47 0701 	orr.w	r7, r7, r1
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
                {
                    sendFileCommand('F',0,line+2);
                    uint8_t i;
                    for (i=0; i<4; i++)
 800094a:	d1eb      	bne.n	8000924 <prvCommsTask+0x3c4>
 800094c:	4626      	mov	r6, r4
                        freeClusters |= (wordBuf << 8*i);
                    }
                    for (i=0; i<4; i++)
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
 800094e:	f8df 8234 	ldr.w	r8, [pc, #564]	; 8000b84 <prvCommsTask+0x624>
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        freeClusters |= (wordBuf << 8*i);
                    }
                    for (i=0; i<4; i++)
                    {
                        wordBuf = 0;
 8000952:	2500      	movs	r5, #0
 8000954:	a91a      	add	r1, sp, #104	; 0x68
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
 8000956:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        freeClusters |= (wordBuf << 8*i);
                    }
                    for (i=0; i<4; i++)
                    {
                        wordBuf = 0;
 800095a:	f801 5d56 	strb.w	r5, [r1, #-86]!
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
 800095e:	f8d8 0000 	ldr.w	r0, [r8]
 8000962:	462b      	mov	r3, r5
 8000964:	f005 fa0b 	bl	8005d7e <xQueueGenericReceive>
                        sectorCluster |= (wordBuf << 8*i);
 8000968:	f89d 2012 	ldrb.w	r2, [sp, #18]
 800096c:	fa02 f204 	lsl.w	r2, r2, r4
 8000970:	3408      	adds	r4, #8
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        freeClusters |= (wordBuf << 8*i);
                    }
                    for (i=0; i<4; i++)
 8000972:	2c20      	cmp	r4, #32
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        sectorCluster |= (wordBuf << 8*i);
 8000974:	ea46 0602 	orr.w	r6, r6, r2
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        freeClusters |= (wordBuf << 8*i);
                    }
                    for (i=0; i<4; i++)
 8000978:	d1e9      	bne.n	800094e <prvCommsTask+0x3ee>
                    {
                        wordBuf = 0;
                        xQueueReceive(fileReceiveQueue,&wordBuf,portMAX_DELAY);
                        sectorCluster |= (wordBuf << 8*i);
                    }
                    dataMessageSend("fF",freeClusters,sectorCluster);
 800097a:	4883      	ldr	r0, [pc, #524]	; (8000b88 <prvCommsTask+0x628>)
 800097c:	4639      	mov	r1, r7
 800097e:	4632      	mov	r2, r6
 8000980:	f7ff fdb8 	bl	80004f4 <dataMessageSend>
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000984:	f10d 0113 	add.w	r1, sp, #19
 8000988:	f8d8 0000 	ldr.w	r0, [r8]
 800098c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000990:	462b      	mov	r3, r5
 8000992:	f005 f9f4 	bl	8005d7e <xQueueGenericReceive>
                    xSemaphoreGive(fileSendSemaphore);
 8000996:	4879      	ldr	r0, [pc, #484]	; (8000b7c <prvCommsTask+0x61c>)
 8000998:	4629      	mov	r1, r5
 800099a:	6800      	ldr	r0, [r0, #0]
 800099c:	e237      	b.n	8000e0e <prvCommsTask+0x8ae>
                break;
            }
/* Open a file for writing */
            case 'W':
            {
                if (stringLength((char*)line+2) < 12)
 800099e:	1ca8      	adds	r0, r5, #2
 80009a0:	f002 f88c 	bl	8002abc <stringLength>
 80009a4:	280b      	cmp	r0, #11
 80009a6:	f63f adee 	bhi.w	8000586 <prvCommsTask+0x26>
                {
                    uint8_t fileStatus = FR_INT_ERR;
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 80009aa:	4f74      	ldr	r7, [pc, #464]	; (8000b7c <prvCommsTask+0x61c>)
/* Open a file for writing */
            case 'W':
            {
                if (stringLength((char*)line+2) < 12)
                {
                    uint8_t fileStatus = FR_INT_ERR;
 80009ac:	2202      	movs	r2, #2
 80009ae:	f88d 2013 	strb.w	r2, [sp, #19]
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 80009b2:	6838      	ldr	r0, [r7, #0]
 80009b4:	4621      	mov	r1, r4
 80009b6:	2264      	movs	r2, #100	; 0x64
 80009b8:	4623      	mov	r3, r4
 80009ba:	f005 f9e0 	bl	8005d7e <xQueueGenericReceive>
 80009be:	2800      	cmp	r0, #0
 80009c0:	f000 8229 	beq.w	8000e16 <prvCommsTask+0x8b6>
                    {
                        stringCopy(writeFileName,(char*)line+2);
 80009c4:	1ca9      	adds	r1, r5, #2
 80009c6:	4871      	ldr	r0, [pc, #452]	; (8000b8c <prvCommsTask+0x62c>)
 80009c8:	f002 f870 	bl	8002aac <stringCopy>
                        sendFileCommand('W',13,line+2);
 80009cc:	4630      	mov	r0, r6
 80009ce:	1caa      	adds	r2, r5, #2
                        xQueueReceive(fileReceiveQueue,&writeFileHandle,portMAX_DELAY);
 80009d0:	4e6f      	ldr	r6, [pc, #444]	; (8000b90 <prvCommsTask+0x630>)
 80009d2:	4d6c      	ldr	r5, [pc, #432]	; (8000b84 <prvCommsTask+0x624>)
                {
                    uint8_t fileStatus = FR_INT_ERR;
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
                    {
                        stringCopy(writeFileName,(char*)line+2);
                        sendFileCommand('W',13,line+2);
 80009d4:	210d      	movs	r1, #13
 80009d6:	f000 fd01 	bl	80013dc <sendFileCommand>
                        xQueueReceive(fileReceiveQueue,&writeFileHandle,portMAX_DELAY);
 80009da:	4631      	mov	r1, r6
 80009dc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80009e0:	4623      	mov	r3, r4
 80009e2:	6828      	ldr	r0, [r5, #0]
 80009e4:	f005 f9cb 	bl	8005d7e <xQueueGenericReceive>
                        sendResponse("fW",writeFileHandle);
 80009e8:	486a      	ldr	r0, [pc, #424]	; (8000b94 <prvCommsTask+0x634>)
 80009ea:	7831      	ldrb	r1, [r6, #0]
 80009ec:	f7ff fd56 	bl	800049c <sendResponse>
                        xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 80009f0:	6828      	ldr	r0, [r5, #0]
 80009f2:	e203      	b.n	8000dfc <prvCommsTask+0x89c>
                break;
            }
/* Open a file for Reading */
            case 'R':
            {
                if (stringLength((char*)line+2) < 12)
 80009f4:	1ca8      	adds	r0, r5, #2
 80009f6:	f002 f861 	bl	8002abc <stringLength>
 80009fa:	280b      	cmp	r0, #11
 80009fc:	f63f adc3 	bhi.w	8000586 <prvCommsTask+0x26>
                {
                    uint8_t fileStatus = FR_INT_ERR;
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000a00:	4f5e      	ldr	r7, [pc, #376]	; (8000b7c <prvCommsTask+0x61c>)
/* Open a file for Reading */
            case 'R':
            {
                if (stringLength((char*)line+2) < 12)
                {
                    uint8_t fileStatus = FR_INT_ERR;
 8000a02:	2302      	movs	r3, #2
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000a04:	2100      	movs	r1, #0
/* Open a file for Reading */
            case 'R':
            {
                if (stringLength((char*)line+2) < 12)
                {
                    uint8_t fileStatus = FR_INT_ERR;
 8000a06:	f88d 3013 	strb.w	r3, [sp, #19]
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000a0a:	6838      	ldr	r0, [r7, #0]
 8000a0c:	2264      	movs	r2, #100	; 0x64
 8000a0e:	460b      	mov	r3, r1
 8000a10:	f005 f9b5 	bl	8005d7e <xQueueGenericReceive>
 8000a14:	2800      	cmp	r0, #0
 8000a16:	f000 81fe 	beq.w	8000e16 <prvCommsTask+0x8b6>
                    {
                        stringCopy(readFileName,(char*)line+2);
 8000a1a:	485f      	ldr	r0, [pc, #380]	; (8000b98 <prvCommsTask+0x638>)
 8000a1c:	4958      	ldr	r1, [pc, #352]	; (8000b80 <prvCommsTask+0x620>)
                        sendFileCommand('R',13,line+2);
                        xQueueReceive(fileReceiveQueue,&readFileHandle,portMAX_DELAY);
 8000a1e:	4c59      	ldr	r4, [pc, #356]	; (8000b84 <prvCommsTask+0x624>)
 8000a20:	4e5e      	ldr	r6, [pc, #376]	; (8000b9c <prvCommsTask+0x63c>)
                if (stringLength((char*)line+2) < 12)
                {
                    uint8_t fileStatus = FR_INT_ERR;
                    if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
                    {
                        stringCopy(readFileName,(char*)line+2);
 8000a22:	f002 f843 	bl	8002aac <stringCopy>
                        sendFileCommand('R',13,line+2);
 8000a26:	2052      	movs	r0, #82	; 0x52
 8000a28:	210d      	movs	r1, #13
 8000a2a:	4a55      	ldr	r2, [pc, #340]	; (8000b80 <prvCommsTask+0x620>)
 8000a2c:	f000 fcd6 	bl	80013dc <sendFileCommand>
                        xQueueReceive(fileReceiveQueue,&readFileHandle,portMAX_DELAY);
 8000a30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000a34:	2300      	movs	r3, #0
 8000a36:	4631      	mov	r1, r6
 8000a38:	6820      	ldr	r0, [r4, #0]
 8000a3a:	f005 f9a0 	bl	8005d7e <xQueueGenericReceive>
                        sendResponse("fR",readFileHandle);
 8000a3e:	4858      	ldr	r0, [pc, #352]	; (8000ba0 <prvCommsTask+0x640>)
 8000a40:	7831      	ldrb	r1, [r6, #0]
 8000a42:	f7ff fd2b 	bl	800049c <sendResponse>
                        xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000a46:	6820      	ldr	r0, [r4, #0]
 8000a48:	f10d 0113 	add.w	r1, sp, #19
 8000a4c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000a50:	2300      	movs	r3, #0
 8000a52:	f005 f994 	bl	8005d7e <xQueueGenericReceive>
                        xSemaphoreGive(fileSendSemaphore);
 8000a56:	6838      	ldr	r0, [r7, #0]
 8000a58:	e1bc      	b.n	8000dd4 <prvCommsTask+0x874>
            }
/* Close file for write or read file. The file handle is a two character integer. */
            case 'C':
            {
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000a5a:	4948      	ldr	r1, [pc, #288]	; (8000b7c <prvCommsTask+0x61c>)
                break;
            }
/* Close file for write or read file. The file handle is a two character integer. */
            case 'C':
            {
                uint8_t fileStatus = FR_INT_ERR;
 8000a5c:	2002      	movs	r0, #2
 8000a5e:	f88d 0012 	strb.w	r0, [sp, #18]
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000a62:	2264      	movs	r2, #100	; 0x64
 8000a64:	6808      	ldr	r0, [r1, #0]
 8000a66:	4623      	mov	r3, r4
 8000a68:	4621      	mov	r1, r4
 8000a6a:	f005 f988 	bl	8005d7e <xQueueGenericReceive>
 8000a6e:	b340      	cbz	r0, 8000ac2 <prvCommsTask+0x562>
                {
                    uint8_t fileHandle = asciiToInt((char*)line+2);
 8000a70:	4843      	ldr	r0, [pc, #268]	; (8000b80 <prvCommsTask+0x620>)
 8000a72:	f001 ffd7 	bl	8002a24 <asciiToInt>
 8000a76:	aa1a      	add	r2, sp, #104	; 0x68
 8000a78:	f802 0d55 	strb.w	r0, [r2, #-85]!
                    sendFileCommand('C',1,&fileHandle);
 8000a7c:	2101      	movs	r1, #1
 8000a7e:	2043      	movs	r0, #67	; 0x43
 8000a80:	f000 fcac 	bl	80013dc <sendFileCommand>
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000a84:	4a3f      	ldr	r2, [pc, #252]	; (8000b84 <prvCommsTask+0x624>)
 8000a86:	f10d 0112 	add.w	r1, sp, #18
 8000a8a:	6810      	ldr	r0, [r2, #0]
 8000a8c:	2300      	movs	r3, #0
 8000a8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000a92:	f005 f974 	bl	8005d7e <xQueueGenericReceive>
                    if (fileStatus == FR_OK)
 8000a96:	f89d 5012 	ldrb.w	r5, [sp, #18]
 8000a9a:	b95d      	cbnz	r5, 8000ab4 <prvCommsTask+0x554>
                    {
                        if (writeFileHandle == fileHandle) writeFileHandle = 0xFF;
 8000a9c:	4b3c      	ldr	r3, [pc, #240]	; (8000b90 <prvCommsTask+0x630>)
 8000a9e:	f89d 7013 	ldrb.w	r7, [sp, #19]
 8000aa2:	781c      	ldrb	r4, [r3, #0]
 8000aa4:	42bc      	cmp	r4, r7
 8000aa6:	d003      	beq.n	8000ab0 <prvCommsTask+0x550>
                        else if (readFileHandle == fileHandle) readFileHandle = 0xFF;
 8000aa8:	4b3c      	ldr	r3, [pc, #240]	; (8000b9c <prvCommsTask+0x63c>)
 8000aaa:	781e      	ldrb	r6, [r3, #0]
 8000aac:	42be      	cmp	r6, r7
 8000aae:	d101      	bne.n	8000ab4 <prvCommsTask+0x554>
 8000ab0:	20ff      	movs	r0, #255	; 0xff
 8000ab2:	7018      	strb	r0, [r3, #0]
                    }
                    xSemaphoreGive(fileSendSemaphore);
 8000ab4:	4931      	ldr	r1, [pc, #196]	; (8000b7c <prvCommsTask+0x61c>)
 8000ab6:	6808      	ldr	r0, [r1, #0]
 8000ab8:	2100      	movs	r1, #0
 8000aba:	460a      	mov	r2, r1
 8000abc:	460b      	mov	r3, r1
 8000abe:	f005 f8c7 	bl	8005c50 <xQueueGenericSend>
                }
                sendResponse("fE",(uint8_t)fileStatus);
 8000ac2:	4838      	ldr	r0, [pc, #224]	; (8000ba4 <prvCommsTask+0x644>)
 8000ac4:	f89d 1012 	ldrb.w	r1, [sp, #18]
 8000ac8:	e1a8      	b.n	8000e1c <prvCommsTask+0x8bc>
sent, the rest remains in the buffer until the next request. */
#define GET_RECORD_SIZE 80
            case 'G':
            {
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000aca:	4a2c      	ldr	r2, [pc, #176]	; (8000b7c <prvCommsTask+0x61c>)
 8000acc:	2100      	movs	r1, #0
 8000ace:	6810      	ldr	r0, [r2, #0]
 8000ad0:	460b      	mov	r3, r1
 8000ad2:	2264      	movs	r2, #100	; 0x64
 8000ad4:	f005 f953 	bl	8005d7e <xQueueGenericReceive>
 8000ad8:	2800      	cmp	r0, #0
 8000ada:	f000 80a5 	beq.w	8000c28 <prvCommsTask+0x6c8>
                {
                    int numberRecords = asciiToInt((char*)line+2);
 8000ade:	4828      	ldr	r0, [pc, #160]	; (8000b80 <prvCommsTask+0x620>)
 8000ae0:	f001 ffa0 	bl	8002a24 <asciiToInt>
                    if (numberRecords < 1) numberRecords = 1;
 8000ae4:	2801      	cmp	r0, #1
 8000ae6:	bfac      	ite	ge
 8000ae8:	4605      	movge	r5, r0
 8000aea:	2501      	movlt	r5, #1
                    static uint8_t buffer[GET_RECORD_SIZE];
                    static uint8_t readPointer = 0;
                    static uint8_t writePointer = 0;
                    char sendData[GET_RECORD_SIZE];
                    uint8_t sendPointer = 0;
                    uint8_t fileHandle = asciiToInt((char*)line+2);
 8000aec:	4824      	ldr	r0, [pc, #144]	; (8000b80 <prvCommsTask+0x620>)
 8000aee:	f001 ff99 	bl	8002a24 <asciiToInt>
                    uint8_t blockLength = GET_RECORD_SIZE-1;
                    uint8_t numRead;
                    uint8_t parameters[2] = {fileHandle, blockLength};
 8000af2:	274f      	movs	r7, #79	; 0x4f
                    static uint8_t buffer[GET_RECORD_SIZE];
                    static uint8_t readPointer = 0;
                    static uint8_t writePointer = 0;
                    char sendData[GET_RECORD_SIZE];
                    uint8_t sendPointer = 0;
                    uint8_t fileHandle = asciiToInt((char*)line+2);
 8000af4:	f88d 0014 	strb.w	r0, [sp, #20]
                    uint8_t blockLength = GET_RECORD_SIZE-1;
                    uint8_t numRead;
                    uint8_t parameters[2] = {fileHandle, blockLength};
 8000af8:	f88d 7015 	strb.w	r7, [sp, #21]
                    static FRESULT fileStatus = FR_OK;
                    static uint8_t buffer[GET_RECORD_SIZE];
                    static uint8_t readPointer = 0;
                    static uint8_t writePointer = 0;
                    char sendData[GET_RECORD_SIZE];
                    uint8_t sendPointer = 0;
 8000afc:	2400      	movs	r4, #0
                    uint8_t numRead;
                    uint8_t parameters[2] = {fileHandle, blockLength};
                    while (numberRecords > 0)
                    {
/* The buffer is empty, so fill up. */
                        if (readPointer == writePointer)
 8000afe:	4b2a      	ldr	r3, [pc, #168]	; (8000ba8 <prvCommsTask+0x648>)
 8000b00:	482a      	ldr	r0, [pc, #168]	; (8000bac <prvCommsTask+0x64c>)
 8000b02:	781e      	ldrb	r6, [r3, #0]
 8000b04:	7801      	ldrb	r1, [r0, #0]
 8000b06:	428e      	cmp	r6, r1
 8000b08:	d15d      	bne.n	8000bc6 <prvCommsTask+0x666>
                        {
                            sendFileCommand('G',2,parameters);
 8000b0a:	2047      	movs	r0, #71	; 0x47
 8000b0c:	2102      	movs	r1, #2
 8000b0e:	aa05      	add	r2, sp, #20
 8000b10:	f000 fc64 	bl	80013dc <sendFileCommand>
                            numRead = 0;
                            xQueueReceive(fileReceiveQueue,&numRead,portMAX_DELAY);
 8000b14:	4a1b      	ldr	r2, [pc, #108]	; (8000b84 <prvCommsTask+0x624>)
                    {
/* The buffer is empty, so fill up. */
                        if (readPointer == writePointer)
                        {
                            sendFileCommand('G',2,parameters);
                            numRead = 0;
 8000b16:	2600      	movs	r6, #0
 8000b18:	a91a      	add	r1, sp, #104	; 0x68
                            xQueueReceive(fileReceiveQueue,&numRead,portMAX_DELAY);
 8000b1a:	6810      	ldr	r0, [r2, #0]
                    {
/* The buffer is empty, so fill up. */
                        if (readPointer == writePointer)
                        {
                            sendFileCommand('G',2,parameters);
                            numRead = 0;
 8000b1c:	f801 6d55 	strb.w	r6, [r1, #-85]!
                            xQueueReceive(fileReceiveQueue,&numRead,portMAX_DELAY);
 8000b20:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000b24:	4633      	mov	r3, r6
 8000b26:	f005 f92a 	bl	8005d7e <xQueueGenericReceive>
/* As records are written in entirety, premature EOF should not happen. */
                            if (numRead != blockLength)
 8000b2a:	f89d 7013 	ldrb.w	r7, [sp, #19]
 8000b2e:	2f4f      	cmp	r7, #79	; 0x4f
 8000b30:	d003      	beq.n	8000b3a <prvCommsTask+0x5da>
                            {
                                fileStatus = FR_DENIED;
 8000b32:	4c1f      	ldr	r4, [pc, #124]	; (8000bb0 <prvCommsTask+0x650>)
 8000b34:	2507      	movs	r5, #7
 8000b36:	7025      	strb	r5, [r4, #0]
 8000b38:	e06f      	b.n	8000c1a <prvCommsTask+0x6ba>
                                break;
                            }
                            uint8_t i;
/* Read the entire block to the local buffer. */
                            for (i=0; i<numRead; i++)
 8000b3a:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8000b3e:	4811      	ldr	r0, [pc, #68]	; (8000b84 <prvCommsTask+0x624>)
 8000b40:	42b3      	cmp	r3, r6
 8000b42:	d939      	bls.n	8000bb8 <prvCommsTask+0x658>
                            {
                                uint8_t nextWritePointer = (writePointer+1) % GET_RECORD_SIZE;
 8000b44:	4f19      	ldr	r7, [pc, #100]	; (8000bac <prvCommsTask+0x64c>)
                                xQueueReceive(fileReceiveQueue,
 8000b46:	4a1b      	ldr	r2, [pc, #108]	; (8000bb4 <prvCommsTask+0x654>)
                            }
                            uint8_t i;
/* Read the entire block to the local buffer. */
                            for (i=0; i<numRead; i++)
                            {
                                uint8_t nextWritePointer = (writePointer+1) % GET_RECORD_SIZE;
 8000b48:	f897 8000 	ldrb.w	r8, [r7]
                                xQueueReceive(fileReceiveQueue,
 8000b4c:	2300      	movs	r3, #0
 8000b4e:	eb02 0108 	add.w	r1, r2, r8
 8000b52:	6800      	ldr	r0, [r0, #0]
 8000b54:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000b58:	f005 f911 	bl	8005d7e <xQueueGenericReceive>
                            }
                            uint8_t i;
/* Read the entire block to the local buffer. */
                            for (i=0; i<numRead; i++)
                            {
                                uint8_t nextWritePointer = (writePointer+1) % GET_RECORD_SIZE;
 8000b5c:	f108 0001 	add.w	r0, r8, #1
 8000b60:	2350      	movs	r3, #80	; 0x50
 8000b62:	fb90 f1f3 	sdiv	r1, r0, r3
 8000b66:	fb03 0c11 	mls	ip, r3, r1, r0
                                fileStatus = FR_DENIED;
                                break;
                            }
                            uint8_t i;
/* Read the entire block to the local buffer. */
                            for (i=0; i<numRead; i++)
 8000b6a:	3601      	adds	r6, #1
                            {
                                uint8_t nextWritePointer = (writePointer+1) % GET_RECORD_SIZE;
 8000b6c:	f887 c000 	strb.w	ip, [r7]
                                fileStatus = FR_DENIED;
                                break;
                            }
                            uint8_t i;
/* Read the entire block to the local buffer. */
                            for (i=0; i<numRead; i++)
 8000b70:	b2f6      	uxtb	r6, r6
 8000b72:	e7e2      	b.n	8000b3a <prvCommsTask+0x5da>
 8000b74:	200008c8 	.word	0x200008c8
 8000b78:	2000009a 	.word	0x2000009a
 8000b7c:	20000784 	.word	0x20000784
 8000b80:	20000098 	.word	0x20000098
 8000b84:	2000078c 	.word	0x2000078c
 8000b88:	08007509 	.word	0x08007509
 8000b8c:	2000003a 	.word	0x2000003a
 8000b90:	20000039 	.word	0x20000039
 8000b94:	0800750f 	.word	0x0800750f
 8000b98:	20000024 	.word	0x20000024
 8000b9c:	20000032 	.word	0x20000032
 8000ba0:	08007512 	.word	0x08007512
 8000ba4:	0800750c 	.word	0x0800750c
 8000ba8:	20000030 	.word	0x20000030
 8000bac:	20000018 	.word	0x20000018
 8000bb0:	200000e6 	.word	0x200000e6
 8000bb4:	20000046 	.word	0x20000046
                                xQueueReceive(fileReceiveQueue,
                                    buffer+writePointer,portMAX_DELAY);
                                writePointer = nextWritePointer;
                            }
/* Get status byte. */
                            xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000bb8:	6800      	ldr	r0, [r0, #0]
 8000bba:	499d      	ldr	r1, [pc, #628]	; (8000e30 <prvCommsTask+0x8d0>)
 8000bbc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000bc0:	2300      	movs	r3, #0
 8000bc2:	f005 f8dc 	bl	8005d7e <xQueueGenericReceive>
                                sendPointer = 0;
                                numberRecords--;
                                break;
                            }
/* If the current block is exhausted, go get some more. */
                            if (readPointer == writePointer) break;
 8000bc6:	4e9b      	ldr	r6, [pc, #620]	; (8000e34 <prvCommsTask+0x8d4>)
 8000bc8:	499b      	ldr	r1, [pc, #620]	; (8000e38 <prvCommsTask+0x8d8>)
 8000bca:	7836      	ldrb	r6, [r6, #0]
 8000bcc:	7808      	ldrb	r0, [r1, #0]
                            }
/* Get status byte. */
                            xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
                        }
/* Assemble the data message until EOL encountered, or block exhausted. */
                        while (sendPointer < GET_RECORD_SIZE-1)
 8000bce:	2c4e      	cmp	r4, #78	; 0x4e
 8000bd0:	d81e      	bhi.n	8000c10 <prvCommsTask+0x6b0>
                        {
                            sendData[sendPointer] = buffer[readPointer];
 8000bd2:	4a9a      	ldr	r2, [pc, #616]	; (8000e3c <prvCommsTask+0x8dc>)
                            readPointer = (readPointer+1) % GET_RECORD_SIZE;
 8000bd4:	1c43      	adds	r3, r0, #1
                            xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
                        }
/* Assemble the data message until EOL encountered, or block exhausted. */
                        while (sendPointer < GET_RECORD_SIZE-1)
                        {
                            sendData[sendPointer] = buffer[readPointer];
 8000bd6:	5c11      	ldrb	r1, [r2, r0]
 8000bd8:	af1a      	add	r7, sp, #104	; 0x68
                            readPointer = (readPointer+1) % GET_RECORD_SIZE;
 8000bda:	2050      	movs	r0, #80	; 0x50
                            xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
                        }
/* Assemble the data message until EOL encountered, or block exhausted. */
                        while (sendPointer < GET_RECORD_SIZE-1)
                        {
                            sendData[sendPointer] = buffer[readPointer];
 8000bdc:	193a      	adds	r2, r7, r4
                            readPointer = (readPointer+1) % GET_RECORD_SIZE;
 8000bde:	fb93 f7f0 	sdiv	r7, r3, r0
 8000be2:	fb00 3317 	mls	r3, r0, r7, r3
                            if (sendData[sendPointer] == '\n')
 8000be6:	290a      	cmp	r1, #10
                            xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
                        }
/* Assemble the data message until EOL encountered, or block exhausted. */
                        while (sendPointer < GET_RECORD_SIZE-1)
                        {
                            sendData[sendPointer] = buffer[readPointer];
 8000be8:	f802 1c50 	strb.w	r1, [r2, #-80]
                            readPointer = (readPointer+1) % GET_RECORD_SIZE;
 8000bec:	b2d8      	uxtb	r0, r3
                            if (sendData[sendPointer] == '\n')
 8000bee:	d10a      	bne.n	8000c06 <prvCommsTask+0x6a6>
 8000bf0:	4991      	ldr	r1, [pc, #580]	; (8000e38 <prvCommsTask+0x8d8>)
                            {
                                sendData[sendPointer+1] = 0;
 8000bf2:	2400      	movs	r4, #0
 8000bf4:	7008      	strb	r0, [r1, #0]
                                sendStringLowPriority("fG",sendData);
 8000bf6:	4892      	ldr	r0, [pc, #584]	; (8000e40 <prvCommsTask+0x8e0>)
 8000bf8:	a906      	add	r1, sp, #24
                        {
                            sendData[sendPointer] = buffer[readPointer];
                            readPointer = (readPointer+1) % GET_RECORD_SIZE;
                            if (sendData[sendPointer] == '\n')
                            {
                                sendData[sendPointer+1] = 0;
 8000bfa:	f802 4c4f 	strb.w	r4, [r2, #-79]
                                sendStringLowPriority("fG",sendData);
                                sendPointer = 0;
                                numberRecords--;
 8000bfe:	3d01      	subs	r5, #1
                            sendData[sendPointer] = buffer[readPointer];
                            readPointer = (readPointer+1) % GET_RECORD_SIZE;
                            if (sendData[sendPointer] == '\n')
                            {
                                sendData[sendPointer+1] = 0;
                                sendStringLowPriority("fG",sendData);
 8000c00:	f7ff fb92 	bl	8000328 <sendStringLowPriority>
 8000c04:	e006      	b.n	8000c14 <prvCommsTask+0x6b4>
                                sendPointer = 0;
                                numberRecords--;
                                break;
                            }
/* If the current block is exhausted, go get some more. */
                            if (readPointer == writePointer) break;
 8000c06:	42b0      	cmp	r0, r6
 8000c08:	d002      	beq.n	8000c10 <prvCommsTask+0x6b0>
                            sendPointer++;
 8000c0a:	3401      	adds	r4, #1
 8000c0c:	b2e4      	uxtb	r4, r4
 8000c0e:	e7de      	b.n	8000bce <prvCommsTask+0x66e>
 8000c10:	4e89      	ldr	r6, [pc, #548]	; (8000e38 <prvCommsTask+0x8d8>)
 8000c12:	7030      	strb	r0, [r6, #0]
                    uint8_t sendPointer = 0;
                    uint8_t fileHandle = asciiToInt((char*)line+2);
                    uint8_t blockLength = GET_RECORD_SIZE-1;
                    uint8_t numRead;
                    uint8_t parameters[2] = {fileHandle, blockLength};
                    while (numberRecords > 0)
 8000c14:	2d00      	cmp	r5, #0
 8000c16:	f47f af72 	bne.w	8000afe <prvCommsTask+0x59e>
/* If the current block is exhausted, go get some more. */
                            if (readPointer == writePointer) break;
                            sendPointer++;
                        }
                    }
                    xSemaphoreGive(fileSendSemaphore);
 8000c1a:	4f8a      	ldr	r7, [pc, #552]	; (8000e44 <prvCommsTask+0x8e4>)
 8000c1c:	2100      	movs	r1, #0
 8000c1e:	6838      	ldr	r0, [r7, #0]
 8000c20:	460a      	mov	r2, r1
 8000c22:	460b      	mov	r3, r1
 8000c24:	f005 f814 	bl	8005c50 <xQueueGenericSend>
                }
/* Status sent is from the last time the file was read. */
                sendResponse("fE",(uint8_t)fileStatus);
 8000c28:	4887      	ldr	r0, [pc, #540]	; (8000e48 <prvCommsTask+0x8e8>)
 8000c2a:	2102      	movs	r1, #2
 8000c2c:	e0f6      	b.n	8000e1c <prvCommsTask+0x8bc>
            }
/* Get a directory listing. Gets all items in the directory and sends the
names separated by commas. */
            case 'D':
            {
                if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_TIMEOUT)) break;
 8000c2e:	4f87      	ldr	r7, [pc, #540]	; (8000e4c <prvCommsTask+0x8ec>)
 8000c30:	4621      	mov	r1, r4
 8000c32:	6838      	ldr	r0, [r7, #0]
 8000c34:	22c8      	movs	r2, #200	; 0xc8
 8000c36:	4623      	mov	r3, r4
 8000c38:	f005 f8a1 	bl	8005d7e <xQueueGenericReceive>
 8000c3c:	2800      	cmp	r0, #0
 8000c3e:	f43f aca2 	beq.w	8000586 <prvCommsTask+0x26>
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000c42:	4980      	ldr	r1, [pc, #512]	; (8000e44 <prvCommsTask+0x8e4>)
/* Get a directory listing. Gets all items in the directory and sends the
names separated by commas. */
            case 'D':
            {
                if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_TIMEOUT)) break;
                uint8_t fileStatus = FR_INT_ERR;
 8000c44:	2302      	movs	r3, #2
 8000c46:	f88d 3010 	strb.w	r3, [sp, #16]
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000c4a:	6808      	ldr	r0, [r1, #0]
 8000c4c:	2264      	movs	r2, #100	; 0x64
 8000c4e:	4621      	mov	r1, r4
 8000c50:	4623      	mov	r3, r4
 8000c52:	f005 f894 	bl	8005d7e <xQueueGenericReceive>
 8000c56:	2800      	cmp	r0, #0
 8000c58:	d058      	beq.n	8000d0c <prvCommsTask+0x7ac>
                {
                    char character,firstCharacter,type;
                    sendFileCommand('D',13,line+2);
 8000c5a:	4630      	mov	r0, r6
 8000c5c:	210d      	movs	r1, #13
 8000c5e:	1caa      	adds	r2, r5, #2
 8000c60:	f000 fbbc 	bl	80013dc <sendFileCommand>
                    commsPrintString("fD");
 8000c64:	487a      	ldr	r0, [pc, #488]	; (8000e50 <prvCommsTask+0x8f0>)
 8000c66:	f7ff fb49 	bl	80002fc <commsPrintString>
                    do
                    {
                        type = 0;
 8000c6a:	2500      	movs	r5, #0
 8000c6c:	ac1a      	add	r4, sp, #104	; 0x68
                        xQueueReceive(fileReceiveQueue,&type,portMAX_DELAY);
 8000c6e:	4e79      	ldr	r6, [pc, #484]	; (8000e54 <prvCommsTask+0x8f4>)
                    char character,firstCharacter,type;
                    sendFileCommand('D',13,line+2);
                    commsPrintString("fD");
                    do
                    {
                        type = 0;
 8000c70:	f804 5d56 	strb.w	r5, [r4, #-86]!
                        xQueueReceive(fileReceiveQueue,&type,portMAX_DELAY);
 8000c74:	4621      	mov	r1, r4
 8000c76:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000c7a:	462b      	mov	r3, r5
 8000c7c:	6830      	ldr	r0, [r6, #0]
 8000c7e:	f005 f87e 	bl	8005d7e <xQueueGenericReceive>
                        character = 0;
 8000c82:	a91a      	add	r1, sp, #104	; 0x68
 8000c84:	f801 5d57 	strb.w	r5, [r1, #-87]!
                        xQueueReceive(fileReceiveQueue,&character,portMAX_DELAY);
 8000c88:	6830      	ldr	r0, [r6, #0]
 8000c8a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000c8e:	462b      	mov	r3, r5
 8000c90:	f005 f875 	bl	8005d7e <xQueueGenericReceive>
                        firstCharacter = character;
/* If the first character is zero then the listing is ended */
                        if (firstCharacter > 0)
 8000c94:	f89d 7011 	ldrb.w	r7, [sp, #17]
 8000c98:	b33f      	cbz	r7, 8000cea <prvCommsTask+0x78a>
                        {
                            commsPrintString(",");
 8000c9a:	486f      	ldr	r0, [pc, #444]	; (8000e58 <prvCommsTask+0x8f8>)
 8000c9c:	f7ff fb2e 	bl	80002fc <commsPrintString>
                            commsPrintChar(&type);
 8000ca0:	4620      	mov	r0, r4
 8000ca2:	f7ff fb0d 	bl	80002c0 <commsPrintChar>
                            while (character > 0)
 8000ca6:	f89d 4011 	ldrb.w	r4, [sp, #17]
 8000caa:	4d6a      	ldr	r5, [pc, #424]	; (8000e54 <prvCommsTask+0x8f4>)
 8000cac:	b174      	cbz	r4, 8000ccc <prvCommsTask+0x76c>
                            {
                                commsPrintChar(&character);
 8000cae:	f10d 0011 	add.w	r0, sp, #17
 8000cb2:	f7ff fb05 	bl	80002c0 <commsPrintChar>
                                character = 0;
 8000cb6:	2300      	movs	r3, #0
                                xQueueReceive(fileReceiveQueue,&character,portMAX_DELAY);
 8000cb8:	6828      	ldr	r0, [r5, #0]
 8000cba:	f10d 0111 	add.w	r1, sp, #17
 8000cbe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
                            commsPrintString(",");
                            commsPrintChar(&type);
                            while (character > 0)
                            {
                                commsPrintChar(&character);
                                character = 0;
 8000cc2:	f88d 3011 	strb.w	r3, [sp, #17]
                                xQueueReceive(fileReceiveQueue,&character,portMAX_DELAY);
 8000cc6:	f005 f85a 	bl	8005d7e <xQueueGenericReceive>
 8000cca:	e7ec      	b.n	8000ca6 <prvCommsTask+0x746>
                            }
/* Discard the status byte */
                            xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000ccc:	a904      	add	r1, sp, #16
 8000cce:	6828      	ldr	r0, [r5, #0]
 8000cd0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000cd4:	4623      	mov	r3, r4
 8000cd6:	f005 f852 	bl	8005d7e <xQueueGenericReceive>
                            uint8_t eol = 0;
 8000cda:	aa1a      	add	r2, sp, #104	; 0x68
 8000cdc:	f802 4d55 	strb.w	r4, [r2, #-85]!
/* Send a zero parameter to ask for the next entry */
                            sendFileCommand('D',1,&eol);
 8000ce0:	2044      	movs	r0, #68	; 0x44
 8000ce2:	2101      	movs	r1, #1
 8000ce4:	f000 fb7a 	bl	80013dc <sendFileCommand>
 8000ce8:	e7bf      	b.n	8000c6a <prvCommsTask+0x70a>
                        }
                    }
                    while (firstCharacter > 0);
                    commsPrintString("\r\n");
 8000cea:	485c      	ldr	r0, [pc, #368]	; (8000e5c <prvCommsTask+0x8fc>)
 8000cec:	f7ff fb06 	bl	80002fc <commsPrintString>
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000cf0:	a904      	add	r1, sp, #16
 8000cf2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000cf6:	463b      	mov	r3, r7
 8000cf8:	6830      	ldr	r0, [r6, #0]
 8000cfa:	f005 f840 	bl	8005d7e <xQueueGenericReceive>
                    xSemaphoreGive(fileSendSemaphore);
 8000cfe:	4a51      	ldr	r2, [pc, #324]	; (8000e44 <prvCommsTask+0x8e4>)
 8000d00:	4639      	mov	r1, r7
 8000d02:	6810      	ldr	r0, [r2, #0]
 8000d04:	463b      	mov	r3, r7
 8000d06:	463a      	mov	r2, r7
 8000d08:	f004 ffa2 	bl	8005c50 <xQueueGenericSend>
                }
                xSemaphoreGive(commsSendSemaphore);
 8000d0c:	484f      	ldr	r0, [pc, #316]	; (8000e4c <prvCommsTask+0x8ec>)
 8000d0e:	2100      	movs	r1, #0
 8000d10:	460a      	mov	r2, r1
 8000d12:	460b      	mov	r3, r1
 8000d14:	6800      	ldr	r0, [r0, #0]
 8000d16:	f004 ff9b 	bl	8005c50 <xQueueGenericSend>
                sendResponse("fE",(uint8_t)fileStatus);
 8000d1a:	484b      	ldr	r0, [pc, #300]	; (8000e48 <prvCommsTask+0x8e8>)
 8000d1c:	f89d 1010 	ldrb.w	r1, [sp, #16]
 8000d20:	e07c      	b.n	8000e1c <prvCommsTask+0x8bc>
            }
/* Send a status message containing: software switches
(configData.config.recording), names of open files. */
            case 's':
            {
                if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_TIMEOUT))
 8000d22:	494a      	ldr	r1, [pc, #296]	; (8000e4c <prvCommsTask+0x8ec>)
 8000d24:	22c8      	movs	r2, #200	; 0xc8
 8000d26:	6808      	ldr	r0, [r1, #0]
 8000d28:	2100      	movs	r1, #0
 8000d2a:	460b      	mov	r3, r1
 8000d2c:	f005 f827 	bl	8005d7e <xQueueGenericReceive>
 8000d30:	2800      	cmp	r0, #0
 8000d32:	f43f ac28 	beq.w	8000586 <prvCommsTask+0x26>
                    break;;
                commsPrintString("fs,");
 8000d36:	484a      	ldr	r0, [pc, #296]	; (8000e60 <prvCommsTask+0x900>)
 8000d38:	f7ff fae0 	bl	80002fc <commsPrintString>
                commsPrintInt((int)getControls());
                commsPrintString(",");
                uint8_t writeStatus;
                commsPrintInt(writeFileHandle);
 8000d3c:	4d49      	ldr	r5, [pc, #292]	; (8000e64 <prvCommsTask+0x904>)
            case 's':
            {
                if (! xSemaphoreTake(commsSendSemaphore,COMMS_SEND_TIMEOUT))
                    break;;
                commsPrintString("fs,");
                commsPrintInt((int)getControls());
 8000d3e:	f002 f941 	bl	8002fc4 <getControls>
 8000d42:	f7ff fb8b 	bl	800045c <commsPrintInt>
                commsPrintString(",");
 8000d46:	4844      	ldr	r0, [pc, #272]	; (8000e58 <prvCommsTask+0x8f8>)
 8000d48:	f7ff fad8 	bl	80002fc <commsPrintString>
                uint8_t writeStatus;
                commsPrintInt(writeFileHandle);
 8000d4c:	7828      	ldrb	r0, [r5, #0]
 8000d4e:	f7ff fb85 	bl	800045c <commsPrintInt>
                commsPrintString(",");
 8000d52:	4841      	ldr	r0, [pc, #260]	; (8000e58 <prvCommsTask+0x8f8>)
 8000d54:	f7ff fad2 	bl	80002fc <commsPrintString>
                if (writeFileHandle < 0xFF)
 8000d58:	782a      	ldrb	r2, [r5, #0]
 8000d5a:	2aff      	cmp	r2, #255	; 0xff
 8000d5c:	d005      	beq.n	8000d6a <prvCommsTask+0x80a>
                {
                    commsPrintString(writeFileName);
 8000d5e:	4842      	ldr	r0, [pc, #264]	; (8000e68 <prvCommsTask+0x908>)
 8000d60:	f7ff facc 	bl	80002fc <commsPrintString>
                    commsPrintString(",");
 8000d64:	483c      	ldr	r0, [pc, #240]	; (8000e58 <prvCommsTask+0x8f8>)
 8000d66:	f7ff fac9 	bl	80002fc <commsPrintString>
                }
                commsPrintInt(readFileHandle);
 8000d6a:	4f40      	ldr	r7, [pc, #256]	; (8000e6c <prvCommsTask+0x90c>)
 8000d6c:	7838      	ldrb	r0, [r7, #0]
 8000d6e:	f7ff fb75 	bl	800045c <commsPrintInt>
                if (readFileHandle < 0xFF)
 8000d72:	7838      	ldrb	r0, [r7, #0]
 8000d74:	28ff      	cmp	r0, #255	; 0xff
 8000d76:	d005      	beq.n	8000d84 <prvCommsTask+0x824>
                {
                    commsPrintString(",");
 8000d78:	4837      	ldr	r0, [pc, #220]	; (8000e58 <prvCommsTask+0x8f8>)
 8000d7a:	f7ff fabf 	bl	80002fc <commsPrintString>
                    commsPrintString(readFileName);
 8000d7e:	483c      	ldr	r0, [pc, #240]	; (8000e70 <prvCommsTask+0x910>)
 8000d80:	f7ff fabc 	bl	80002fc <commsPrintString>
                }
                commsPrintString("\r\n");
 8000d84:	4835      	ldr	r0, [pc, #212]	; (8000e5c <prvCommsTask+0x8fc>)
 8000d86:	f7ff fab9 	bl	80002fc <commsPrintString>
                xSemaphoreGive(commsSendSemaphore);
 8000d8a:	4b30      	ldr	r3, [pc, #192]	; (8000e4c <prvCommsTask+0x8ec>)
 8000d8c:	2100      	movs	r1, #0
 8000d8e:	6818      	ldr	r0, [r3, #0]
 8000d90:	460a      	mov	r2, r1
 8000d92:	460b      	mov	r3, r1
 8000d94:	f004 ff5c 	bl	8005c50 <xQueueGenericSend>
 8000d98:	f7ff bbf5 	b.w	8000586 <prvCommsTask+0x26>
/* Delete a designated file. The file must not be open at the time.
A status is returned to signal a directory refresh. */
            case 'X':
            {
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000d9c:	4929      	ldr	r1, [pc, #164]	; (8000e44 <prvCommsTask+0x8e4>)
            }
/* Delete a designated file. The file must not be open at the time.
A status is returned to signal a directory refresh. */
            case 'X':
            {
                uint8_t fileStatus = FR_INT_ERR;
 8000d9e:	2602      	movs	r6, #2
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000da0:	6808      	ldr	r0, [r1, #0]
 8000da2:	2264      	movs	r2, #100	; 0x64
 8000da4:	4621      	mov	r1, r4
 8000da6:	4623      	mov	r3, r4
            }
/* Delete a designated file. The file must not be open at the time.
A status is returned to signal a directory refresh. */
            case 'X':
            {
                uint8_t fileStatus = FR_INT_ERR;
 8000da8:	f88d 6013 	strb.w	r6, [sp, #19]
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000dac:	f004 ffe7 	bl	8005d7e <xQueueGenericReceive>
 8000db0:	2800      	cmp	r0, #0
 8000db2:	d030      	beq.n	8000e16 <prvCommsTask+0x8b6>
                {
                    sendFileCommand('X',13,line+2);
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000db4:	4c27      	ldr	r4, [pc, #156]	; (8000e54 <prvCommsTask+0x8f4>)
            case 'X':
            {
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
                {
                    sendFileCommand('X',13,line+2);
 8000db6:	2058      	movs	r0, #88	; 0x58
 8000db8:	210d      	movs	r1, #13
 8000dba:	4a2e      	ldr	r2, [pc, #184]	; (8000e74 <prvCommsTask+0x914>)
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
                    xSemaphoreGive(fileSendSemaphore);
 8000dbc:	4d21      	ldr	r5, [pc, #132]	; (8000e44 <prvCommsTask+0x8e4>)
            case 'X':
            {
                uint8_t fileStatus = FR_INT_ERR;
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
                {
                    sendFileCommand('X',13,line+2);
 8000dbe:	f000 fb0d 	bl	80013dc <sendFileCommand>
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000dc2:	6820      	ldr	r0, [r4, #0]
 8000dc4:	f10d 0113 	add.w	r1, sp, #19
 8000dc8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000dcc:	2300      	movs	r3, #0
 8000dce:	f004 ffd6 	bl	8005d7e <xQueueGenericReceive>
                    xSemaphoreGive(fileSendSemaphore);
 8000dd2:	6828      	ldr	r0, [r5, #0]
 8000dd4:	2100      	movs	r1, #0
 8000dd6:	e01a      	b.n	8000e0e <prvCommsTask+0x8ae>
                break;
            }
/* Register (mount) the SD card. */
            case 'M':
            {
                uint8_t fileStatus = FR_INT_ERR;
 8000dd8:	2702      	movs	r7, #2
 8000dda:	f88d 7013 	strb.w	r7, [sp, #19]
                if (xSemaphoreTake(fileSendSemaphore,COMMS_FILE_TIMEOUT))
 8000dde:	4f19      	ldr	r7, [pc, #100]	; (8000e44 <prvCommsTask+0x8e4>)
 8000de0:	4621      	mov	r1, r4
 8000de2:	6838      	ldr	r0, [r7, #0]
 8000de4:	2264      	movs	r2, #100	; 0x64
 8000de6:	4623      	mov	r3, r4
 8000de8:	f004 ffc9 	bl	8005d7e <xQueueGenericReceive>
 8000dec:	b198      	cbz	r0, 8000e16 <prvCommsTask+0x8b6>
                {
                    sendFileCommand('M',0,line+2);
 8000dee:	4630      	mov	r0, r6
 8000df0:	4621      	mov	r1, r4
 8000df2:	1caa      	adds	r2, r5, #2
 8000df4:	f000 faf2 	bl	80013dc <sendFileCommand>
                    xQueueReceive(fileReceiveQueue,&fileStatus,portMAX_DELAY);
 8000df8:	4816      	ldr	r0, [pc, #88]	; (8000e54 <prvCommsTask+0x8f4>)
 8000dfa:	6800      	ldr	r0, [r0, #0]
 8000dfc:	f10d 0113 	add.w	r1, sp, #19
 8000e00:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000e04:	4623      	mov	r3, r4
 8000e06:	f004 ffba 	bl	8005d7e <xQueueGenericReceive>
                    xSemaphoreGive(fileSendSemaphore);
 8000e0a:	6838      	ldr	r0, [r7, #0]
 8000e0c:	4621      	mov	r1, r4
 8000e0e:	460a      	mov	r2, r1
 8000e10:	460b      	mov	r3, r1
 8000e12:	f004 ff1d 	bl	8005c50 <xQueueGenericSend>
                }
                sendResponse("fE",(uint8_t)fileStatus);
 8000e16:	480c      	ldr	r0, [pc, #48]	; (8000e48 <prvCommsTask+0x8e8>)
 8000e18:	f89d 1013 	ldrb.w	r1, [sp, #19]
 8000e1c:	f7ff fb3e 	bl	800049c <sendResponse>
 8000e20:	f7ff bbb1 	b.w	8000586 <prvCommsTask+0x26>
        {
            line[characterPosition] = 0;
            characterPosition = 0;
            parseCommand(line);
        }
        else line[characterPosition++] = character;
 8000e24:	1c54      	adds	r4, r2, #1
 8000e26:	5488      	strb	r0, [r1, r2]
 8000e28:	7034      	strb	r4, [r6, #0]
    }
 8000e2a:	f7ff bbac 	b.w	8000586 <prvCommsTask+0x26>
 8000e2e:	bf00      	nop
 8000e30:	200000e6 	.word	0x200000e6
 8000e34:	20000018 	.word	0x20000018
 8000e38:	20000030 	.word	0x20000030
 8000e3c:	20000046 	.word	0x20000046
 8000e40:	08007515 	.word	0x08007515
 8000e44:	20000784 	.word	0x20000784
 8000e48:	0800750c 	.word	0x0800750c
 8000e4c:	20000020 	.word	0x20000020
 8000e50:	08007518 	.word	0x08007518
 8000e54:	2000078c 	.word	0x2000078c
 8000e58:	0800751d 	.word	0x0800751d
 8000e5c:	080074c5 	.word	0x080074c5
 8000e60:	0800751b 	.word	0x0800751b
 8000e64:	20000039 	.word	0x20000039
 8000e68:	2000003a 	.word	0x2000003a
 8000e6c:	20000032 	.word	0x20000032
 8000e70:	20000024 	.word	0x20000024
 8000e74:	20000098 	.word	0x20000098

08000e78 <findFileHandle>:
    uint8_t fileHandle=0xFF;
    uint8_t mask = 0;
    while ((i<MAX_OPEN_FILES) && (fileHandle == 0xFF))
    {
        mask = (1 << i);
        if ((filemap & mask) == 0) fileHandle = i;
 8000e78:	4a09      	ldr	r2, [pc, #36]	; (8000ea0 <findFileHandle+0x28>)
 8000e7a:	7813      	ldrb	r3, [r2, #0]
 8000e7c:	4611      	mov	r1, r2
 8000e7e:	f013 0001 	ands.w	r0, r3, #1
 8000e82:	d008      	beq.n	8000e96 <findFileHandle+0x1e>
 8000e84:	f003 0002 	and.w	r0, r3, #2
 8000e88:	b2c2      	uxtb	r2, r0
 8000e8a:	b10a      	cbz	r2, 8000e90 <findFileHandle+0x18>
 8000e8c:	20ff      	movs	r0, #255	; 0xff
 8000e8e:	4770      	bx	lr
 8000e90:	2202      	movs	r2, #2
        i++;
 8000e92:	2001      	movs	r0, #1
 8000e94:	e000      	b.n	8000e98 <findFileHandle+0x20>
    uint8_t i=0;
    uint8_t fileHandle=0xFF;
    uint8_t mask = 0;
    while ((i<MAX_OPEN_FILES) && (fileHandle == 0xFF))
    {
        mask = (1 << i);
 8000e96:	2201      	movs	r2, #1
        if ((filemap & mask) == 0) fileHandle = i;
        i++;
    }
    if (fileHandle < 0xFF) filemap |= mask;
 8000e98:	4313      	orrs	r3, r2
 8000e9a:	700b      	strb	r3, [r1, #0]
    return fileHandle;
}
 8000e9c:	4770      	bx	lr
 8000e9e:	bf00      	nop
 8000ea0:	20000788 	.word	0x20000788

08000ea4 <deleteFileHandle>:
This function deletes a handle. Does nothing if file handle is not valid.
*/

static void deleteFileHandle(uint8_t fileHandle)
{
    if (fileHandle < MAX_OPEN_FILES)
 8000ea4:	2801      	cmp	r0, #1
 8000ea6:	d807      	bhi.n	8000eb8 <deleteFileHandle+0x14>
        filemap &= ~(1 << fileHandle);
 8000ea8:	2201      	movs	r2, #1
 8000eaa:	fa02 f000 	lsl.w	r0, r2, r0
 8000eae:	4b03      	ldr	r3, [pc, #12]	; (8000ebc <deleteFileHandle+0x18>)
 8000eb0:	7819      	ldrb	r1, [r3, #0]
 8000eb2:	ea21 0200 	bic.w	r2, r1, r0
 8000eb6:	701a      	strb	r2, [r3, #0]
 8000eb8:	4770      	bx	lr
 8000eba:	bf00      	nop
 8000ebc:	20000788 	.word	0x20000788

08000ec0 <prvFileTask>:

Only deal with one disk volume.
*/

void prvFileTask( void *pvParameters )
{
 8000ec0:	b570      	push	{r4, r5, r6, lr}
*/

static void initFile(void)
{
/* Setup the queues to use */
    fileSendQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
 8000ec2:	2101      	movs	r1, #1

Only deal with one disk volume.
*/

void prvFileTask( void *pvParameters )
{
 8000ec4:	b098      	sub	sp, #96	; 0x60
*/

static void initFile(void)
{
/* Setup the queues to use */
    fileSendQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
 8000ec6:	2200      	movs	r2, #0
 8000ec8:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000ecc:	f004 fea0 	bl	8005c10 <xQueueGenericCreate>
 8000ed0:	4ba9      	ldr	r3, [pc, #676]	; (8001178 <prvFileTask+0x2b8>)
    fileReceiveQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
 8000ed2:	2101      	movs	r1, #1
*/

static void initFile(void)
{
/* Setup the queues to use */
    fileSendQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
 8000ed4:	6018      	str	r0, [r3, #0]
    fileReceiveQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
 8000ed6:	2200      	movs	r2, #0
 8000ed8:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000edc:	f004 fe98 	bl	8005c10 <xQueueGenericCreate>
 8000ee0:	49a6      	ldr	r1, [pc, #664]	; (800117c <prvFileTask+0x2bc>)
    vSemaphoreCreateBinary(fileSendSemaphore);
 8000ee2:	2203      	movs	r2, #3

static void initFile(void)
{
/* Setup the queues to use */
    fileSendQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
    fileReceiveQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
 8000ee4:	6008      	str	r0, [r1, #0]
    vSemaphoreCreateBinary(fileSendSemaphore);
 8000ee6:	2001      	movs	r0, #1
 8000ee8:	2100      	movs	r1, #0
 8000eea:	f004 fe91 	bl	8005c10 <xQueueGenericCreate>
 8000eee:	4aa4      	ldr	r2, [pc, #656]	; (8001180 <prvFileTask+0x2c0>)
 8000ef0:	6010      	str	r0, [r2, #0]
 8000ef2:	b120      	cbz	r0, 8000efe <prvFileTask+0x3e>
 8000ef4:	2100      	movs	r1, #0
 8000ef6:	460a      	mov	r2, r1
 8000ef8:	460b      	mov	r3, r1
 8000efa:	f004 fea9 	bl	8005c50 <xQueueGenericSend>

/* initialise the drive working area */
    FRESULT fileStatus = f_mount(&Fatfs[0],"",0);
 8000efe:	2200      	movs	r2, #0
 8000f00:	49a0      	ldr	r1, [pc, #640]	; (8001184 <prvFileTask+0x2c4>)
 8000f02:	48a1      	ldr	r0, [pc, #644]	; (8001188 <prvFileTask+0x2c8>)
 8000f04:	f003 f896 	bl	8004034 <f_mount>
    fileUsable = (fileStatus == FR_OK);
 8000f08:	4da0      	ldr	r5, [pc, #640]	; (800118c <prvFileTask+0x2cc>)
 8000f0a:	f1d0 0001 	rsbs	r0, r0, #1
 8000f0e:	bf38      	it	cc
 8000f10:	2000      	movcc	r0, #0

/* Initialise some global variables */
    writeFileHandle = 0xFF;
    readFileHandle = 0xFF;
    uint8_t i=0;
    for (i=0; i<MAX_OPEN_FILES; i++) fileInfo[i].fname[0] = 0;
 8000f12:	4c9f      	ldr	r4, [pc, #636]	; (8001190 <prvFileTask+0x2d0>)
/* initialise the drive working area */
    FRESULT fileStatus = f_mount(&Fatfs[0],"",0);
    fileUsable = (fileStatus == FR_OK);

/* Initialise some global variables */
    writeFileHandle = 0xFF;
 8000f14:	4b9f      	ldr	r3, [pc, #636]	; (8001194 <prvFileTask+0x2d4>)
    readFileHandle = 0xFF;
 8000f16:	49a0      	ldr	r1, [pc, #640]	; (8001198 <prvFileTask+0x2d8>)
    uint8_t i=0;
    for (i=0; i<MAX_OPEN_FILES; i++) fileInfo[i].fname[0] = 0;
    filemap = 0;
 8000f18:	4aa0      	ldr	r2, [pc, #640]	; (800119c <prvFileTask+0x2dc>)
/* initialise the drive working area */
    FRESULT fileStatus = f_mount(&Fatfs[0],"",0);
    fileUsable = (fileStatus == FR_OK);

/* Initialise some global variables */
    writeFileHandle = 0xFF;
 8000f1a:	26ff      	movs	r6, #255	; 0xff
    fileReceiveQueue = xQueueCreate(FILE_QUEUE_SIZE,1);
    vSemaphoreCreateBinary(fileSendSemaphore);

/* initialise the drive working area */
    FRESULT fileStatus = f_mount(&Fatfs[0],"",0);
    fileUsable = (fileStatus == FR_OK);
 8000f1c:	7028      	strb	r0, [r5, #0]

/* Initialise some global variables */
    writeFileHandle = 0xFF;
    readFileHandle = 0xFF;
    uint8_t i=0;
    for (i=0; i<MAX_OPEN_FILES; i++) fileInfo[i].fname[0] = 0;
 8000f1e:	2000      	movs	r0, #0
/* initialise the drive working area */
    FRESULT fileStatus = f_mount(&Fatfs[0],"",0);
    fileUsable = (fileStatus == FR_OK);

/* Initialise some global variables */
    writeFileHandle = 0xFF;
 8000f20:	701e      	strb	r6, [r3, #0]
    readFileHandle = 0xFF;
 8000f22:	700e      	strb	r6, [r1, #0]
    uint8_t i=0;
    for (i=0; i<MAX_OPEN_FILES; i++) fileInfo[i].fname[0] = 0;
 8000f24:	7260      	strb	r0, [r4, #9]
 8000f26:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
    filemap = 0;
 8000f2a:	7010      	strb	r0, [r2, #0]
	{
/* Build a command line before actioning */
/** The first character is the command, followed by the total message length
in bytes (which is the number of parameter bytes, if any, plus 2). */
        char character;
        xQueueReceive(fileSendQueue,&character,portMAX_DELAY);
 8000f2c:	4d92      	ldr	r5, [pc, #584]	; (8001178 <prvFileTask+0x2b8>)
        if (characterPosition == 1) lineLength = character;
 8000f2e:	4e9c      	ldr	r6, [pc, #624]	; (80011a0 <prvFileTask+0x2e0>)
	{
/* Build a command line before actioning */
/** The first character is the command, followed by the total message length
in bytes (which is the number of parameter bytes, if any, plus 2). */
        char character;
        xQueueReceive(fileSendQueue,&character,portMAX_DELAY);
 8000f30:	2300      	movs	r3, #0
 8000f32:	6828      	ldr	r0, [r5, #0]
 8000f34:	f10d 0106 	add.w	r1, sp, #6
 8000f38:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000f3c:	f004 ff1f 	bl	8005d7e <xQueueGenericReceive>
        if (characterPosition == 1) lineLength = character;
 8000f40:	7834      	ldrb	r4, [r6, #0]
 8000f42:	2c01      	cmp	r4, #1
 8000f44:	d103      	bne.n	8000f4e <prvFileTask+0x8e>
 8000f46:	f89d 1006 	ldrb.w	r1, [sp, #6]
 8000f4a:	4b96      	ldr	r3, [pc, #600]	; (80011a4 <prvFileTask+0x2e4>)
 8000f4c:	7019      	strb	r1, [r3, #0]
        line[characterPosition++] = character;
 8000f4e:	4d96      	ldr	r5, [pc, #600]	; (80011a8 <prvFileTask+0x2e8>)
 8000f50:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8000f54:	1c62      	adds	r2, r4, #1
 8000f56:	5528      	strb	r0, [r5, r4]
        if (characterPosition >= lineLength)
 8000f58:	4c92      	ldr	r4, [pc, #584]	; (80011a4 <prvFileTask+0x2e4>)
/** The first character is the command, followed by the total message length
in bytes (which is the number of parameter bytes, if any, plus 2). */
        char character;
        xQueueReceive(fileSendQueue,&character,portMAX_DELAY);
        if (characterPosition == 1) lineLength = character;
        line[characterPosition++] = character;
 8000f5a:	b2d6      	uxtb	r6, r2
        if (characterPosition >= lineLength)
 8000f5c:	7823      	ldrb	r3, [r4, #0]
/** The first character is the command, followed by the total message length
in bytes (which is the number of parameter bytes, if any, plus 2). */
        char character;
        xQueueReceive(fileSendQueue,&character,portMAX_DELAY);
        if (characterPosition == 1) lineLength = character;
        line[characterPosition++] = character;
 8000f5e:	4990      	ldr	r1, [pc, #576]	; (80011a0 <prvFileTask+0x2e0>)
        if (characterPosition >= lineLength)
 8000f60:	42b3      	cmp	r3, r6
/** The first character is the command, followed by the total message length
in bytes (which is the number of parameter bytes, if any, plus 2). */
        char character;
        xQueueReceive(fileSendQueue,&character,portMAX_DELAY);
        if (characterPosition == 1) lineLength = character;
        line[characterPosition++] = character;
 8000f62:	700e      	strb	r6, [r1, #0]
        if (characterPosition >= lineLength)
 8000f64:	d8e2      	bhi.n	8000f2c <prvFileTask+0x6c>
        {
            line[characterPosition] = 0;
 8000f66:	2000      	movs	r0, #0
 8000f68:	55a8      	strb	r0, [r5, r6]

static void parseFileCommand(char *line)
{
    FRESULT fileStatus;

    switch (line[0])
 8000f6a:	782a      	ldrb	r2, [r5, #0]
        if (characterPosition == 1) lineLength = character;
        line[characterPosition++] = character;
        if (characterPosition >= lineLength)
        {
            line[characterPosition] = 0;
            characterPosition = 0;
 8000f6c:	7008      	strb	r0, [r1, #0]

static void parseFileCommand(char *line)
{
    FRESULT fileStatus;

    switch (line[0])
 8000f6e:	3a43      	subs	r2, #67	; 0x43
 8000f70:	2a15      	cmp	r2, #21
 8000f72:	f200 8216 	bhi.w	80013a2 <prvFileTask+0x4e2>
 8000f76:	e8df f012 	tbh	[pc, r2, lsl #1]
 8000f7a:	007f      	.short	0x007f
 8000f7c:	0214011d 	.word	0x0214011d
 8000f80:	00cc016f 	.word	0x00cc016f
 8000f84:	02140214 	.word	0x02140214
 8000f88:	02140214 	.word	0x02140214
 8000f8c:	020d0214 	.word	0x020d0214
 8000f90:	02140214 	.word	0x02140214
 8000f94:	021400a7 	.word	0x021400a7
 8000f98:	01a20042 	.word	0x01a20042
 8000f9c:	02140214 	.word	0x02140214
 8000fa0:	00160214 	.word	0x00160214
 8000fa4:	01ea      	.short	0x01ea
/* Returns a file handle. On error file handle is 0xFF. */
        case 'W':
        {
            uint8_t fileHandle = 0xFF;
/* Already open */
            if (writeFileHandle < 0xFF)
 8000fa6:	497b      	ldr	r1, [pc, #492]	; (8001194 <prvFileTask+0x2d4>)
/* Open a file for read/write */
/* Parameter is a filename, 8 character plus dot plus 3 character extension */
/* Returns a file handle. On error file handle is 0xFF. */
        case 'W':
        {
            uint8_t fileHandle = 0xFF;
 8000fa8:	26ff      	movs	r6, #255	; 0xff
/* Already open */
            if (writeFileHandle < 0xFF)
 8000faa:	780d      	ldrb	r5, [r1, #0]
/* Open a file for read/write */
/* Parameter is a filename, 8 character plus dot plus 3 character extension */
/* Returns a file handle. On error file handle is 0xFF. */
        case 'W':
        {
            uint8_t fileHandle = 0xFF;
 8000fac:	f88d 600c 	strb.w	r6, [sp, #12]
/* Already open */
            if (writeFileHandle < 0xFF)
 8000fb0:	2dff      	cmp	r5, #255	; 0xff
 8000fb2:	d12b      	bne.n	800100c <prvFileTask+0x14c>
                fileStatus = FR_DENIED;
            else
            {
                fileHandle = findFileHandle();
 8000fb4:	f7ff ff60 	bl	8000e78 <findFileHandle>
/* Unable to be allocated */
                if (fileHandle >= MAX_OPEN_FILES)
 8000fb8:	2801      	cmp	r0, #1
/* Already open */
            if (writeFileHandle < 0xFF)
                fileStatus = FR_DENIED;
            else
            {
                fileHandle = findFileHandle();
 8000fba:	f88d 000c 	strb.w	r0, [sp, #12]
/* Unable to be allocated */
                if (fileHandle >= MAX_OPEN_FILES)
 8000fbe:	d82d      	bhi.n	800101c <prvFileTask+0x15c>
                    fileStatus = FR_TOO_MANY_OPEN_FILES;
                else
                {
/* Try to open a file write/read, creating it if necessary */
                    fileStatus = f_open(&file[fileHandle], line+2, \
 8000fc0:	4c7a      	ldr	r4, [pc, #488]	; (80011ac <prvFileTask+0x2ec>)
 8000fc2:	f44f 7609 	mov.w	r6, #548	; 0x224
 8000fc6:	fb06 4000 	mla	r0, r6, r0, r4
 8000fca:	4979      	ldr	r1, [pc, #484]	; (80011b0 <prvFileTask+0x2f0>)
 8000fcc:	2213      	movs	r2, #19
 8000fce:	f003 f857 	bl	8004080 <f_open>
 8000fd2:	4603      	mov	r3, r0
 8000fd4:	f88d 0007 	strb.w	r0, [sp, #7]
 8000fd8:	f89d 000c 	ldrb.w	r0, [sp, #12]
                                        FA_OPEN_ALWAYS | FA_READ | FA_WRITE);
/* Skip to the end of the file to append. */
                    if (fileStatus == FR_OK)
 8000fdc:	b93b      	cbnz	r3, 8000fee <prvFileTask+0x12e>
                        fileStatus = f_lseek(&file[fileHandle], f_size(file));
 8000fde:	fb06 4000 	mla	r0, r6, r0, r4
 8000fe2:	68e1      	ldr	r1, [r4, #12]
 8000fe4:	f003 fac4 	bl	8004570 <f_lseek>
 8000fe8:	f88d 0007 	strb.w	r0, [sp, #7]
 8000fec:	e003      	b.n	8000ff6 <prvFileTask+0x136>
                    else
                    {
                        deleteFileHandle(fileHandle);
 8000fee:	f7ff ff59 	bl	8000ea4 <deleteFileHandle>
                        fileHandle = 0xFF;
 8000ff2:	f88d 500c 	strb.w	r5, [sp, #12]
                    }
                    writeFileHandle = fileHandle;
 8000ff6:	f89d 600c 	ldrb.w	r6, [sp, #12]
 8000ffa:	4a66      	ldr	r2, [pc, #408]	; (8001194 <prvFileTask+0x2d4>)
 8000ffc:	e027      	b.n	800104e <prvFileTask+0x18e>
/* Returns a file handle */
        case 'R':
        {
            uint8_t fileHandle = 0xFF;
/* Already open */
            if (readFileHandle < 0xFF)
 8000ffe:	4866      	ldr	r0, [pc, #408]	; (8001198 <prvFileTask+0x2d8>)
/* Open a file read only. No check if the file is already opened. */
/* Parameter is a filename, 8 character plus dot plus 3 character extension */
/* Returns a file handle */
        case 'R':
        {
            uint8_t fileHandle = 0xFF;
 8001000:	25ff      	movs	r5, #255	; 0xff
/* Already open */
            if (readFileHandle < 0xFF)
 8001002:	7804      	ldrb	r4, [r0, #0]
/* Open a file read only. No check if the file is already opened. */
/* Parameter is a filename, 8 character plus dot plus 3 character extension */
/* Returns a file handle */
        case 'R':
        {
            uint8_t fileHandle = 0xFF;
 8001004:	f88d 500c 	strb.w	r5, [sp, #12]
/* Already open */
            if (readFileHandle < 0xFF)
 8001008:	2cff      	cmp	r4, #255	; 0xff
 800100a:	d001      	beq.n	8001010 <prvFileTask+0x150>
                fileStatus = FR_DENIED;
 800100c:	2007      	movs	r0, #7
 800100e:	e006      	b.n	800101e <prvFileTask+0x15e>
            else
            {
                fileHandle = findFileHandle();
 8001010:	f7ff ff32 	bl	8000e78 <findFileHandle>
/* Unable to be allocated */
                if (fileHandle >= MAX_OPEN_FILES)
 8001014:	2801      	cmp	r0, #1
/* Already open */
            if (readFileHandle < 0xFF)
                fileStatus = FR_DENIED;
            else
            {
                fileHandle = findFileHandle();
 8001016:	f88d 000c 	strb.w	r0, [sp, #12]
/* Unable to be allocated */
                if (fileHandle >= MAX_OPEN_FILES)
 800101a:	d903      	bls.n	8001024 <prvFileTask+0x164>
                    fileStatus = FR_TOO_MANY_OPEN_FILES;
 800101c:	2012      	movs	r0, #18
 800101e:	f88d 0007 	strb.w	r0, [sp, #7]
 8001022:	e021      	b.n	8001068 <prvFileTask+0x1a8>
                else
                {
/* Try to open a file read only */
                    fileStatus = f_open(&file[fileHandle], line+2, \
 8001024:	4b61      	ldr	r3, [pc, #388]	; (80011ac <prvFileTask+0x2ec>)
 8001026:	f44f 7109 	mov.w	r1, #548	; 0x224
 800102a:	fb01 3000 	mla	r0, r1, r0, r3
 800102e:	2201      	movs	r2, #1
 8001030:	495f      	ldr	r1, [pc, #380]	; (80011b0 <prvFileTask+0x2f0>)
 8001032:	f003 f825 	bl	8004080 <f_open>
 8001036:	f88d 0007 	strb.w	r0, [sp, #7]
                                        FA_OPEN_EXISTING | FA_READ);
                    if (fileStatus != FR_OK)
 800103a:	b128      	cbz	r0, 8001048 <prvFileTask+0x188>
                    {
                        deleteFileHandle(fileHandle);
 800103c:	f89d 000c 	ldrb.w	r0, [sp, #12]
 8001040:	f7ff ff30 	bl	8000ea4 <deleteFileHandle>
                        fileHandle = 0xFF;
 8001044:	f88d 400c 	strb.w	r4, [sp, #12]
                    }
                    readFileHandle = fileHandle;
 8001048:	f89d 600c 	ldrb.w	r6, [sp, #12]
 800104c:	4a52      	ldr	r2, [pc, #328]	; (8001198 <prvFileTask+0x2d8>)
 800104e:	7016      	strb	r6, [r2, #0]
                    if (fileStatus == FR_OK)
 8001050:	f89d 5007 	ldrb.w	r5, [sp, #7]
 8001054:	b945      	cbnz	r5, 8001068 <prvFileTask+0x1a8>
                        fileStatus = f_stat(line+2, fileInfo+readFileHandle);
 8001056:	494e      	ldr	r1, [pc, #312]	; (8001190 <prvFileTask+0x2d0>)
 8001058:	2418      	movs	r4, #24
 800105a:	4855      	ldr	r0, [pc, #340]	; (80011b0 <prvFileTask+0x2f0>)
 800105c:	fb04 1106 	mla	r1, r4, r6, r1
 8001060:	f003 fb7a 	bl	8004758 <f_stat>
 8001064:	f88d 0007 	strb.w	r0, [sp, #7]
                }
            }
          	xQueueSendToBack(fileReceiveQueue,&fileHandle,FILE_SEND_TIMEOUT);
 8001068:	4b44      	ldr	r3, [pc, #272]	; (800117c <prvFileTask+0x2bc>)
 800106a:	a903      	add	r1, sp, #12
 800106c:	6818      	ldr	r0, [r3, #0]
 800106e:	22c8      	movs	r2, #200	; 0xc8
 8001070:	2300      	movs	r3, #0
 8001072:	f004 fded 	bl	8005c50 <xQueueGenericSend>
 8001076:	e194      	b.n	80013a2 <prvFileTask+0x4e2>
        }
/* Close a file */
/* Parameter is a file handle that was given when opened */
        case 'C':
        {
            if (line[1] != 3)
 8001078:	786b      	ldrb	r3, [r5, #1]
 800107a:	2b03      	cmp	r3, #3
 800107c:	d001      	beq.n	8001082 <prvFileTask+0x1c2>
            {
                fileStatus = FR_INVALID_PARAMETER;
 800107e:	2213      	movs	r2, #19
 8001080:	e004      	b.n	800108c <prvFileTask+0x1cc>
                break;
            }
            uint8_t fileHandle = line[2];
 8001082:	4a49      	ldr	r2, [pc, #292]	; (80011a8 <prvFileTask+0x2e8>)
 8001084:	7894      	ldrb	r4, [r2, #2]
            if (fileHandle >= MAX_OPEN_FILES)
 8001086:	2c01      	cmp	r4, #1
 8001088:	d903      	bls.n	8001092 <prvFileTask+0x1d2>
            {
                fileStatus = FR_INVALID_OBJECT;
 800108a:	2209      	movs	r2, #9
 800108c:	f88d 2007 	strb.w	r2, [sp, #7]
 8001090:	e187      	b.n	80013a2 <prvFileTask+0x4e2>
                break;
            }
            if (writeFileHandle == fileHandle) writeFileHandle = 0xFF;
 8001092:	4840      	ldr	r0, [pc, #256]	; (8001194 <prvFileTask+0x2d4>)
 8001094:	7801      	ldrb	r1, [r0, #0]
 8001096:	42a1      	cmp	r1, r4
 8001098:	d003      	beq.n	80010a2 <prvFileTask+0x1e2>
            else if (readFileHandle == fileHandle) readFileHandle = 0xFF;
 800109a:	483f      	ldr	r0, [pc, #252]	; (8001198 <prvFileTask+0x2d8>)
 800109c:	7805      	ldrb	r5, [r0, #0]
 800109e:	42a5      	cmp	r5, r4
 80010a0:	d1f3      	bne.n	800108a <prvFileTask+0x1ca>
            else
            {
                fileStatus = FR_INVALID_OBJECT;
                break;
            }
            fileInfo[fileHandle].fname[0] = 0;
 80010a2:	4b3b      	ldr	r3, [pc, #236]	; (8001190 <prvFileTask+0x2d0>)
 80010a4:	2218      	movs	r2, #24
 80010a6:	fb02 3104 	mla	r1, r2, r4, r3
            {
                fileStatus = FR_INVALID_OBJECT;
                break;
            }
            if (writeFileHandle == fileHandle) writeFileHandle = 0xFF;
            else if (readFileHandle == fileHandle) readFileHandle = 0xFF;
 80010aa:	26ff      	movs	r6, #255	; 0xff
 80010ac:	7006      	strb	r6, [r0, #0]
            else
            {
                fileStatus = FR_INVALID_OBJECT;
                break;
            }
            fileInfo[fileHandle].fname[0] = 0;
 80010ae:	2000      	movs	r0, #0
            deleteFileHandle(fileHandle);
            fileStatus = f_close(&file[fileHandle]);
 80010b0:	4e3e      	ldr	r6, [pc, #248]	; (80011ac <prvFileTask+0x2ec>)
            else
            {
                fileStatus = FR_INVALID_OBJECT;
                break;
            }
            fileInfo[fileHandle].fname[0] = 0;
 80010b2:	7248      	strb	r0, [r1, #9]
            deleteFileHandle(fileHandle);
            fileStatus = f_close(&file[fileHandle]);
 80010b4:	f44f 7509 	mov.w	r5, #548	; 0x224
            {
                fileStatus = FR_INVALID_OBJECT;
                break;
            }
            fileInfo[fileHandle].fname[0] = 0;
            deleteFileHandle(fileHandle);
 80010b8:	4620      	mov	r0, r4
 80010ba:	f7ff fef3 	bl	8000ea4 <deleteFileHandle>
            fileStatus = f_close(&file[fileHandle]);
 80010be:	fb05 6004 	mla	r0, r5, r4, r6
 80010c2:	f003 fa4e 	bl	8004562 <f_close>
 80010c6:	e16a      	b.n	800139e <prvFileTask+0x4de>
The number of bytes to write is given by the length less 4. Returns the number
written. The number written will differ from the number requested if the disk
is full. */
        case 'P':
        {
            if (line[1] < 4) break;
 80010c8:	786d      	ldrb	r5, [r5, #1]
        line[characterPosition++] = character;
        if (characterPosition >= lineLength)
        {
            line[characterPosition] = 0;
            characterPosition = 0;
            parseFileCommand(line);
 80010ca:	4e37      	ldr	r6, [pc, #220]	; (80011a8 <prvFileTask+0x2e8>)
The number of bytes to write is given by the length less 4. Returns the number
written. The number written will differ from the number requested if the disk
is full. */
        case 'P':
        {
            if (line[1] < 4) break;
 80010cc:	2d03      	cmp	r5, #3
 80010ce:	f240 8168 	bls.w	80013a2 <prvFileTask+0x4e2>
            uint8_t fileHandle = line[2];
            UINT length = line[1]-3;
 80010d2:	1eec      	subs	r4, r5, #3
            UINT numWritten = 0;
 80010d4:	2100      	movs	r1, #0
            if (length < 82)
 80010d6:	2c51      	cmp	r4, #81	; 0x51
written. The number written will differ from the number requested if the disk
is full. */
        case 'P':
        {
            if (line[1] < 4) break;
            uint8_t fileHandle = line[2];
 80010d8:	78b2      	ldrb	r2, [r6, #2]
            UINT length = line[1]-3;
            UINT numWritten = 0;
 80010da:	9102      	str	r1, [sp, #8]
            if (length < 82)
 80010dc:	d811      	bhi.n	8001102 <prvFileTask+0x242>
            {
                fileStatus = f_write(&file[fileHandle],line+3,length,&numWritten);
 80010de:	4b33      	ldr	r3, [pc, #204]	; (80011ac <prvFileTask+0x2ec>)
 80010e0:	f44f 7509 	mov.w	r5, #548	; 0x224
 80010e4:	fb05 3502 	mla	r5, r5, r2, r3
 80010e8:	1cf1      	adds	r1, r6, #3
 80010ea:	4628      	mov	r0, r5
 80010ec:	4622      	mov	r2, r4
 80010ee:	ab02      	add	r3, sp, #8
 80010f0:	f003 f91f 	bl	8004332 <f_write>
 80010f4:	f88d 0007 	strb.w	r0, [sp, #7]
                if (fileStatus == FR_OK) f_sync(&file[fileHandle]);
 80010f8:	b930      	cbnz	r0, 8001108 <prvFileTask+0x248>
 80010fa:	4628      	mov	r0, r5
 80010fc:	f003 f9db 	bl	80044b6 <f_sync>
 8001100:	e002      	b.n	8001108 <prvFileTask+0x248>
            }
            else fileStatus = FR_INVALID_PARAMETER;
 8001102:	2013      	movs	r0, #19
 8001104:	f88d 0007 	strb.w	r0, [sp, #7]
/* Send a denied status if the disk fills. The program probably won't use this. */
            if (numWritten != length) fileStatus = FR_DENIED;
 8001108:	9e02      	ldr	r6, [sp, #8]
 800110a:	42a6      	cmp	r6, r4
 800110c:	f040 8140 	bne.w	8001390 <prvFileTask+0x4d0>
 8001110:	e147      	b.n	80013a2 <prvFileTask+0x4e2>
        case 'G':
        {
            uint8_t buffer[80];
            uint8_t fileHandle = line[2];
            uint8_t i = 0;
            UINT length = line[3];
 8001112:	78ea      	ldrb	r2, [r5, #3]
Returns the number read followed by binary byte-wise data. The number read will
differ from the number requested if EOF reached. */
        case 'G':
        {
            uint8_t buffer[80];
            uint8_t fileHandle = line[2];
 8001114:	78ac      	ldrb	r4, [r5, #2]
            uint8_t i = 0;
            UINT length = line[3];
            UINT numRead = 0;
            if (length < 82)
 8001116:	2a51      	cmp	r2, #81	; 0x51
        {
            uint8_t buffer[80];
            uint8_t fileHandle = line[2];
            uint8_t i = 0;
            UINT length = line[3];
            UINT numRead = 0;
 8001118:	9002      	str	r0, [sp, #8]
            if (length < 82)
 800111a:	d80b      	bhi.n	8001134 <prvFileTask+0x274>
                fileStatus = f_read(&file[fileHandle],buffer,length,&numRead);
 800111c:	4b23      	ldr	r3, [pc, #140]	; (80011ac <prvFileTask+0x2ec>)
 800111e:	f44f 7009 	mov.w	r0, #548	; 0x224
 8001122:	fb00 3004 	mla	r0, r0, r4, r3
 8001126:	a904      	add	r1, sp, #16
 8001128:	ab02      	add	r3, sp, #8
 800112a:	f003 f856 	bl	80041da <f_read>
 800112e:	f88d 0007 	strb.w	r0, [sp, #7]
 8001132:	e002      	b.n	800113a <prvFileTask+0x27a>
            else fileStatus = FR_INVALID_PARAMETER;
 8001134:	2113      	movs	r1, #19
 8001136:	f88d 1007 	strb.w	r1, [sp, #7]
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= numRead+1)
 800113a:	4d10      	ldr	r5, [pc, #64]	; (800117c <prvFileTask+0x2bc>)
 800113c:	6828      	ldr	r0, [r5, #0]
 800113e:	f004 fed1 	bl	8005ee4 <uxQueueSpacesAvailable>
 8001142:	9e02      	ldr	r6, [sp, #8]
 8001144:	1c72      	adds	r2, r6, #1
 8001146:	4290      	cmp	r0, r2
 8001148:	f0c0 812b 	bcc.w	80013a2 <prvFileTask+0x4e2>
            {
                xQueueSendToBack(fileReceiveQueue,&numRead,FILE_SEND_TIMEOUT);
 800114c:	6828      	ldr	r0, [r5, #0]
 800114e:	a902      	add	r1, sp, #8
 8001150:	22c8      	movs	r2, #200	; 0xc8
 8001152:	2300      	movs	r3, #0
 8001154:	f004 fd7c 	bl	8005c50 <xQueueGenericSend>
                for (i=0; i<numRead; i++)
 8001158:	2500      	movs	r5, #0
 800115a:	9902      	ldr	r1, [sp, #8]
 800115c:	428d      	cmp	r5, r1
 800115e:	f080 8120 	bcs.w	80013a2 <prvFileTask+0x4e2>
                    xQueueSendToBack(fileReceiveQueue,buffer+i,FILE_SEND_TIMEOUT);
 8001162:	4806      	ldr	r0, [pc, #24]	; (800117c <prvFileTask+0x2bc>)
 8001164:	ab04      	add	r3, sp, #16
 8001166:	1959      	adds	r1, r3, r5
 8001168:	6800      	ldr	r0, [r0, #0]
 800116a:	22c8      	movs	r2, #200	; 0xc8
 800116c:	2300      	movs	r3, #0
                fileStatus = f_read(&file[fileHandle],buffer,length,&numRead);
            else fileStatus = FR_INVALID_PARAMETER;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= numRead+1)
            {
                xQueueSendToBack(fileReceiveQueue,&numRead,FILE_SEND_TIMEOUT);
                for (i=0; i<numRead; i++)
 800116e:	1c6c      	adds	r4, r5, #1
                    xQueueSendToBack(fileReceiveQueue,buffer+i,FILE_SEND_TIMEOUT);
 8001170:	f004 fd6e 	bl	8005c50 <xQueueGenericSend>
                fileStatus = f_read(&file[fileHandle],buffer,length,&numRead);
            else fileStatus = FR_INVALID_PARAMETER;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= numRead+1)
            {
                xQueueSendToBack(fileReceiveQueue,&numRead,FILE_SEND_TIMEOUT);
                for (i=0; i<numRead; i++)
 8001174:	b2e5      	uxtb	r5, r4
 8001176:	e7f0      	b.n	800115a <prvFileTask+0x29a>
 8001178:	200007e4 	.word	0x200007e4
 800117c:	2000078c 	.word	0x2000078c
 8001180:	20000784 	.word	0x20000784
 8001184:	080074c7 	.word	0x080074c7
 8001188:	20000534 	.word	0x20000534
 800118c:	200007e0 	.word	0x200007e0
 8001190:	200007ec 	.word	0x200007ec
 8001194:	2000081c 	.word	0x2000081c
 8001198:	200007e8 	.word	0x200007e8
 800119c:	20000788 	.word	0x20000788
 80011a0:	20000780 	.word	0x20000780
 80011a4:	20000000 	.word	0x20000000
 80011a8:	20000790 	.word	0x20000790
 80011ac:	200000e8 	.word	0x200000e8
 80011b0:	20000792 	.word	0x20000792
        line[characterPosition++] = character;
        if (characterPosition >= lineLength)
        {
            line[characterPosition] = 0;
            characterPosition = 0;
            parseFileCommand(line);
 80011b4:	4d7f      	ldr	r5, [pc, #508]	; (80013b4 <prvFileTask+0x4f4>)
        {
            uint8_t i = 0;
            uint8_t numRead = 0;
            static DIR directory;
            FILINFO fileInfo;
            fileStatus = FR_OK;
 80011b6:	f88d 0007 	strb.w	r0, [sp, #7]
            if (line[2] != 0) fileStatus = f_opendir(&directory, line+2);
 80011ba:	78a9      	ldrb	r1, [r5, #2]
 80011bc:	b129      	cbz	r1, 80011ca <prvFileTask+0x30a>
 80011be:	487e      	ldr	r0, [pc, #504]	; (80013b8 <prvFileTask+0x4f8>)
 80011c0:	1ca9      	adds	r1, r5, #2
 80011c2:	f003 fa6f 	bl	80046a4 <f_opendir>
 80011c6:	f88d 0007 	strb.w	r0, [sp, #7]
            if (fileStatus == FR_OK)
 80011ca:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80011ce:	b958      	cbnz	r0, 80011e8 <prvFileTask+0x328>
            {
                fileStatus = f_readdir(&directory, &fileInfo);
 80011d0:	a904      	add	r1, sp, #16
 80011d2:	4879      	ldr	r0, [pc, #484]	; (80013b8 <prvFileTask+0x4f8>)
 80011d4:	f003 fa98 	bl	8004708 <f_readdir>
 80011d8:	f88d 0007 	strb.w	r0, [sp, #7]
                numRead = stringLength(fileInfo.fname);
 80011dc:	f10d 0019 	add.w	r0, sp, #25
 80011e0:	f001 fc6c 	bl	8002abc <stringLength>
 80011e4:	b2c4      	uxtb	r4, r0
 80011e6:	e000      	b.n	80011ea <prvFileTask+0x32a>
 f = file, d = directory, n = error e = end
will be sent. */
        case 'D':
        {
            uint8_t i = 0;
            uint8_t numRead = 0;
 80011e8:	2400      	movs	r4, #0
            {
                fileStatus = f_readdir(&directory, &fileInfo);
                numRead = stringLength(fileInfo.fname);
            }
            char type = 'f';
            if (fileInfo.fattrib == AM_DIR) type = 'd';
 80011ea:	f89d 6018 	ldrb.w	r6, [sp, #24]
            if (fileStatus == FR_OK)
            {
                fileStatus = f_readdir(&directory, &fileInfo);
                numRead = stringLength(fileInfo.fname);
            }
            char type = 'f';
 80011ee:	2366      	movs	r3, #102	; 0x66
            if (fileInfo.fattrib == AM_DIR) type = 'd';
 80011f0:	2e10      	cmp	r6, #16
            if (fileStatus == FR_OK)
            {
                fileStatus = f_readdir(&directory, &fileInfo);
                numRead = stringLength(fileInfo.fname);
            }
            char type = 'f';
 80011f2:	f88d 300c 	strb.w	r3, [sp, #12]
            if (fileInfo.fattrib == AM_DIR) type = 'd';
 80011f6:	d102      	bne.n	80011fe <prvFileTask+0x33e>
 80011f8:	2264      	movs	r2, #100	; 0x64
 80011fa:	f88d 200c 	strb.w	r2, [sp, #12]
            if (fileInfo.fname[0] == 0) type = 'e';
 80011fe:	f89d 5019 	ldrb.w	r5, [sp, #25]
 8001202:	b915      	cbnz	r5, 800120a <prvFileTask+0x34a>
 8001204:	2165      	movs	r1, #101	; 0x65
 8001206:	f88d 100c 	strb.w	r1, [sp, #12]
            if (fileStatus != FR_OK)
 800120a:	f89d 0007 	ldrb.w	r0, [sp, #7]
 800120e:	b128      	cbz	r0, 800121c <prvFileTask+0x35c>
            {
                numRead = 0;
                fileInfo.fname[0] = 0;
 8001210:	2400      	movs	r4, #0
                type = 'n';
 8001212:	236e      	movs	r3, #110	; 0x6e
            if (fileInfo.fattrib == AM_DIR) type = 'd';
            if (fileInfo.fname[0] == 0) type = 'e';
            if (fileStatus != FR_OK)
            {
                numRead = 0;
                fileInfo.fname[0] = 0;
 8001214:	f88d 4019 	strb.w	r4, [sp, #25]
                type = 'n';
 8001218:	f88d 300c 	strb.w	r3, [sp, #12]
            }
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= numRead+2)
 800121c:	4e67      	ldr	r6, [pc, #412]	; (80013bc <prvFileTask+0x4fc>)
 800121e:	6830      	ldr	r0, [r6, #0]
 8001220:	f004 fe60 	bl	8005ee4 <uxQueueSpacesAvailable>
 8001224:	1ca2      	adds	r2, r4, #2
 8001226:	4290      	cmp	r0, r2
 8001228:	f0c0 80bb 	bcc.w	80013a2 <prvFileTask+0x4e2>
            {
                xQueueSendToBack(fileReceiveQueue,&type,FILE_SEND_TIMEOUT);
 800122c:	6830      	ldr	r0, [r6, #0]
 800122e:	a903      	add	r1, sp, #12
 8001230:	22c8      	movs	r2, #200	; 0xc8
 8001232:	2300      	movs	r3, #0
 8001234:	f004 fd0c 	bl	8005c50 <xQueueGenericSend>
                for (i=0; i<numRead+1; i++)
 8001238:	2600      	movs	r6, #0
 800123a:	42b4      	cmp	r4, r6
 800123c:	f2c0 80b1 	blt.w	80013a2 <prvFileTask+0x4e2>
                    xQueueSendToBack(fileReceiveQueue,fileInfo.fname+i,FILE_SEND_TIMEOUT);
 8001240:	a918      	add	r1, sp, #96	; 0x60
 8001242:	485e      	ldr	r0, [pc, #376]	; (80013bc <prvFileTask+0x4fc>)
 8001244:	1989      	adds	r1, r1, r6
 8001246:	6800      	ldr	r0, [r0, #0]
 8001248:	3947      	subs	r1, #71	; 0x47
 800124a:	22c8      	movs	r2, #200	; 0xc8
 800124c:	2300      	movs	r3, #0
                type = 'n';
            }
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= numRead+2)
            {
                xQueueSendToBack(fileReceiveQueue,&type,FILE_SEND_TIMEOUT);
                for (i=0; i<numRead+1; i++)
 800124e:	1c75      	adds	r5, r6, #1
                    xQueueSendToBack(fileReceiveQueue,fileInfo.fname+i,FILE_SEND_TIMEOUT);
 8001250:	f004 fcfe 	bl	8005c50 <xQueueGenericSend>
                type = 'n';
            }
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= numRead+2)
            {
                xQueueSendToBack(fileReceiveQueue,&type,FILE_SEND_TIMEOUT);
                for (i=0; i<numRead+1; i++)
 8001254:	b2ee      	uxtb	r6, r5
 8001256:	e7f0      	b.n	800123a <prvFileTask+0x37a>
/* Read the free space on the drive. */
/* No parameters. Returns free clusters as 4 bytes (32 bit word), lowest first */
        case 'F':
        {
            DWORD freeClusters = 0;
	        fileStatus = f_getfree("", (DWORD*)&freeClusters, &fs);
 8001258:	4e59      	ldr	r6, [pc, #356]	; (80013c0 <prvFileTask+0x500>)
        }
/* Read the free space on the drive. */
/* No parameters. Returns free clusters as 4 bytes (32 bit word), lowest first */
        case 'F':
        {
            DWORD freeClusters = 0;
 800125a:	a918      	add	r1, sp, #96	; 0x60
 800125c:	f841 0d54 	str.w	r0, [r1, #-84]!
	        fileStatus = f_getfree("", (DWORD*)&freeClusters, &fs);
 8001260:	4632      	mov	r2, r6
 8001262:	4858      	ldr	r0, [pc, #352]	; (80013c4 <prvFileTask+0x504>)
 8001264:	f003 fa97 	bl	8004796 <f_getfree>
            uint32_t sectorCluster = fs->csize;
            uint8_t i;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= 8)
 8001268:	4954      	ldr	r1, [pc, #336]	; (80013bc <prvFileTask+0x4fc>)
/* No parameters. Returns free clusters as 4 bytes (32 bit word), lowest first */
        case 'F':
        {
            DWORD freeClusters = 0;
	        fileStatus = f_getfree("", (DWORD*)&freeClusters, &fs);
            uint32_t sectorCluster = fs->csize;
 800126a:	6832      	ldr	r2, [r6, #0]
/* Read the free space on the drive. */
/* No parameters. Returns free clusters as 4 bytes (32 bit word), lowest first */
        case 'F':
        {
            DWORD freeClusters = 0;
	        fileStatus = f_getfree("", (DWORD*)&freeClusters, &fs);
 800126c:	f88d 0007 	strb.w	r0, [sp, #7]
            uint32_t sectorCluster = fs->csize;
            uint8_t i;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= 8)
 8001270:	6808      	ldr	r0, [r1, #0]
/* No parameters. Returns free clusters as 4 bytes (32 bit word), lowest first */
        case 'F':
        {
            DWORD freeClusters = 0;
	        fileStatus = f_getfree("", (DWORD*)&freeClusters, &fs);
            uint32_t sectorCluster = fs->csize;
 8001272:	7895      	ldrb	r5, [r2, #2]
            uint8_t i;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= 8)
 8001274:	f004 fe36 	bl	8005ee4 <uxQueueSpacesAvailable>
 8001278:	2807      	cmp	r0, #7
 800127a:	f240 8092 	bls.w	80013a2 <prvFileTask+0x4e2>
 800127e:	2400      	movs	r4, #0
            {
                for (i=0; i<4; i++)
                {
                    uint8_t wordBuf = (freeClusters >> 8*i) & 0xFF;
 8001280:	9803      	ldr	r0, [sp, #12]
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
 8001282:	4b4e      	ldr	r3, [pc, #312]	; (80013bc <prvFileTask+0x4fc>)
            uint8_t i;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= 8)
            {
                for (i=0; i<4; i++)
                {
                    uint8_t wordBuf = (freeClusters >> 8*i) & 0xFF;
 8001284:	fa20 f004 	lsr.w	r0, r0, r4
 8001288:	a918      	add	r1, sp, #96	; 0x60
 800128a:	f801 0d58 	strb.w	r0, [r1, #-88]!
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
 800128e:	22c8      	movs	r2, #200	; 0xc8
 8001290:	6818      	ldr	r0, [r3, #0]
 8001292:	3408      	adds	r4, #8
 8001294:	2300      	movs	r3, #0
 8001296:	f004 fcdb 	bl	8005c50 <xQueueGenericSend>
	        fileStatus = f_getfree("", (DWORD*)&freeClusters, &fs);
            uint32_t sectorCluster = fs->csize;
            uint8_t i;
            if (uxQueueSpacesAvailable(fileReceiveQueue) >= 8)
            {
                for (i=0; i<4; i++)
 800129a:	2c20      	cmp	r4, #32
 800129c:	d1f0      	bne.n	8001280 <prvFileTask+0x3c0>
 800129e:	2600      	movs	r6, #0
                    uint8_t wordBuf = (freeClusters >> 8*i) & 0xFF;
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
                }
                for (i=0; i<4; i++)
                {
                    uint8_t wordBuf = (sectorCluster >> 8*i) & 0xFF;
 80012a0:	fa25 f206 	lsr.w	r2, r5, r6
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
 80012a4:	4c45      	ldr	r4, [pc, #276]	; (80013bc <prvFileTask+0x4fc>)
                    uint8_t wordBuf = (freeClusters >> 8*i) & 0xFF;
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
                }
                for (i=0; i<4; i++)
                {
                    uint8_t wordBuf = (sectorCluster >> 8*i) & 0xFF;
 80012a6:	a918      	add	r1, sp, #96	; 0x60
 80012a8:	f801 2d58 	strb.w	r2, [r1, #-88]!
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
 80012ac:	2300      	movs	r3, #0
 80012ae:	22c8      	movs	r2, #200	; 0xc8
 80012b0:	6820      	ldr	r0, [r4, #0]
 80012b2:	3608      	adds	r6, #8
 80012b4:	f004 fccc 	bl	8005c50 <xQueueGenericSend>
                for (i=0; i<4; i++)
                {
                    uint8_t wordBuf = (freeClusters >> 8*i) & 0xFF;
                    xQueueSendToBack(fileReceiveQueue,&wordBuf,FILE_SEND_TIMEOUT);
                }
                for (i=0; i<4; i++)
 80012b8:	2e20      	cmp	r6, #32
 80012ba:	d1f1      	bne.n	80012a0 <prvFileTask+0x3e0>
 80012bc:	e071      	b.n	80013a2 <prvFileTask+0x4e2>
            break;
        }
/* Return the open status, name and size of open files. */
        case 'S':
        {
            xQueueSendToBack(fileReceiveQueue,&writeFileHandle,FILE_SEND_TIMEOUT);
 80012be:	4d42      	ldr	r5, [pc, #264]	; (80013c8 <prvFileTask+0x508>)
 80012c0:	483e      	ldr	r0, [pc, #248]	; (80013bc <prvFileTask+0x4fc>)
 80012c2:	22c8      	movs	r2, #200	; 0xc8
 80012c4:	2300      	movs	r3, #0
 80012c6:	6800      	ldr	r0, [r0, #0]
 80012c8:	4629      	mov	r1, r5
 80012ca:	f004 fcc1 	bl	8005c50 <xQueueGenericSend>
            if (writeFileHandle  < 0xFF)
 80012ce:	782a      	ldrb	r2, [r5, #0]
 80012d0:	2aff      	cmp	r2, #255	; 0xff
 80012d2:	d10b      	bne.n	80012ec <prvFileTask+0x42c>
                    xQueueSendToBack(fileReceiveQueue,writeNameChar,FILE_SEND_TIMEOUT);
                    i++;
                }
                while (*writeNameChar > 0);
            }
            xQueueSendToBack(fileReceiveQueue,&readFileHandle,FILE_SEND_TIMEOUT);
 80012d4:	4d3d      	ldr	r5, [pc, #244]	; (80013cc <prvFileTask+0x50c>)
 80012d6:	4a39      	ldr	r2, [pc, #228]	; (80013bc <prvFileTask+0x4fc>)
 80012d8:	4629      	mov	r1, r5
 80012da:	6810      	ldr	r0, [r2, #0]
 80012dc:	2300      	movs	r3, #0
 80012de:	22c8      	movs	r2, #200	; 0xc8
 80012e0:	f004 fcb6 	bl	8005c50 <xQueueGenericSend>
            if (readFileHandle  < 0xFF)
 80012e4:	7829      	ldrb	r1, [r5, #0]
 80012e6:	29ff      	cmp	r1, #255	; 0xff
 80012e8:	d118      	bne.n	800131c <prvFileTask+0x45c>
 80012ea:	e02e      	b.n	800134a <prvFileTask+0x48a>
        }
/* Return the open status, name and size of open files. */
        case 'S':
        {
            xQueueSendToBack(fileReceiveQueue,&writeFileHandle,FILE_SEND_TIMEOUT);
            if (writeFileHandle  < 0xFF)
 80012ec:	2300      	movs	r3, #0
            {
                TCHAR *writeNameChar;
                uint8_t i=0;
                do
                {
                    writeNameChar = fileInfo[writeFileHandle].fname+i;
 80012ee:	4936      	ldr	r1, [pc, #216]	; (80013c8 <prvFileTask+0x508>)
 80012f0:	2518      	movs	r5, #24
 80012f2:	7808      	ldrb	r0, [r1, #0]
 80012f4:	4e36      	ldr	r6, [pc, #216]	; (80013d0 <prvFileTask+0x510>)
 80012f6:	4345      	muls	r5, r0
 80012f8:	461c      	mov	r4, r3
                    xQueueSendToBack(fileReceiveQueue,writeNameChar,FILE_SEND_TIMEOUT);
 80012fa:	4a30      	ldr	r2, [pc, #192]	; (80013bc <prvFileTask+0x4fc>)
            {
                TCHAR *writeNameChar;
                uint8_t i=0;
                do
                {
                    writeNameChar = fileInfo[writeFileHandle].fname+i;
 80012fc:	195b      	adds	r3, r3, r5
 80012fe:	18f1      	adds	r1, r6, r3
                    xQueueSendToBack(fileReceiveQueue,writeNameChar,FILE_SEND_TIMEOUT);
 8001300:	6810      	ldr	r0, [r2, #0]
 8001302:	3109      	adds	r1, #9
 8001304:	2300      	movs	r3, #0
 8001306:	22c8      	movs	r2, #200	; 0xc8
 8001308:	f004 fca2 	bl	8005c50 <xQueueGenericSend>
                    i++;
                }
                while (*writeNameChar > 0);
 800130c:	1970      	adds	r0, r6, r5
                uint8_t i=0;
                do
                {
                    writeNameChar = fileInfo[writeFileHandle].fname+i;
                    xQueueSendToBack(fileReceiveQueue,writeNameChar,FILE_SEND_TIMEOUT);
                    i++;
 800130e:	1c61      	adds	r1, r4, #1
                }
                while (*writeNameChar > 0);
 8001310:	1904      	adds	r4, r0, r4
 8001312:	7a66      	ldrb	r6, [r4, #9]
                uint8_t i=0;
                do
                {
                    writeNameChar = fileInfo[writeFileHandle].fname+i;
                    xQueueSendToBack(fileReceiveQueue,writeNameChar,FILE_SEND_TIMEOUT);
                    i++;
 8001314:	b2cb      	uxtb	r3, r1
                }
                while (*writeNameChar > 0);
 8001316:	2e00      	cmp	r6, #0
 8001318:	d1e9      	bne.n	80012ee <prvFileTask+0x42e>
 800131a:	e7db      	b.n	80012d4 <prvFileTask+0x414>
            }
            xQueueSendToBack(fileReceiveQueue,&readFileHandle,FILE_SEND_TIMEOUT);
            if (readFileHandle  < 0xFF)
 800131c:	2300      	movs	r3, #0
            {
                TCHAR *readNameChar;
                uint8_t i=0;
                do
                {
                    readNameChar = fileInfo[readFileHandle].fname+i;
 800131e:	482b      	ldr	r0, [pc, #172]	; (80013cc <prvFileTask+0x50c>)
 8001320:	2518      	movs	r5, #24
 8001322:	7802      	ldrb	r2, [r0, #0]
 8001324:	4e2a      	ldr	r6, [pc, #168]	; (80013d0 <prvFileTask+0x510>)
 8001326:	4355      	muls	r5, r2
 8001328:	461c      	mov	r4, r3
                    xQueueSendToBack(fileReceiveQueue,readNameChar,FILE_SEND_TIMEOUT);
 800132a:	4824      	ldr	r0, [pc, #144]	; (80013bc <prvFileTask+0x4fc>)
            {
                TCHAR *readNameChar;
                uint8_t i=0;
                do
                {
                    readNameChar = fileInfo[readFileHandle].fname+i;
 800132c:	195b      	adds	r3, r3, r5
 800132e:	18f1      	adds	r1, r6, r3
                    xQueueSendToBack(fileReceiveQueue,readNameChar,FILE_SEND_TIMEOUT);
 8001330:	3109      	adds	r1, #9
 8001332:	22c8      	movs	r2, #200	; 0xc8
 8001334:	2300      	movs	r3, #0
 8001336:	6800      	ldr	r0, [r0, #0]
 8001338:	f004 fc8a 	bl	8005c50 <xQueueGenericSend>
                    i++;
                }
                while (*readNameChar > 0);
 800133c:	1972      	adds	r2, r6, r5
                uint8_t i=0;
                do
                {
                    readNameChar = fileInfo[readFileHandle].fname+i;
                    xQueueSendToBack(fileReceiveQueue,readNameChar,FILE_SEND_TIMEOUT);
                    i++;
 800133e:	1c61      	adds	r1, r4, #1
                }
                while (*readNameChar > 0);
 8001340:	1914      	adds	r4, r2, r4
 8001342:	7a66      	ldrb	r6, [r4, #9]
                uint8_t i=0;
                do
                {
                    readNameChar = fileInfo[readFileHandle].fname+i;
                    xQueueSendToBack(fileReceiveQueue,readNameChar,FILE_SEND_TIMEOUT);
                    i++;
 8001344:	b2cb      	uxtb	r3, r1
                }
                while (*readNameChar > 0);
 8001346:	2e00      	cmp	r6, #0
 8001348:	d1e9      	bne.n	800131e <prvFileTask+0x45e>
            }
            fileStatus = 0;
 800134a:	2200      	movs	r2, #0
 800134c:	e69e      	b.n	800108c <prvFileTask+0x1cc>
        }
/* Delete a file. Beware that the file be NOT open when deleting.
Checks the filename and handle for the write and read files, if they are open. */
        case 'X':
        {
            if (! ((writeFileHandle < 0xFF) &&
 800134e:	4d1e      	ldr	r5, [pc, #120]	; (80013c8 <prvFileTask+0x508>)
 8001350:	782e      	ldrb	r6, [r5, #0]
 8001352:	2eff      	cmp	r6, #255	; 0xff
 8001354:	d104      	bne.n	8001360 <prvFileTask+0x4a0>
                stringEqual((char*)line+2, fileInfo[writeFileHandle].fname)) &&
                ! ((readFileHandle < 0xFF) &&
 8001356:	4b1d      	ldr	r3, [pc, #116]	; (80013cc <prvFileTask+0x50c>)
 8001358:	7818      	ldrb	r0, [r3, #0]
/* Delete a file. Beware that the file be NOT open when deleting.
Checks the filename and handle for the write and read files, if they are open. */
        case 'X':
        {
            if (! ((writeFileHandle < 0xFF) &&
                stringEqual((char*)line+2, fileInfo[writeFileHandle].fname)) &&
 800135a:	28ff      	cmp	r0, #255	; 0xff
 800135c:	d10b      	bne.n	8001376 <prvFileTask+0x4b6>
 800135e:	e013      	b.n	8001388 <prvFileTask+0x4c8>
 8001360:	4c1b      	ldr	r4, [pc, #108]	; (80013d0 <prvFileTask+0x510>)
 8001362:	2118      	movs	r1, #24
 8001364:	fb01 4106 	mla	r1, r1, r6, r4
 8001368:	481a      	ldr	r0, [pc, #104]	; (80013d4 <prvFileTask+0x514>)
 800136a:	3109      	adds	r1, #9
 800136c:	f001 fbbe 	bl	8002aec <stringEqual>
        }
/* Delete a file. Beware that the file be NOT open when deleting.
Checks the filename and handle for the write and read files, if they are open. */
        case 'X':
        {
            if (! ((writeFileHandle < 0xFF) &&
 8001370:	2800      	cmp	r0, #0
 8001372:	d0f0      	beq.n	8001356 <prvFileTask+0x496>
 8001374:	e00c      	b.n	8001390 <prvFileTask+0x4d0>
                stringEqual((char*)line+2, fileInfo[writeFileHandle].fname)) &&
                ! ((readFileHandle < 0xFF) &&
                stringEqual((char*)line+2, fileInfo[readFileHandle].fname)))
 8001376:	4a16      	ldr	r2, [pc, #88]	; (80013d0 <prvFileTask+0x510>)
 8001378:	2518      	movs	r5, #24
 800137a:	fb05 2100 	mla	r1, r5, r0, r2
 800137e:	4815      	ldr	r0, [pc, #84]	; (80013d4 <prvFileTask+0x514>)
 8001380:	3109      	adds	r1, #9
 8001382:	f001 fbb3 	bl	8002aec <stringEqual>
Checks the filename and handle for the write and read files, if they are open. */
        case 'X':
        {
            if (! ((writeFileHandle < 0xFF) &&
                stringEqual((char*)line+2, fileInfo[writeFileHandle].fname)) &&
                ! ((readFileHandle < 0xFF) &&
 8001386:	b918      	cbnz	r0, 8001390 <prvFileTask+0x4d0>
                stringEqual((char*)line+2, fileInfo[readFileHandle].fname)))
            {
                fileStatus = f_unlink(line+2);
 8001388:	4812      	ldr	r0, [pc, #72]	; (80013d4 <prvFileTask+0x514>)
 800138a:	f003 fa75 	bl	8004878 <f_unlink>
 800138e:	e006      	b.n	800139e <prvFileTask+0x4de>
            }
            else
                fileStatus = FR_DENIED;
 8001390:	2207      	movs	r2, #7
 8001392:	e67b      	b.n	800108c <prvFileTask+0x1cc>
            break;
        }
/* Remount the memory card. */
        case 'M':
        {
            fileStatus = f_mount(&Fatfs[0],"",0);
 8001394:	4810      	ldr	r0, [pc, #64]	; (80013d8 <prvFileTask+0x518>)
 8001396:	490b      	ldr	r1, [pc, #44]	; (80013c4 <prvFileTask+0x504>)
 8001398:	2200      	movs	r2, #0
 800139a:	f002 fe4b 	bl	8004034 <f_mount>
 800139e:	f88d 0007 	strb.w	r0, [sp, #7]
            break;
        }
    }
    xQueueSendToBack(fileReceiveQueue,&fileStatus,FILE_SEND_TIMEOUT);
 80013a2:	4c06      	ldr	r4, [pc, #24]	; (80013bc <prvFileTask+0x4fc>)
 80013a4:	f10d 0107 	add.w	r1, sp, #7
 80013a8:	6820      	ldr	r0, [r4, #0]
 80013aa:	22c8      	movs	r2, #200	; 0xc8
 80013ac:	2300      	movs	r3, #0
 80013ae:	f004 fc4f 	bl	8005c50 <xQueueGenericSend>
        {
            line[characterPosition] = 0;
            characterPosition = 0;
            parseFileCommand(line);
        }
    }
 80013b2:	e5bb      	b.n	8000f2c <prvFileTask+0x6c>
 80013b4:	20000790 	.word	0x20000790
 80013b8:	20000764 	.word	0x20000764
 80013bc:	2000078c 	.word	0x2000078c
 80013c0:	20000530 	.word	0x20000530
 80013c4:	080074c7 	.word	0x080074c7
 80013c8:	2000081c 	.word	0x2000081c
 80013cc:	200007e8 	.word	0x200007e8
 80013d0:	200007ec 	.word	0x200007ec
 80013d4:	20000792 	.word	0x20000792
 80013d8:	20000534 	.word	0x20000534

080013dc <sendFileCommand>:
@param[in] uint8_t length: Length of parameter set only.
@param[in] uint8_t *parameters: Parameter list. 
*/

void sendFileCommand(char command, uint8_t length, uint8_t *parameters)
{
 80013dc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    uint8_t i;
    uint8_t totalLength = length+2;
    if (uxQueueSpacesAvailable(fileSendQueue) >= totalLength)
 80013de:	4c16      	ldr	r4, [pc, #88]	; (8001438 <sendFileCommand+0x5c>)
*/

void sendFileCommand(char command, uint8_t length, uint8_t *parameters)
{
    uint8_t i;
    uint8_t totalLength = length+2;
 80013e0:	1c8b      	adds	r3, r1, #2
@param[in] uint8_t length: Length of parameter set only.
@param[in] uint8_t *parameters: Parameter list. 
*/

void sendFileCommand(char command, uint8_t length, uint8_t *parameters)
{
 80013e2:	f88d 0007 	strb.w	r0, [sp, #7]
    uint8_t i;
    uint8_t totalLength = length+2;
    if (uxQueueSpacesAvailable(fileSendQueue) >= totalLength)
 80013e6:	6820      	ldr	r0, [r4, #0]
@param[in] uint8_t length: Length of parameter set only.
@param[in] uint8_t *parameters: Parameter list. 
*/

void sendFileCommand(char command, uint8_t length, uint8_t *parameters)
{
 80013e8:	460d      	mov	r5, r1
 80013ea:	4616      	mov	r6, r2
    uint8_t i;
    uint8_t totalLength = length+2;
 80013ec:	f88d 300f 	strb.w	r3, [sp, #15]
    if (uxQueueSpacesAvailable(fileSendQueue) >= totalLength)
 80013f0:	f004 fd78 	bl	8005ee4 <uxQueueSpacesAvailable>
 80013f4:	f89d 100f 	ldrb.w	r1, [sp, #15]
 80013f8:	4288      	cmp	r0, r1
 80013fa:	d31b      	bcc.n	8001434 <sendFileCommand+0x58>
    {
        xQueueSendToBack(fileSendQueue,&command,FILE_SEND_TIMEOUT);
 80013fc:	6820      	ldr	r0, [r4, #0]
 80013fe:	f10d 0107 	add.w	r1, sp, #7
 8001402:	22c8      	movs	r2, #200	; 0xc8
 8001404:	2300      	movs	r3, #0
 8001406:	f004 fc23 	bl	8005c50 <xQueueGenericSend>
        xQueueSendToBack(fileSendQueue,&totalLength,FILE_SEND_TIMEOUT);
 800140a:	6820      	ldr	r0, [r4, #0]
 800140c:	f10d 010f 	add.w	r1, sp, #15
 8001410:	22c8      	movs	r2, #200	; 0xc8
 8001412:	2300      	movs	r3, #0
 8001414:	f004 fc1c 	bl	8005c50 <xQueueGenericSend>
 8001418:	4634      	mov	r4, r6
        for (i=0; i<length; i++)
 800141a:	1ba0      	subs	r0, r4, r6
 800141c:	b2c2      	uxtb	r2, r0
 800141e:	42aa      	cmp	r2, r5
 8001420:	d208      	bcs.n	8001434 <sendFileCommand+0x58>
            xQueueSendToBack(fileSendQueue,parameters+i,FILE_SEND_TIMEOUT);
 8001422:	4b05      	ldr	r3, [pc, #20]	; (8001438 <sendFileCommand+0x5c>)
 8001424:	4621      	mov	r1, r4
 8001426:	6818      	ldr	r0, [r3, #0]
 8001428:	22c8      	movs	r2, #200	; 0xc8
 800142a:	2300      	movs	r3, #0
 800142c:	f004 fc10 	bl	8005c50 <xQueueGenericSend>
 8001430:	3401      	adds	r4, #1
 8001432:	e7f2      	b.n	800141a <sendFileCommand+0x3e>
    }
}
 8001434:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
 8001436:	bf00      	nop
 8001438:	200007e4 	.word	0x200007e4

0800143c <recordString>:
@param int32_t param1: first parameter.
@param int32_t param2: second parameter.
*/

uint8_t recordString(char* ident, char* string)
{
 800143c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint8_t fileStatus = FR_DENIED;
 8001440:	2307      	movs	r3, #7
@param int32_t param1: first parameter.
@param int32_t param2: second parameter.
*/

uint8_t recordString(char* ident, char* string)
{
 8001442:	b096      	sub	sp, #88	; 0x58
 8001444:	4680      	mov	r8, r0
 8001446:	460f      	mov	r7, r1
    uint8_t fileStatus = FR_DENIED;
 8001448:	f88d 3007 	strb.w	r3, [sp, #7]
    if (isRecording() && (writeFileHandle < 0x7F))
 800144c:	f001 fda2 	bl	8002f94 <isRecording>
 8001450:	2800      	cmp	r0, #0
 8001452:	d03b      	beq.n	80014cc <recordString+0x90>
 8001454:	4e20      	ldr	r6, [pc, #128]	; (80014d8 <recordString+0x9c>)
 8001456:	7830      	ldrb	r0, [r6, #0]
 8001458:	287e      	cmp	r0, #126	; 0x7e
 800145a:	d837      	bhi.n	80014cc <recordString+0x90>
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
 800145c:	4d1f      	ldr	r5, [pc, #124]	; (80014dc <recordString+0xa0>)
 800145e:	2100      	movs	r1, #0
 8001460:	6828      	ldr	r0, [r5, #0]
 8001462:	22c8      	movs	r2, #200	; 0xc8
 8001464:	460b      	mov	r3, r1
 8001466:	f004 fc8a 	bl	8005d7e <xQueueGenericReceive>
 800146a:	2800      	cmp	r0, #0
 800146c:	d02e      	beq.n	80014cc <recordString+0x90>
        {
            char record[80];
            record[0] = '0';
 800146e:	2130      	movs	r1, #48	; 0x30
            record[1] = 0;
 8001470:	2400      	movs	r4, #0
    if (isRecording() && (writeFileHandle < 0x7F))
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
        {
            char record[80];
            record[0] = '0';
 8001472:	f88d 1008 	strb.w	r1, [sp, #8]
            record[1] = 0;
            stringAppend(record, ident);
 8001476:	a802      	add	r0, sp, #8
 8001478:	4641      	mov	r1, r8
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
        {
            char record[80];
            record[0] = '0';
            record[1] = 0;
 800147a:	f88d 4009 	strb.w	r4, [sp, #9]
            stringAppend(record, ident);
 800147e:	f001 fb25 	bl	8002acc <stringAppend>
            stringAppend(record, ",");
 8001482:	a802      	add	r0, sp, #8
 8001484:	4916      	ldr	r1, [pc, #88]	; (80014e0 <recordString+0xa4>)
 8001486:	f001 fb21 	bl	8002acc <stringAppend>
            stringAppend(record, string);
 800148a:	a802      	add	r0, sp, #8
 800148c:	4639      	mov	r1, r7
 800148e:	f001 fb1d 	bl	8002acc <stringAppend>
            stringAppend(record, "\r\n");
 8001492:	4914      	ldr	r1, [pc, #80]	; (80014e4 <recordString+0xa8>)
 8001494:	a802      	add	r0, sp, #8
 8001496:	f001 fb19 	bl	8002acc <stringAppend>
            uint8_t length = stringLength(record);
 800149a:	a802      	add	r0, sp, #8
 800149c:	f001 fb0e 	bl	8002abc <stringLength>
            record[0] = writeFileHandle;
 80014a0:	7832      	ldrb	r2, [r6, #0]
            sendFileCommand('P',length, (uint8_t*)record);
 80014a2:	b2c1      	uxtb	r1, r0
            stringAppend(record, ident);
            stringAppend(record, ",");
            stringAppend(record, string);
            stringAppend(record, "\r\n");
            uint8_t length = stringLength(record);
            record[0] = writeFileHandle;
 80014a4:	f88d 2008 	strb.w	r2, [sp, #8]
            sendFileCommand('P',length, (uint8_t*)record);
 80014a8:	2050      	movs	r0, #80	; 0x50
 80014aa:	aa02      	add	r2, sp, #8
 80014ac:	f7ff ff96 	bl	80013dc <sendFileCommand>
            xQueueReceive(fileReceiveQueue,&fileStatus,FILE_SEND_TIMEOUT);
 80014b0:	4b0d      	ldr	r3, [pc, #52]	; (80014e8 <recordString+0xac>)
 80014b2:	f10d 0107 	add.w	r1, sp, #7
 80014b6:	6818      	ldr	r0, [r3, #0]
 80014b8:	22c8      	movs	r2, #200	; 0xc8
 80014ba:	4623      	mov	r3, r4
 80014bc:	f004 fc5f 	bl	8005d7e <xQueueGenericReceive>
            xSemaphoreGive(fileSendSemaphore);
 80014c0:	6828      	ldr	r0, [r5, #0]
 80014c2:	4621      	mov	r1, r4
 80014c4:	4622      	mov	r2, r4
 80014c6:	4623      	mov	r3, r4
 80014c8:	f004 fbc2 	bl	8005c50 <xQueueGenericSend>
        }
    }
    return fileStatus;
}
 80014cc:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80014d0:	b016      	add	sp, #88	; 0x58
 80014d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80014d6:	bf00      	nop
 80014d8:	2000081c 	.word	0x2000081c
 80014dc:	20000784 	.word	0x20000784
 80014e0:	0800751d 	.word	0x0800751d
 80014e4:	080074c5 	.word	0x080074c5
 80014e8:	2000078c 	.word	0x2000078c

080014ec <recordDual>:
@param int32_t param2: second parameter.
@returns uint8_t file status.
*/

uint8_t recordDual(char* ident, int32_t param1, int32_t param2)
{
 80014ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80014f0:	b09b      	sub	sp, #108	; 0x6c
 80014f2:	4681      	mov	r9, r0
 80014f4:	4688      	mov	r8, r1
 80014f6:	4617      	mov	r7, r2
    uint8_t fileStatus;
    if (isRecording() && (writeFileHandle < 0x7F))
 80014f8:	f001 fd4c 	bl	8002f94 <isRecording>
 80014fc:	2800      	cmp	r0, #0
 80014fe:	d04b      	beq.n	8001598 <recordDual+0xac>
 8001500:	4e28      	ldr	r6, [pc, #160]	; (80015a4 <recordDual+0xb8>)
 8001502:	7833      	ldrb	r3, [r6, #0]
 8001504:	2b7e      	cmp	r3, #126	; 0x7e
 8001506:	d847      	bhi.n	8001598 <recordDual+0xac>
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
 8001508:	4d27      	ldr	r5, [pc, #156]	; (80015a8 <recordDual+0xbc>)
 800150a:	2100      	movs	r1, #0
 800150c:	6828      	ldr	r0, [r5, #0]
 800150e:	22c8      	movs	r2, #200	; 0xc8
 8001510:	460b      	mov	r3, r1
 8001512:	f004 fc34 	bl	8005d7e <xQueueGenericReceive>
 8001516:	2800      	cmp	r0, #0
 8001518:	d03e      	beq.n	8001598 <recordDual+0xac>
        {
            char record[80];
            record[0] = '0';
 800151a:	2030      	movs	r0, #48	; 0x30
            record[1] = 0;
 800151c:	2400      	movs	r4, #0
    if (isRecording() && (writeFileHandle < 0x7F))
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
        {
            char record[80];
            record[0] = '0';
 800151e:	f88d 0018 	strb.w	r0, [sp, #24]
            record[1] = 0;
            stringAppend(record, ident);
 8001522:	4649      	mov	r1, r9
 8001524:	a806      	add	r0, sp, #24
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
        {
            char record[80];
            record[0] = '0';
            record[1] = 0;
 8001526:	f88d 4019 	strb.w	r4, [sp, #25]
            stringAppend(record, ident);
 800152a:	f001 facf 	bl	8002acc <stringAppend>
            stringAppend(record, ",");
 800152e:	a806      	add	r0, sp, #24
 8001530:	491e      	ldr	r1, [pc, #120]	; (80015ac <recordDual+0xc0>)
 8001532:	f001 facb 	bl	8002acc <stringAppend>
            char buffer[20];
            intToAscii(param1, buffer);
 8001536:	4640      	mov	r0, r8
 8001538:	a901      	add	r1, sp, #4
 800153a:	f001 fa81 	bl	8002a40 <intToAscii>
            stringAppend(record, buffer);
 800153e:	a806      	add	r0, sp, #24
 8001540:	a901      	add	r1, sp, #4
 8001542:	f001 fac3 	bl	8002acc <stringAppend>
            stringAppend(record, ",");
 8001546:	a806      	add	r0, sp, #24
 8001548:	4918      	ldr	r1, [pc, #96]	; (80015ac <recordDual+0xc0>)
 800154a:	f001 fabf 	bl	8002acc <stringAppend>
            intToAscii(param2, buffer);
 800154e:	4638      	mov	r0, r7
 8001550:	a901      	add	r1, sp, #4
 8001552:	f001 fa75 	bl	8002a40 <intToAscii>
            stringAppend(record, buffer);
 8001556:	a806      	add	r0, sp, #24
 8001558:	a901      	add	r1, sp, #4
 800155a:	f001 fab7 	bl	8002acc <stringAppend>
            stringAppend(record, "\r\n");
 800155e:	4914      	ldr	r1, [pc, #80]	; (80015b0 <recordDual+0xc4>)
 8001560:	a806      	add	r0, sp, #24
 8001562:	f001 fab3 	bl	8002acc <stringAppend>
            uint8_t length = stringLength(record);
 8001566:	a806      	add	r0, sp, #24
 8001568:	f001 faa8 	bl	8002abc <stringLength>
            record[0] = writeFileHandle;
 800156c:	7831      	ldrb	r1, [r6, #0]
            sendFileCommand('P',length, (uint8_t*)record);
 800156e:	aa06      	add	r2, sp, #24
            stringAppend(record, ",");
            intToAscii(param2, buffer);
            stringAppend(record, buffer);
            stringAppend(record, "\r\n");
            uint8_t length = stringLength(record);
            record[0] = writeFileHandle;
 8001570:	f88d 1018 	strb.w	r1, [sp, #24]
            sendFileCommand('P',length, (uint8_t*)record);
 8001574:	b2c1      	uxtb	r1, r0
 8001576:	2050      	movs	r0, #80	; 0x50
 8001578:	f7ff ff30 	bl	80013dc <sendFileCommand>
            xQueueReceive(fileReceiveQueue,&fileStatus,FILE_SEND_TIMEOUT);
 800157c:	4a0d      	ldr	r2, [pc, #52]	; (80015b4 <recordDual+0xc8>)
 800157e:	f10d 0103 	add.w	r1, sp, #3
 8001582:	6810      	ldr	r0, [r2, #0]
 8001584:	4623      	mov	r3, r4
 8001586:	22c8      	movs	r2, #200	; 0xc8
 8001588:	f004 fbf9 	bl	8005d7e <xQueueGenericReceive>
            xSemaphoreGive(fileSendSemaphore);
 800158c:	6828      	ldr	r0, [r5, #0]
 800158e:	4621      	mov	r1, r4
 8001590:	4622      	mov	r2, r4
 8001592:	4623      	mov	r3, r4
 8001594:	f004 fb5c 	bl	8005c50 <xQueueGenericSend>
        }
    }
    return fileStatus;
}
 8001598:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800159c:	b01b      	add	sp, #108	; 0x6c
 800159e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80015a2:	bf00      	nop
 80015a4:	2000081c 	.word	0x2000081c
 80015a8:	20000784 	.word	0x20000784
 80015ac:	0800751d 	.word	0x0800751d
 80015b0:	080074c5 	.word	0x080074c5
 80015b4:	2000078c 	.word	0x2000078c

080015b8 <recordSingle>:
@param int32_t param1: first parameter.
@param int32_t param2: second parameter.
*/

uint8_t recordSingle(char* ident, int32_t param1)
{
 80015b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80015bc:	b09a      	sub	sp, #104	; 0x68
 80015be:	4680      	mov	r8, r0
 80015c0:	460f      	mov	r7, r1
    uint8_t fileStatus;
    if (isRecording() && (writeFileHandle < 0x7F))
 80015c2:	f001 fce7 	bl	8002f94 <isRecording>
 80015c6:	2800      	cmp	r0, #0
 80015c8:	d03f      	beq.n	800164a <recordSingle+0x92>
 80015ca:	4e22      	ldr	r6, [pc, #136]	; (8001654 <recordSingle+0x9c>)
 80015cc:	7833      	ldrb	r3, [r6, #0]
 80015ce:	2b7e      	cmp	r3, #126	; 0x7e
 80015d0:	d83b      	bhi.n	800164a <recordSingle+0x92>
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
 80015d2:	4d21      	ldr	r5, [pc, #132]	; (8001658 <recordSingle+0xa0>)
 80015d4:	2100      	movs	r1, #0
 80015d6:	6828      	ldr	r0, [r5, #0]
 80015d8:	22c8      	movs	r2, #200	; 0xc8
 80015da:	460b      	mov	r3, r1
 80015dc:	f004 fbcf 	bl	8005d7e <xQueueGenericReceive>
 80015e0:	2800      	cmp	r0, #0
 80015e2:	d032      	beq.n	800164a <recordSingle+0x92>
        {
            char record[80];
            record[0] = '0';            /* dummy in case writeFileHandle is zero */
 80015e4:	2030      	movs	r0, #48	; 0x30
            record[1] = 0;
 80015e6:	2400      	movs	r4, #0
    if (isRecording() && (writeFileHandle < 0x7F))
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
        {
            char record[80];
            record[0] = '0';            /* dummy in case writeFileHandle is zero */
 80015e8:	f88d 0018 	strb.w	r0, [sp, #24]
            record[1] = 0;
            stringAppend(record, ident);
 80015ec:	4641      	mov	r1, r8
 80015ee:	a806      	add	r0, sp, #24
    {
        if (xSemaphoreTake(fileSendSemaphore,FILE_SEND_TIMEOUT))
        {
            char record[80];
            record[0] = '0';            /* dummy in case writeFileHandle is zero */
            record[1] = 0;
 80015f0:	f88d 4019 	strb.w	r4, [sp, #25]
            stringAppend(record, ident);
 80015f4:	f001 fa6a 	bl	8002acc <stringAppend>
            stringAppend(record, ",");
 80015f8:	a806      	add	r0, sp, #24
 80015fa:	4918      	ldr	r1, [pc, #96]	; (800165c <recordSingle+0xa4>)
 80015fc:	f001 fa66 	bl	8002acc <stringAppend>
            char buffer[20];
            intToAscii(param1, buffer);
 8001600:	4638      	mov	r0, r7
 8001602:	a901      	add	r1, sp, #4
 8001604:	f001 fa1c 	bl	8002a40 <intToAscii>
            stringAppend(record, buffer);
 8001608:	a806      	add	r0, sp, #24
 800160a:	a901      	add	r1, sp, #4
 800160c:	f001 fa5e 	bl	8002acc <stringAppend>
            stringAppend(record, "\r\n");
 8001610:	4913      	ldr	r1, [pc, #76]	; (8001660 <recordSingle+0xa8>)
 8001612:	a806      	add	r0, sp, #24
 8001614:	f001 fa5a 	bl	8002acc <stringAppend>
            uint8_t length = stringLength(record);
 8001618:	a806      	add	r0, sp, #24
 800161a:	f001 fa4f 	bl	8002abc <stringLength>
            record[0] = writeFileHandle;
 800161e:	7831      	ldrb	r1, [r6, #0]
            sendFileCommand('P',length, (uint8_t*)record);
 8001620:	aa06      	add	r2, sp, #24
            char buffer[20];
            intToAscii(param1, buffer);
            stringAppend(record, buffer);
            stringAppend(record, "\r\n");
            uint8_t length = stringLength(record);
            record[0] = writeFileHandle;
 8001622:	f88d 1018 	strb.w	r1, [sp, #24]
            sendFileCommand('P',length, (uint8_t*)record);
 8001626:	b2c1      	uxtb	r1, r0
 8001628:	2050      	movs	r0, #80	; 0x50
 800162a:	f7ff fed7 	bl	80013dc <sendFileCommand>
            xQueueReceive(fileReceiveQueue,&fileStatus,FILE_SEND_TIMEOUT);
 800162e:	4a0d      	ldr	r2, [pc, #52]	; (8001664 <recordSingle+0xac>)
 8001630:	f10d 0103 	add.w	r1, sp, #3
 8001634:	6810      	ldr	r0, [r2, #0]
 8001636:	4623      	mov	r3, r4
 8001638:	22c8      	movs	r2, #200	; 0xc8
 800163a:	f004 fba0 	bl	8005d7e <xQueueGenericReceive>
            xSemaphoreGive(fileSendSemaphore);
 800163e:	6828      	ldr	r0, [r5, #0]
 8001640:	4621      	mov	r1, r4
 8001642:	4622      	mov	r2, r4
 8001644:	4623      	mov	r3, r4
 8001646:	f004 fb03 	bl	8005c50 <xQueueGenericSend>
        }
    }
    return fileStatus;
}
 800164a:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800164e:	b01a      	add	sp, #104	; 0x68
 8001650:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001654:	2000081c 	.word	0x2000081c
 8001658:	20000784 	.word	0x20000784
 800165c:	0800751d 	.word	0x0800751d
 8001660:	080074c5 	.word	0x080074c5
 8001664:	2000078c 	.word	0x2000078c

08001668 <computeSoC>:
    int32_t soc;
    uint32_t v100, v50, v25;
    if (type == wetT) v100 = 3242;
    else v100 = 3280;
/* Difference between top temperature 48.9C and ambient, times 64. */
    uint32_t tDiff = (12518-temperature) >> 2;
 8001668:	f5c1 5143 	rsb	r1, r1, #12480	; 0x30c0
 800166c:	f101 0326 	add.w	r3, r1, #38	; 0x26
 8001670:	089b      	lsrs	r3, r3, #2
/* Correction factor to apply to measured voltages, times 65536. */
    uint32_t vFactor = 65536-((42*tDiff*tDiff) >> 20);
 8001672:	435b      	muls	r3, r3
 8001674:	212a      	movs	r1, #42	; 0x2a
 8001676:	434b      	muls	r3, r1
 8001678:	0d1b      	lsrs	r3, r3, #20
 800167a:	f5c3 3180 	rsb	r1, r3, #65536	; 0x10000
/* Open circuit voltage referred to 48.9C */
    uint32_t ocv = (voltage*65536)/vFactor;
 800167e:	0400      	lsls	r0, r0, #16
@param uint32_t temperature. Temperature degrees C times 256
@return int16_t Percentage State of Charge times 256.
*/

static int16_t computeSoC(uint32_t voltage, uint32_t temperature, battery_Type type)
{
 8001680:	b510      	push	{r4, lr}
    int32_t soc;
    uint32_t v100, v50, v25;
    if (type == wetT) v100 = 3242;
 8001682:	f640 44aa 	movw	r4, #3242	; 0xcaa
 8001686:	2a00      	cmp	r2, #0
 8001688:	bf18      	it	ne
 800168a:	f44f 644d 	movne.w	r4, #3280	; 0xcd0
/* Difference between top temperature 48.9C and ambient, times 64. */
    uint32_t tDiff = (12518-temperature) >> 2;
/* Correction factor to apply to measured voltages, times 65536. */
    uint32_t vFactor = 65536-((42*tDiff*tDiff) >> 20);
/* Open circuit voltage referred to 48.9C */
    uint32_t ocv = (voltage*65536)/vFactor;
 800168e:	fbb0 f0f1 	udiv	r0, r0, r1
/* SoC for Wet cell and part of Gel cell */
    soc = (100*(65536 - 320*(v100-ocv))) >> 8;
 8001692:	1a23      	subs	r3, r4, r0
 8001694:	f44f 41fa 	mov.w	r1, #32000	; 0x7d00
 8001698:	434b      	muls	r3, r1
 800169a:	f5c3 03c8 	rsb	r3, r3, #6553600	; 0x640000
 800169e:	0a1b      	lsrs	r3, r3, #8
    if (type == gelT)
 80016a0:	2a01      	cmp	r2, #1
 80016a2:	d118      	bne.n	80016d6 <computeSoC+0x6e>
    {
        v50 = 3178;
        if (ocv < v50)
 80016a4:	f640 4269 	movw	r2, #3177	; 0xc69
 80016a8:	4290      	cmp	r0, r2
 80016aa:	d814      	bhi.n	80016d6 <computeSoC+0x6e>
        {
            v25 = 3075;
            if (ocv > v25) soc = (100*(65536 - 640*(v50-ocv))) >> 8;
 80016ac:	f640 4303 	movw	r3, #3075	; 0xc03
 80016b0:	4298      	cmp	r0, r3
 80016b2:	d909      	bls.n	80016c8 <computeSoC+0x60>
 80016b4:	f5c0 6246 	rsb	r2, r0, #3168	; 0xc60
 80016b8:	320a      	adds	r2, #10
 80016ba:	f44f 417a 	mov.w	r1, #64000	; 0xfa00
 80016be:	4351      	muls	r1, r2
 80016c0:	f5c1 03c8 	rsb	r3, r1, #6553600	; 0x640000
 80016c4:	0a18      	lsrs	r0, r3, #8
 80016c6:	e00c      	b.n	80016e2 <computeSoC+0x7a>
            else soc = (100*(65536 - 320*(v25-ocv))) >> 8;
 80016c8:	f5c0 6040 	rsb	r0, r0, #3072	; 0xc00
 80016cc:	1cc2      	adds	r2, r0, #3
 80016ce:	434a      	muls	r2, r1
 80016d0:	f5c2 01c8 	rsb	r1, r2, #6553600	; 0x640000
 80016d4:	0a0b      	lsrs	r3, r1, #8
        }
    }
    if (soc > 100*256) soc = 100*256;
 80016d6:	f5b3 4fc8 	cmp.w	r3, #25600	; 0x6400
 80016da:	bfb4      	ite	lt
 80016dc:	4618      	movlt	r0, r3
 80016de:	f44f 40c8 	movge.w	r0, #25600	; 0x6400
    return soc;
}
 80016e2:	b200      	sxth	r0, r0
 80016e4:	bd10      	pop	{r4, pc}
	...

080016e8 <prvMonitorTask>:
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
{
 80016e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

*/

static void initGlobals(void)
{
    calibrate = false;
 80016ec:	4b4f      	ldr	r3, [pc, #316]	; (800182c <prvMonitorTask+0x144>)
 80016ee:	2500      	movs	r5, #0
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
{
 80016f0:	b09b      	sub	sp, #108	; 0x6c

*/

static void initGlobals(void)
{
    calibrate = false;
 80016f2:	701d      	strb	r5, [r3, #0]
 80016f4:	462c      	mov	r4, r5
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
    {
/* Determine capacity */
        batterySoC[i] = computeSoC(getBatteryVoltage(i),getTemperature(),
 80016f6:	4620      	mov	r0, r4
 80016f8:	f001 fdd2 	bl	80032a0 <getBatteryVoltage>
 80016fc:	4607      	mov	r7, r0
 80016fe:	f001 fdfb 	bl	80032f8 <getTemperature>
 8001702:	4606      	mov	r6, r0
 8001704:	4620      	mov	r0, r4
 8001706:	f001 fbc9 	bl	8002e9c <getBatteryType>
 800170a:	4631      	mov	r1, r6
 800170c:	4602      	mov	r2, r0
 800170e:	4638      	mov	r0, r7
 8001710:	f7ff ffaa 	bl	8001668 <computeSoC>
 8001714:	4f46      	ldr	r7, [pc, #280]	; (8001830 <prvMonitorTask+0x148>)
                                   getBatteryType(i));
        batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
        batteryCurrentSteady[i] = 0;
 8001716:	2600      	movs	r6, #0
    calibrate = false;
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
    {
/* Determine capacity */
        batterySoC[i] = computeSoC(getBatteryVoltage(i),getTemperature(),
 8001718:	5378      	strh	r0, [r7, r5]
                                   getBatteryType(i));
        batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
 800171a:	4620      	mov	r0, r4
 800171c:	f001 fbc4 	bl	8002ea8 <getBatteryCapacity>
 8001720:	2124      	movs	r1, #36	; 0x24
 8001722:	4348      	muls	r0, r1
 8001724:	5bea      	ldrh	r2, [r5, r7]
 8001726:	4b43      	ldr	r3, [pc, #268]	; (8001834 <prvMonitorTask+0x14c>)
 8001728:	fb02 f000 	mul.w	r0, r2, r0
        batteryCurrentSteady[i] = 0;
        batteryIsolationTime[i] = 0;
 800172c:	4a42      	ldr	r2, [pc, #264]	; (8001838 <prvMonitorTask+0x150>)
    for (i=0; i<NUM_BATS; i++)
    {
/* Determine capacity */
        batterySoC[i] = computeSoC(getBatteryVoltage(i),getTemperature(),
                                   getBatteryType(i));
        batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
 800172e:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
        batteryCurrentSteady[i] = 0;
        batteryIsolationTime[i] = 0;
/* Start with all batteries isolated */
        batteryOpState[i] = isolatedO;
 8001732:	4b42      	ldr	r3, [pc, #264]	; (800183c <prvMonitorTask+0x154>)
 8001734:	2002      	movs	r0, #2
    {
/* Determine capacity */
        batterySoC[i] = computeSoC(getBatteryVoltage(i),getTemperature(),
                                   getBatteryType(i));
        batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
        batteryCurrentSteady[i] = 0;
 8001736:	4942      	ldr	r1, [pc, #264]	; (8001840 <prvMonitorTask+0x158>)
        batteryIsolationTime[i] = 0;
 8001738:	f842 6024 	str.w	r6, [r2, r4, lsl #2]
/* Start with all batteries isolated */
        batteryOpState[i] = isolatedO;
 800173c:	54e0      	strb	r0, [r4, r3]
 800173e:	3401      	adds	r4, #1

static void initGlobals(void)
{
    calibrate = false;
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
 8001740:	2c03      	cmp	r4, #3
    {
/* Determine capacity */
        batterySoC[i] = computeSoC(getBatteryVoltage(i),getTemperature(),
                                   getBatteryType(i));
        batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
        batteryCurrentSteady[i] = 0;
 8001742:	526e      	strh	r6, [r5, r1]
 8001744:	4405      	add	r5, r0

static void initGlobals(void)
{
    calibrate = false;
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
 8001746:	d1d6      	bne.n	80016f6 <prvMonitorTask+0xe>
        batteryCurrentSteady[i] = 0;
        batteryIsolationTime[i] = 0;
/* Start with all batteries isolated */
        batteryOpState[i] = isolatedO;
    }
    batteryUnderLoad = 0;
 8001748:	493e      	ldr	r1, [pc, #248]	; (8001844 <prvMonitorTask+0x15c>)
    batteryUnderCharge = 0;
 800174a:	4f3f      	ldr	r7, [pc, #252]	; (8001848 <prvMonitorTask+0x160>)
        batteryCurrentSteady[i] = 0;
        batteryIsolationTime[i] = 0;
/* Start with all batteries isolated */
        batteryOpState[i] = isolatedO;
    }
    batteryUnderLoad = 0;
 800174c:	700e      	strb	r6, [r1, #0]
    batteryUnderCharge = 0;
 800174e:	703e      	strb	r6, [r7, #0]
 8001750:	4634      	mov	r4, r6
/* These will be in FLASH, or set to zero if not */
    for (i=0; i<NUM_IFS; i++) currentOffsets.data[i] = getCurrentOffset(i);
 8001752:	b2e0      	uxtb	r0, r4
 8001754:	f001 fbf0 	bl	8002f38 <getCurrentOffset>
 8001758:	4e3c      	ldr	r6, [pc, #240]	; (800184c <prvMonitorTask+0x164>)
 800175a:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
 800175e:	3401      	adds	r4, #1
 8001760:	2c06      	cmp	r4, #6
 8001762:	d1f6      	bne.n	8001752 <prvMonitorTask+0x6a>
    initGlobals();

    uint16_t decisionStatus = 0;    

/* Short delay to allow measurement task to produce results */
	vTaskDelay(MONITOR_STARTUP_DELAY );
 8001764:	2064      	movs	r0, #100	; 0x64
 8001766:	f004 f80b 	bl	8005780 <vTaskDelay>
 800176a:	2400      	movs	r4, #0

/* Determine SoC and capacity to start. */
    uint8_t i;
    for (i=0; i<NUM_BATS; i++)
    {
        batterySoC[i] = computeSoC(getBatteryVoltage(i),getTemperature(),
 800176c:	4620      	mov	r0, r4
 800176e:	f001 fd97 	bl	80032a0 <getBatteryVoltage>
 8001772:	4607      	mov	r7, r0
 8001774:	f001 fdc0 	bl	80032f8 <getTemperature>
 8001778:	4605      	mov	r5, r0
 800177a:	4620      	mov	r0, r4
 800177c:	f001 fb8e 	bl	8002e9c <getBatteryType>
 8001780:	4629      	mov	r1, r5
 8001782:	4602      	mov	r2, r0
 8001784:	4638      	mov	r0, r7
 8001786:	f7ff ff6f 	bl	8001668 <computeSoC>
 800178a:	4e29      	ldr	r6, [pc, #164]	; (8001830 <prvMonitorTask+0x148>)
 800178c:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
                                   getBatteryType(i));
        batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
 8001790:	4620      	mov	r0, r4
 8001792:	f001 fb89 	bl	8002ea8 <getBatteryCapacity>
 8001796:	2224      	movs	r2, #36	; 0x24
 8001798:	4350      	muls	r0, r2
 800179a:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
 800179e:	4925      	ldr	r1, [pc, #148]	; (8001834 <prvMonitorTask+0x14c>)
 80017a0:	fb03 f000 	mul.w	r0, r3, r0
 80017a4:	f841 0024 	str.w	r0, [r1, r4, lsl #2]
 80017a8:	3401      	adds	r4, #1
/* Short delay to allow measurement task to produce results */
	vTaskDelay(MONITOR_STARTUP_DELAY );

/* Determine SoC and capacity to start. */
    uint8_t i;
    for (i=0; i<NUM_BATS; i++)
 80017aa:	2c03      	cmp	r4, #3
 80017ac:	d1de      	bne.n	800176c <prvMonitorTask+0x84>
 80017ae:	2400      	movs	r4, #0
/* Count the number of batteries present. */
        uint8_t numBats = 0;
        uint8_t i;
        for (i=0; i<NUM_BATS; i++)
        {
            if (batteryOpState[i] != missingO) numBats++;
 80017b0:	4f22      	ldr	r7, [pc, #136]	; (800183c <prvMonitorTask+0x154>)
 80017b2:	783d      	ldrb	r5, [r7, #0]
 80017b4:	787a      	ldrb	r2, [r7, #1]

/* Main loop */
	while (1)
	{
/* Count the number of batteries present. */
        uint8_t numBats = 0;
 80017b6:	1eee      	subs	r6, r5, #3
 80017b8:	bf18      	it	ne
 80017ba:	2601      	movne	r6, #1
        uint8_t i;
        for (i=0; i<NUM_BATS; i++)
        {
            if (batteryOpState[i] != missingO) numBats++;
 80017bc:	2a03      	cmp	r2, #3
 80017be:	d001      	beq.n	80017c4 <prvMonitorTask+0xdc>
 80017c0:	3601      	adds	r6, #1
 80017c2:	b2f6      	uxtb	r6, r6
 80017c4:	78bb      	ldrb	r3, [r7, #2]
 80017c6:	2b03      	cmp	r3, #3
 80017c8:	d001      	beq.n	80017ce <prvMonitorTask+0xe6>
 80017ca:	1c70      	adds	r0, r6, #1
 80017cc:	b2c6      	uxtb	r6, r0
/*------------- CALIBRATION -----------------------*/
/* Perform a calibration sequence to zero the currents (see docs).
Also the State of Charge is estimated from the Open Circuit Voltages, so the
system should have been left in a quiescent state for at least an hour. */

        if (calibrate)
 80017ce:	4917      	ldr	r1, [pc, #92]	; (800182c <prvMonitorTask+0x144>)
 80017d0:	780f      	ldrb	r7, [r1, #0]
 80017d2:	2f00      	cmp	r7, #0
 80017d4:	f000 80e8 	beq.w	80019a8 <prvMonitorTask+0x2c0>
        {
/* Keep aside to restore after calibration. */
            uint8_t switchSettings = getSwitchControlBits();
 80017d8:	f000 feee 	bl	80025b8 <getSwitchControlBits>
            int16_t results[NUM_TESTS][NUM_IFS];    /* result for all 7 tests */
            uint8_t test;
            uint8_t i;

/* Zero the offsets. */
            for (i=0; i<NUM_IFS; i++) currentOffsets.data[i] = 0;
 80017dc:	4d1b      	ldr	r5, [pc, #108]	; (800184c <prvMonitorTask+0x164>)
 80017de:	2200      	movs	r2, #0
 80017e0:	802a      	strh	r2, [r5, #0]
 80017e2:	806a      	strh	r2, [r5, #2]
 80017e4:	80aa      	strh	r2, [r5, #4]
 80017e6:	80ea      	strh	r2, [r5, #6]
 80017e8:	812a      	strh	r2, [r5, #8]
 80017ea:	816a      	strh	r2, [r5, #10]
system should have been left in a quiescent state for at least an hour. */

        if (calibrate)
        {
/* Keep aside to restore after calibration. */
            uint8_t switchSettings = getSwitchControlBits();
 80017ec:	4680      	mov	r8, r0
            int16_t results[NUM_TESTS][NUM_IFS];    /* result for all 7 tests */
            uint8_t test;
            uint8_t i;

/* Zero the offsets. */
            for (i=0; i<NUM_IFS; i++) currentOffsets.data[i] = 0;
 80017ee:	4615      	mov	r5, r2
 80017f0:	b2ef      	uxtb	r7, r5

/* Set switches and collect the results */
            for (test=0; test<NUM_TESTS ; test++)
            {
/* Run test only if the needed battery is present (last test unconditional). */
                if ((test < NUM_TESTS-1) &&
 80017f2:	2f06      	cmp	r7, #6
 80017f4:	d04a      	beq.n	800188c <prvMonitorTask+0x1a4>
                    (batteryOpState[test % NUM_BATS] != missingO))
 80017f6:	2303      	movs	r3, #3
 80017f8:	fbb7 f0f3 	udiv	r0, r7, r3
 80017fc:	fb03 7110 	mls	r1, r3, r0, r7

/* Set switches and collect the results */
            for (test=0; test<NUM_TESTS ; test++)
            {
/* Run test only if the needed battery is present (last test unconditional). */
                if ((test < NUM_TESTS-1) &&
 8001800:	4a0e      	ldr	r2, [pc, #56]	; (800183c <prvMonitorTask+0x154>)
                    (batteryOpState[test % NUM_BATS] != missingO))
 8001802:	b2cb      	uxtb	r3, r1

/* Set switches and collect the results */
            for (test=0; test<NUM_TESTS ; test++)
            {
/* Run test only if the needed battery is present (last test unconditional). */
                if ((test < NUM_TESTS-1) &&
 8001804:	5cd0      	ldrb	r0, [r2, r3]
 8001806:	2803      	cmp	r0, #3
 8001808:	d040      	beq.n	800188c <prvMonitorTask+0x1a4>
                    (batteryOpState[test % NUM_BATS] != missingO))
                {
/* First turn off all switches */
                    for (i=0; i<NUM_BATS; i++) setSwitch(0,i);
 800180a:	2000      	movs	r0, #0
 800180c:	4601      	mov	r1, r0
 800180e:	f000 feaf 	bl	8002570 <setSwitch>
 8001812:	2000      	movs	r0, #0
 8001814:	2101      	movs	r1, #1
 8001816:	f000 feab 	bl	8002570 <setSwitch>
 800181a:	2000      	movs	r0, #0
 800181c:	2102      	movs	r1, #2
 800181e:	f000 fea7 	bl	8002570 <setSwitch>
/* Connect load 2 to each battery in turn. */
                    if (test < NUM_BATS) setSwitch(test,1);
 8001822:	2f02      	cmp	r7, #2
 8001824:	d814      	bhi.n	8001850 <prvMonitorTask+0x168>
 8001826:	4638      	mov	r0, r7
 8001828:	2101      	movs	r1, #1
 800182a:	e014      	b.n	8001856 <prvMonitorTask+0x16e>
 800182c:	20000842 	.word	0x20000842
 8001830:	20000838 	.word	0x20000838
 8001834:	2000082c 	.word	0x2000082c
 8001838:	20000820 	.word	0x20000820
 800183c:	2000083e 	.word	0x2000083e
 8001840:	20000844 	.word	0x20000844
 8001844:	20000843 	.word	0x20000843
 8001848:	2000084a 	.word	0x2000084a
 800184c:	2000084c 	.word	0x2000084c
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 8001850:	3f03      	subs	r7, #3
                    for (i=0; i<NUM_BATS; i++) setSwitch(0,i);
/* Connect load 2 to each battery in turn. */
                    if (test < NUM_BATS) setSwitch(test,1);
/* Then connect load 1 to each battery in turn. Last test is all
switches off to allow the panel to be measured. */
                    else if (test < NUM_TESTS-1) setSwitch(test-NUM_BATS,0);
 8001852:	b2f8      	uxtb	r0, r7
 8001854:	2100      	movs	r1, #0
 8001856:	f000 fe8b 	bl	8002570 <setSwitch>
/* Delay a few seconds to let the measurements settle. Current should settle
quickly but terminal voltage may take some time, which could slightly affect
some currents. */
	                vTaskDelay(getCalibrationDelay());
 800185a:	f001 fb95 	bl	8002f88 <getCalibrationDelay>
 800185e:	f003 ff8f 	bl	8005780 <vTaskDelay>
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 8001862:	f04f 090c 	mov.w	r9, #12
 8001866:	ab05      	add	r3, sp, #20
 8001868:	fb09 3905 	mla	r9, r9, r5, r3
/* Delay a few seconds to let the measurements settle. Current should settle
quickly but terminal voltage may take some time, which could slightly affect
some currents. */
	                vTaskDelay(getCalibrationDelay());
/* Reset watchdog counter */
                    monitorWatchdogCount = 0;
 800186c:	49c0      	ldr	r1, [pc, #768]	; (8001b70 <prvMonitorTask+0x488>)
 800186e:	2700      	movs	r7, #0
 8001870:	700f      	strb	r7, [r1, #0]
                    for (i=0; i<NUM_IFS; i++) results[test][i] = getCurrent(i);
 8001872:	4638      	mov	r0, r7
 8001874:	f001 fd3a 	bl	80032ec <getCurrent>
 8001878:	f829 0017 	strh.w	r0, [r9, r7, lsl #1]
 800187c:	3701      	adds	r7, #1
 800187e:	2f06      	cmp	r7, #6
 8001880:	d1f7      	bne.n	8001872 <prvMonitorTask+0x18a>
/* Send a progress update */
                    dataMessageSend("pQ",0,test);
 8001882:	48bc      	ldr	r0, [pc, #752]	; (8001b74 <prvMonitorTask+0x48c>)
 8001884:	2100      	movs	r1, #0
 8001886:	462a      	mov	r2, r5
 8001888:	f7fe fe34 	bl	80004f4 <dataMessageSend>
 800188c:	3501      	adds	r5, #1

/* Zero the offsets. */
            for (i=0; i<NUM_IFS; i++) currentOffsets.data[i] = 0;

/* Set switches and collect the results */
            for (test=0; test<NUM_TESTS ; test++)
 800188e:	2d07      	cmp	r5, #7
 8001890:	d1ae      	bne.n	80017f0 <prvMonitorTask+0x108>
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 8001892:	4bb9      	ldr	r3, [pc, #740]	; (8001b78 <prvMonitorTask+0x490>)
 8001894:	aa05      	add	r2, sp, #20
 8001896:	f103 070c 	add.w	r7, r3, #12

/* Estimate the offsets only when they are less than a threshold. Find the lowest
value for each interface. */
            for (i=0; i<NUM_IFS; i++)
            {
                currentOffsets.data[i] = OFFSET_START_VALUE;
 800189a:	2064      	movs	r0, #100	; 0x64
 800189c:	8058      	strh	r0, [r3, #2]
 800189e:	2100      	movs	r1, #0
/* Run through each test to find the minimum. This is the offset. */
                for (test=0; test<NUM_TESTS; test++)
                {
                    int16_t current = results[test][i];
 80018a0:	5a50      	ldrh	r0, [r2, r1]
/* Get the minimum if within the threshold. */
                    if (current > CALIBRATION_THRESHOLD)
 80018a2:	b205      	sxth	r5, r0
 80018a4:	f115 0f31 	cmn.w	r5, #49	; 0x31
 80018a8:	db04      	blt.n	80018b4 <prvMonitorTask+0x1cc>
                    {
                        if (current < currentOffsets.data[i])
 80018aa:	f9b3 e002 	ldrsh.w	lr, [r3, #2]
 80018ae:	45ae      	cmp	lr, r5
                            currentOffsets.data[i] = current;
 80018b0:	bfc8      	it	gt
 80018b2:	8058      	strhgt	r0, [r3, #2]
 80018b4:	310c      	adds	r1, #12
value for each interface. */
            for (i=0; i<NUM_IFS; i++)
            {
                currentOffsets.data[i] = OFFSET_START_VALUE;
/* Run through each test to find the minimum. This is the offset. */
                for (test=0; test<NUM_TESTS; test++)
 80018b6:	2954      	cmp	r1, #84	; 0x54
 80018b8:	d1f2      	bne.n	80018a0 <prvMonitorTask+0x1b8>
                        if (current < currentOffsets.data[i])
                            currentOffsets.data[i] = current;
                    }
                }
/* If not changed, then the measurements were invalid, so set to zero. */
                if (currentOffsets.data[i] == OFFSET_START_VALUE)
 80018ba:	f9b3 1002 	ldrsh.w	r1, [r3, #2]
 80018be:	2964      	cmp	r1, #100	; 0x64
 80018c0:	d101      	bne.n	80018c6 <prvMonitorTask+0x1de>
                    currentOffsets.data[i] = 0;
 80018c2:	2000      	movs	r0, #0
 80018c4:	8058      	strh	r0, [r3, #2]
/* Remove offset from the results */
                for (test=0; test<NUM_TESTS; test++)
                {
                    results[test][i] -= currentOffsets.data[i];
 80018c6:	f833 5f02 	ldrh.w	r5, [r3, #2]!
 80018ca:	2100      	movs	r1, #0
 80018cc:	5a50      	ldrh	r0, [r2, r1]
 80018ce:	1b40      	subs	r0, r0, r5
 80018d0:	5250      	strh	r0, [r2, r1]
 80018d2:	310c      	adds	r1, #12
                }
/* If not changed, then the measurements were invalid, so set to zero. */
                if (currentOffsets.data[i] == OFFSET_START_VALUE)
                    currentOffsets.data[i] = 0;
/* Remove offset from the results */
                for (test=0; test<NUM_TESTS; test++)
 80018d4:	2954      	cmp	r1, #84	; 0x54
 80018d6:	d1f9      	bne.n	80018cc <prvMonitorTask+0x1e4>
 80018d8:	3202      	adds	r2, #2
                }
            }

/* Estimate the offsets only when they are less than a threshold. Find the lowest
value for each interface. */
            for (i=0; i<NUM_IFS; i++)
 80018da:	42bb      	cmp	r3, r7
 80018dc:	d1dd      	bne.n	800189a <prvMonitorTask+0x1b2>
 80018de:	2200      	movs	r2, #0
 80018e0:	f64f 719c 	movw	r1, #65436	; 0xff9c
                if (currentOffsets.data[i] == OFFSET_START_VALUE)
                    currentOffsets.data[i] = 0;
/* Remove offset from the results */
                for (test=0; test<NUM_TESTS; test++)
                {
                    results[test][i] -= currentOffsets.data[i];
 80018e4:	2300      	movs	r3, #0
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 80018e6:	af05      	add	r7, sp, #20
 80018e8:	19d5      	adds	r5, r2, r7
            {
                for (test=0; test<NUM_TESTS; test++)
                {
                    int16_t current = results[test][i];
/* Get the maximum if within threshold. */
                    if (current > CALIBRATION_THRESHOLD)
 80018ea:	5ee8      	ldrsh	r0, [r5, r3]
 80018ec:	f110 0f31 	cmn.w	r0, #49	; 0x31
 80018f0:	db04      	blt.n	80018fc <prvMonitorTask+0x214>
 80018f2:	b209      	sxth	r1, r1
 80018f4:	4288      	cmp	r0, r1
 80018f6:	bfa8      	it	ge
 80018f8:	4601      	movge	r1, r0
 80018fa:	b289      	uxth	r1, r1
 80018fc:	330c      	adds	r3, #12
/* Run through all tests and batteries to find the maximum. This is the
quiescent current */
            int16_t quiescentCurrent = -100;
            for (i=0; i<NUM_BATS; i++)
            {
                for (test=0; test<NUM_TESTS; test++)
 80018fe:	2b54      	cmp	r3, #84	; 0x54
 8001900:	d1f1      	bne.n	80018e6 <prvMonitorTask+0x1fe>
 8001902:	3202      	adds	r2, #2
                }        
            }
/* Run through all tests and batteries to find the maximum. This is the
quiescent current */
            int16_t quiescentCurrent = -100;
            for (i=0; i<NUM_BATS; i++)
 8001904:	2a06      	cmp	r2, #6
 8001906:	d1ed      	bne.n	80018e4 <prvMonitorTask+0x1fc>
                        if (current > quiescentCurrent)
                            quiescentCurrent = current;
                    }
                }
            }
            dataMessageSend("pQ",quiescentCurrent,7);
 8001908:	b209      	sxth	r1, r1
 800190a:	2207      	movs	r2, #7
 800190c:	4899      	ldr	r0, [pc, #612]	; (8001b74 <prvMonitorTask+0x48c>)
 800190e:	f7fe fdf1 	bl	80004f4 <dataMessageSend>

/* Restore switches and report back */
            setSwitchControlBits(switchSettings);
 8001912:	4640      	mov	r0, r8
 8001914:	f000 fea2 	bl	800265c <setSwitchControlBits>
            dataMessageSend("dS",switchSettings,0);
 8001918:	4898      	ldr	r0, [pc, #608]	; (8001b7c <prvMonitorTask+0x494>)
 800191a:	4641      	mov	r1, r8
 800191c:	2200      	movs	r2, #0
 800191e:	f7fe fde9 	bl	80004f4 <dataMessageSend>
 8001922:	2500      	movs	r5, #0
/* Compute the SoC from the OCV. Note the conditions for which OCV gives an
accurate estimate of SoC. */
            for (i=0; i<NUM_BATS; i++)
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8001924:	4628      	mov	r0, r5
 8001926:	f001 fcbb 	bl	80032a0 <getBatteryVoltage>
 800192a:	4682      	mov	sl, r0
                                           getTemperature(),getBatteryType(i));
 800192c:	f001 fce4 	bl	80032f8 <getTemperature>
 8001930:	4607      	mov	r7, r0
            dataMessageSend("dS",switchSettings,0);
/* Compute the SoC from the OCV. Note the conditions for which OCV gives an
accurate estimate of SoC. */
            for (i=0; i<NUM_BATS; i++)
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8001932:	4628      	mov	r0, r5
 8001934:	f001 fab2 	bl	8002e9c <getBatteryType>
 8001938:	4639      	mov	r1, r7
 800193a:	4602      	mov	r2, r0
 800193c:	4650      	mov	r0, sl
 800193e:	f7ff fe93 	bl	8001668 <computeSoC>
 8001942:	4f8f      	ldr	r7, [pc, #572]	; (8001b80 <prvMonitorTask+0x498>)
 8001944:	f827 0015 	strh.w	r0, [r7, r5, lsl #1]
                                           getTemperature(),getBatteryType(i));
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
 8001948:	4628      	mov	r0, r5
 800194a:	f001 faad 	bl	8002ea8 <getBatteryCapacity>
 800194e:	2324      	movs	r3, #36	; 0x24
 8001950:	4358      	muls	r0, r3
 8001952:	f837 1015 	ldrh.w	r1, [r7, r5, lsl #1]
 8001956:	4a8b      	ldr	r2, [pc, #556]	; (8001b84 <prvMonitorTask+0x49c>)
 8001958:	fb01 f000 	mul.w	r0, r1, r0
 800195c:	f842 0025 	str.w	r0, [r2, r5, lsl #2]
 8001960:	3501      	adds	r5, #1
/* Restore switches and report back */
            setSwitchControlBits(switchSettings);
            dataMessageSend("dS",switchSettings,0);
/* Compute the SoC from the OCV. Note the conditions for which OCV gives an
accurate estimate of SoC. */
            for (i=0; i<NUM_BATS; i++)
 8001962:	2d03      	cmp	r5, #3
 8001964:	d1de      	bne.n	8001924 <prvMonitorTask+0x23c>
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
            }
/* Zero counters, and reset battery states */
            for (i=0; i<NUM_BATS; i++)
            {
                batteryCurrentSteady[i] = 0;
 8001966:	4d88      	ldr	r5, [pc, #544]	; (8001b88 <prvMonitorTask+0x4a0>)
                batteryIsolationTime[i] = 0;
 8001968:	4888      	ldr	r0, [pc, #544]	; (8001b8c <prvMonitorTask+0x4a4>)
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
            }
/* Zero counters, and reset battery states */
            for (i=0; i<NUM_BATS; i++)
            {
                batteryCurrentSteady[i] = 0;
 800196a:	2300      	movs	r3, #0
                batteryIsolationTime[i] = 0;
                batteryOpState[i] = isolatedO;
 800196c:	4a88      	ldr	r2, [pc, #544]	; (8001b90 <prvMonitorTask+0x4a8>)
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
            }
/* Zero counters, and reset battery states */
            for (i=0; i<NUM_BATS; i++)
            {
                batteryCurrentSteady[i] = 0;
 800196e:	802b      	strh	r3, [r5, #0]
                batteryIsolationTime[i] = 0;
 8001970:	6003      	str	r3, [r0, #0]
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
            }
/* Zero counters, and reset battery states */
            for (i=0; i<NUM_BATS; i++)
            {
                batteryCurrentSteady[i] = 0;
 8001972:	806b      	strh	r3, [r5, #2]
                batteryIsolationTime[i] = 0;
 8001974:	6043      	str	r3, [r0, #4]
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
            }
/* Zero counters, and reset battery states */
            for (i=0; i<NUM_BATS; i++)
            {
                batteryCurrentSteady[i] = 0;
 8001976:	80ab      	strh	r3, [r5, #4]
                batteryIsolationTime[i] = 0;
 8001978:	6083      	str	r3, [r0, #8]
                batteryOpState[i] = isolatedO;
            }
            batteryUnderLoad = 0;
 800197a:	4d86      	ldr	r5, [pc, #536]	; (8001b94 <prvMonitorTask+0x4ac>)
            batteryUnderCharge = 0;
 800197c:	4886      	ldr	r0, [pc, #536]	; (8001b98 <prvMonitorTask+0x4b0>)
/* Zero counters, and reset battery states */
            for (i=0; i<NUM_BATS; i++)
            {
                batteryCurrentSteady[i] = 0;
                batteryIsolationTime[i] = 0;
                batteryOpState[i] = isolatedO;
 800197e:	2102      	movs	r1, #2
 8001980:	7011      	strb	r1, [r2, #0]
 8001982:	7051      	strb	r1, [r2, #1]
 8001984:	7091      	strb	r1, [r2, #2]
            }
            batteryUnderLoad = 0;
 8001986:	702b      	strb	r3, [r5, #0]
            batteryUnderCharge = 0;
 8001988:	7003      	strb	r3, [r0, #0]
 800198a:	461f      	mov	r7, r3
/* Write the offsets to FLASH */
            for (i=0; i<NUM_IFS; i++) setCurrentOffset(i,currentOffsets.data[i]);
 800198c:	4b83      	ldr	r3, [pc, #524]	; (8001b9c <prvMonitorTask+0x4b4>)
 800198e:	b2f8      	uxtb	r0, r7
 8001990:	f933 1017 	ldrsh.w	r1, [r3, r7, lsl #1]
 8001994:	3701      	adds	r7, #1
 8001996:	f001 fad7 	bl	8002f48 <setCurrentOffset>
 800199a:	2f06      	cmp	r7, #6
 800199c:	d1f6      	bne.n	800198c <prvMonitorTask+0x2a4>
            writeConfigBlock();
 800199e:	f001 f9f1 	bl	8002d84 <writeConfigBlock>
/* Ensure that calibration doesn't happen on the next cycle */
            calibrate = false;
 80019a2:	497f      	ldr	r1, [pc, #508]	; (8001ba0 <prvMonitorTask+0x4b8>)
 80019a4:	2200      	movs	r2, #0
 80019a6:	700a      	strb	r2, [r1, #0]
        }

/*------------- RECORD AND REPORT STATE --------------*/
/* Send off the current set of measurements */
        char id[4];
        id[0] = 'd';
 80019a8:	2564      	movs	r5, #100	; 0x64
        id[3] = 0;
 80019aa:	2700      	movs	r7, #0
/* Send out a time string */
        char timeString[20];
        putTimeToString(timeString);
 80019ac:	a805      	add	r0, sp, #20
        }

/*------------- RECORD AND REPORT STATE --------------*/
/* Send off the current set of measurements */
        char id[4];
        id[0] = 'd';
 80019ae:	f88d 5010 	strb.w	r5, [sp, #16]
        id[3] = 0;
 80019b2:	f88d 7013 	strb.w	r7, [sp, #19]
/* Send out a time string */
        char timeString[20];
        putTimeToString(timeString);
 80019b6:	f001 f8a7 	bl	8002b08 <putTimeToString>
        sendString("pH",timeString);
 80019ba:	487a      	ldr	r0, [pc, #488]	; (8001ba4 <prvMonitorTask+0x4bc>)
 80019bc:	a905      	add	r1, sp, #20
 80019be:	f7fe fd0b 	bl	80003d8 <sendString>
        recordString("pH",timeString);
 80019c2:	4878      	ldr	r0, [pc, #480]	; (8001ba4 <prvMonitorTask+0x4bc>)
 80019c4:	a905      	add	r1, sp, #20
 80019c6:	f7ff fd39 	bl	800143c <recordString>
 80019ca:	463d      	mov	r5, r7
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 80019cc:	f105 0031 	add.w	r0, r5, #49	; 0x31
        recordString("pH",timeString);
        for (i=0; i<NUM_BATS; i++)
        {
            id[2] = '1'+i;
/* Send out battery terminal measurements. */
            id[1] = 'B';
 80019d0:	2342      	movs	r3, #66	; 0x42
        putTimeToString(timeString);
        sendString("pH",timeString);
        recordString("pH",timeString);
        for (i=0; i<NUM_BATS; i++)
        {
            id[2] = '1'+i;
 80019d2:	f88d 0012 	strb.w	r0, [sp, #18]
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
 80019d6:	4628      	mov	r0, r5
        recordString("pH",timeString);
        for (i=0; i<NUM_BATS; i++)
        {
            id[2] = '1'+i;
/* Send out battery terminal measurements. */
            id[1] = 'B';
 80019d8:	f88d 3011 	strb.w	r3, [sp, #17]
            dataMessageSend(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
 80019dc:	f001 fc5a 	bl	8003294 <getBatteryCurrent>
 80019e0:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 8001b9c <prvMonitorTask+0x4b4>
        for (i=0; i<NUM_BATS; i++)
        {
            id[2] = '1'+i;
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
 80019e4:	f937 b008 	ldrsh.w	fp, [r7, r8]
                        getBatteryCurrent(i)-currentOffsets.data[i],
 80019e8:	ebcb 0900 	rsb	r9, fp, r0
                        getBatteryVoltage(i));
 80019ec:	4628      	mov	r0, r5
 80019ee:	f001 fc57 	bl	80032a0 <getBatteryVoltage>
        for (i=0; i<NUM_BATS; i++)
        {
            id[2] = '1'+i;
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
 80019f2:	4649      	mov	r1, r9
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
 80019f4:	4602      	mov	r2, r0
        for (i=0; i<NUM_BATS; i++)
        {
            id[2] = '1'+i;
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
 80019f6:	a804      	add	r0, sp, #16
 80019f8:	f7fe fd7c 	bl	80004f4 <dataMessageSend>
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
            recordDual(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
 80019fc:	4628      	mov	r0, r5
 80019fe:	f001 fc49 	bl	8003294 <getBatteryCurrent>
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
            recordDual(id,
 8001a02:	f937 2008 	ldrsh.w	r2, [r7, r8]
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
/* Send out battery state of charge. */
            id[1] = 'C';
            sendResponse(id,batterySoC[i]);
 8001a06:	f8df b178 	ldr.w	fp, [pc, #376]	; 8001b80 <prvMonitorTask+0x498>
            id[1] = 'B';
            dataMessageSend(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
            recordDual(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
 8001a0a:	ebc2 0a00 	rsb	sl, r2, r0
                        getBatteryVoltage(i));
 8001a0e:	4628      	mov	r0, r5
 8001a10:	f001 fc46 	bl	80032a0 <getBatteryVoltage>
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
            recordDual(id,
 8001a14:	4651      	mov	r1, sl
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
 8001a16:	4602      	mov	r2, r0
/* Send out battery terminal measurements. */
            id[1] = 'B';
            dataMessageSend(id,
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
            recordDual(id,
 8001a18:	a804      	add	r0, sp, #16
 8001a1a:	f7ff fd67 	bl	80014ec <recordDual>
                        getBatteryCurrent(i)-currentOffsets.data[i],
                        getBatteryVoltage(i));
/* Send out battery state of charge. */
            id[1] = 'C';
 8001a1e:	2143      	movs	r1, #67	; 0x43
 8001a20:	f88d 1011 	strb.w	r1, [sp, #17]
            sendResponse(id,batterySoC[i]);
 8001a24:	a804      	add	r0, sp, #16
 8001a26:	f83b 1007 	ldrh.w	r1, [fp, r7]
 8001a2a:	f7fe fd37 	bl	800049c <sendResponse>
            recordSingle(id,batterySoC[i]);
 8001a2e:	f83b 1007 	ldrh.w	r1, [fp, r7]
 8001a32:	a804      	add	r0, sp, #16
 8001a34:	f7ff fdc0 	bl	80015b8 <recordSingle>
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
                             ((batteryFillState[i] & 0x03) << 2) |
 8001a38:	4a5b      	ldr	r2, [pc, #364]	; (8001ba8 <prvMonitorTask+0x4c0>)
/* Send out battery state of charge. */
            id[1] = 'C';
            sendResponse(id,batterySoC[i]);
            recordSingle(id,batterySoC[i]);
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
 8001a3a:	4855      	ldr	r0, [pc, #340]	; (8001b90 <prvMonitorTask+0x4a8>)
                             ((batteryFillState[i] & 0x03) << 2) |
 8001a3c:	f815 c002 	ldrb.w	ip, [r5, r2]
/* Send out battery state of charge. */
            id[1] = 'C';
            sendResponse(id,batterySoC[i]);
            recordSingle(id,batterySoC[i]);
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
 8001a40:	5c2b      	ldrb	r3, [r5, r0]
                             ((batteryFillState[i] & 0x03) << 2) |
                             ((getBatteryChargingPhase(i) & 0x03) << 4);
 8001a42:	4628      	mov	r0, r5
            id[1] = 'C';
            sendResponse(id,batterySoC[i]);
            recordSingle(id,batterySoC[i]);
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
                             ((batteryFillState[i] & 0x03) << 2) |
 8001a44:	f00c 0a03 	and.w	sl, ip, #3
/* Send out battery state of charge. */
            id[1] = 'C';
            sendResponse(id,batterySoC[i]);
            recordSingle(id,batterySoC[i]);
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
 8001a48:	f003 0903 	and.w	r9, r3, #3
                             ((batteryFillState[i] & 0x03) << 2) |
                             ((getBatteryChargingPhase(i) & 0x03) << 4);
 8001a4c:	f000 fcd2 	bl	80023f4 <getBatteryChargingPhase>
 8001a50:	f000 0003 	and.w	r0, r0, #3
/* Send out battery state of charge. */
            id[1] = 'C';
            sendResponse(id,batterySoC[i]);
            recordSingle(id,batterySoC[i]);
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
 8001a54:	ea49 1300 	orr.w	r3, r9, r0, lsl #4
 8001a58:	ea4f 0b8a 	mov.w	fp, sl, lsl #2
                             ((batteryFillState[i] & 0x03) << 2) |
                             ((getBatteryChargingPhase(i) & 0x03) << 4);
            id[1] = 'O';
            sendResponse(id,states);
 8001a5c:	ea43 090b 	orr.w	r9, r3, fp
            recordSingle(id,batterySoC[i]);
/* Send out battery operational, fill and charging state indication. */
            uint8_t states = (batteryOpState[i] & 0x03) |
                             ((batteryFillState[i] & 0x03) << 2) |
                             ((getBatteryChargingPhase(i) & 0x03) << 4);
            id[1] = 'O';
 8001a60:	214f      	movs	r1, #79	; 0x4f
 8001a62:	f88d 1011 	strb.w	r1, [sp, #17]
            sendResponse(id,states);
 8001a66:	a804      	add	r0, sp, #16
 8001a68:	4649      	mov	r1, r9
 8001a6a:	f7fe fd17 	bl	800049c <sendResponse>
 8001a6e:	3501      	adds	r5, #1
            recordSingle(id,states);
 8001a70:	a804      	add	r0, sp, #16
 8001a72:	4649      	mov	r1, r9
 8001a74:	f7ff fda0 	bl	80015b8 <recordSingle>
 8001a78:	3702      	adds	r7, #2
/* Send out a time string */
        char timeString[20];
        putTimeToString(timeString);
        sendString("pH",timeString);
        recordString("pH",timeString);
        for (i=0; i<NUM_BATS; i++)
 8001a7a:	2d03      	cmp	r5, #3
 8001a7c:	d1a6      	bne.n	80019cc <prvMonitorTask+0x2e4>
            id[1] = 'O';
            sendResponse(id,states);
            recordSingle(id,states);
        }
/* Send out load terminal measurements. */
        id[1] = 'L';
 8001a7e:	224c      	movs	r2, #76	; 0x4c
 8001a80:	f88d 2011 	strb.w	r2, [sp, #17]
 8001a84:	f108 0706 	add.w	r7, r8, #6
 8001a88:	2500      	movs	r5, #0
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 8001a8a:	f105 0131 	add.w	r1, r5, #49	; 0x31
        id[1] = 'L';
        for (i=0; i<NUM_LOADS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
 8001a8e:	4628      	mov	r0, r5
        }
/* Send out load terminal measurements. */
        id[1] = 'L';
        for (i=0; i<NUM_LOADS; i++)
        {
            id[2] = '1'+i;
 8001a90:	f88d 1012 	strb.w	r1, [sp, #18]
            dataMessageSend(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
 8001a94:	f001 fc0a 	bl	80032ac <getLoadCurrent>
/* Send out load terminal measurements. */
        id[1] = 'L';
        for (i=0; i<NUM_LOADS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
 8001a98:	f9b7 8000 	ldrsh.w	r8, [r7]
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
 8001a9c:	ebc8 0a00 	rsb	sl, r8, r0
                        getLoadVoltage(i));
 8001aa0:	4628      	mov	r0, r5
 8001aa2:	f001 fc0b 	bl	80032bc <getLoadVoltage>
/* Send out load terminal measurements. */
        id[1] = 'L';
        for (i=0; i<NUM_LOADS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
 8001aa6:	4651      	mov	r1, sl
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
                        getLoadVoltage(i));
 8001aa8:	4602      	mov	r2, r0
/* Send out load terminal measurements. */
        id[1] = 'L';
        for (i=0; i<NUM_LOADS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
 8001aaa:	a804      	add	r0, sp, #16
 8001aac:	f7fe fd22 	bl	80004f4 <dataMessageSend>
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
                        getLoadVoltage(i));
            recordDual(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
 8001ab0:	4628      	mov	r0, r5
 8001ab2:	f001 fbfb 	bl	80032ac <getLoadCurrent>
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
                        getLoadVoltage(i));
            recordDual(id,
 8001ab6:	f937 3b02 	ldrsh.w	r3, [r7], #2
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
 8001aba:	ebc3 0b00 	rsb	fp, r3, r0
                        getLoadVoltage(i));
 8001abe:	4628      	mov	r0, r5
 8001ac0:	f001 fbfc 	bl	80032bc <getLoadVoltage>
 8001ac4:	3501      	adds	r5, #1
 8001ac6:	4602      	mov	r2, r0
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
                        getLoadVoltage(i));
            recordDual(id,
 8001ac8:	4659      	mov	r1, fp
 8001aca:	a804      	add	r0, sp, #16
 8001acc:	f7ff fd0e 	bl	80014ec <recordDual>
            sendResponse(id,states);
            recordSingle(id,states);
        }
/* Send out load terminal measurements. */
        id[1] = 'L';
        for (i=0; i<NUM_LOADS; i++)
 8001ad0:	2d02      	cmp	r5, #2
 8001ad2:	d1da      	bne.n	8001a8a <prvMonitorTask+0x3a2>
            recordDual(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
                        getLoadVoltage(i));
        }
/* Send out panel terminal measurements. */
        id[1] = 'M';
 8001ad4:	204d      	movs	r0, #77	; 0x4d
        for (i=0; i<NUM_PANELS; i++)
        {
            id[2] = '1'+i;
 8001ad6:	2231      	movs	r2, #49	; 0x31
            recordDual(id,
                        getLoadCurrent(i)-currentOffsets.data[NUM_BATS+i],
                        getLoadVoltage(i));
        }
/* Send out panel terminal measurements. */
        id[1] = 'M';
 8001ad8:	f88d 0011 	strb.w	r0, [sp, #17]
        for (i=0; i<NUM_PANELS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
 8001adc:	2000      	movs	r0, #0
        }
/* Send out panel terminal measurements. */
        id[1] = 'M';
        for (i=0; i<NUM_PANELS; i++)
        {
            id[2] = '1'+i;
 8001ade:	f88d 2012 	strb.w	r2, [sp, #18]
            dataMessageSend(id,
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
 8001ae2:	f001 fbf3 	bl	80032cc <getPanelCurrent>
 8001ae6:	4d2d      	ldr	r5, [pc, #180]	; (8001b9c <prvMonitorTask+0x4b4>)
/* Send out panel terminal measurements. */
        id[1] = 'M';
        for (i=0; i<NUM_PANELS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
 8001ae8:	f9b5 700a 	ldrsh.w	r7, [r5, #10]
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
 8001aec:	1bc7      	subs	r7, r0, r7
                        getPanelVoltage(i));
 8001aee:	2000      	movs	r0, #0
 8001af0:	f001 fbf4 	bl	80032dc <getPanelVoltage>
/* Send out panel terminal measurements. */
        id[1] = 'M';
        for (i=0; i<NUM_PANELS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
 8001af4:	4639      	mov	r1, r7
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
 8001af6:	4602      	mov	r2, r0
/* Send out panel terminal measurements. */
        id[1] = 'M';
        for (i=0; i<NUM_PANELS; i++)
        {
            id[2] = '1'+i;
            dataMessageSend(id,
 8001af8:	a804      	add	r0, sp, #16
 8001afa:	f7fe fcfb 	bl	80004f4 <dataMessageSend>
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
            recordDual(id,
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
 8001afe:	2000      	movs	r0, #0
 8001b00:	f001 fbe4 	bl	80032cc <getPanelCurrent>
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
            recordDual(id,
 8001b04:	f9b5 100a 	ldrsh.w	r1, [r5, #10]
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
 8001b08:	1a45      	subs	r5, r0, r1
                        getPanelVoltage(i));
 8001b0a:	2000      	movs	r0, #0
 8001b0c:	f001 fbe6 	bl	80032dc <getPanelVoltage>
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
            recordDual(id,
 8001b10:	4629      	mov	r1, r5
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
 8001b12:	4602      	mov	r2, r0
        {
            id[2] = '1'+i;
            dataMessageSend(id,
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
            recordDual(id,
 8001b14:	a804      	add	r0, sp, #16
 8001b16:	f7ff fce9 	bl	80014ec <recordDual>
                        getPanelCurrent(i)-currentOffsets.data[NUM_BATS+NUM_LOADS+i],
                        getPanelVoltage(i));
        }
/* Send out temperature measurement. */
        sendResponse("dT",getTemperature());
 8001b1a:	f001 fbed 	bl	80032f8 <getTemperature>
 8001b1e:	4601      	mov	r1, r0
 8001b20:	4822      	ldr	r0, [pc, #136]	; (8001bac <prvMonitorTask+0x4c4>)
 8001b22:	f7fe fcbb 	bl	800049c <sendResponse>
        recordSingle("dT",getTemperature());
 8001b26:	f001 fbe7 	bl	80032f8 <getTemperature>
 8001b2a:	4601      	mov	r1, r0
 8001b2c:	481f      	ldr	r0, [pc, #124]	; (8001bac <prvMonitorTask+0x4c4>)
 8001b2e:	f7ff fd43 	bl	80015b8 <recordSingle>
/* Send out control variables - isAutoTrack(), recording, calibrate */
        sendResponse("dD",getControls());
 8001b32:	f001 fa47 	bl	8002fc4 <getControls>
 8001b36:	4601      	mov	r1, r0
 8001b38:	481d      	ldr	r0, [pc, #116]	; (8001bb0 <prvMonitorTask+0x4c8>)
 8001b3a:	f7fe fcaf 	bl	800049c <sendResponse>
        recordSingle("dD",getControls());
 8001b3e:	f001 fa41 	bl	8002fc4 <getControls>
 8001b42:	4601      	mov	r1, r0
 8001b44:	481a      	ldr	r0, [pc, #104]	; (8001bb0 <prvMonitorTask+0x4c8>)
 8001b46:	f7ff fd37 	bl	80015b8 <recordSingle>
        sendResponse("ds",(int)getSwitchControlBits());
 8001b4a:	f000 fd35 	bl	80025b8 <getSwitchControlBits>
 8001b4e:	4601      	mov	r1, r0
 8001b50:	4818      	ldr	r0, [pc, #96]	; (8001bb4 <prvMonitorTask+0x4cc>)
 8001b52:	f7fe fca3 	bl	800049c <sendResponse>
        recordSingle("ds",(int)getSwitchControlBits());
 8001b56:	f000 fd2f 	bl	80025b8 <getSwitchControlBits>
 8001b5a:	4601      	mov	r1, r0
 8001b5c:	4815      	ldr	r0, [pc, #84]	; (8001bb4 <prvMonitorTask+0x4cc>)
 8001b5e:	f7ff fd2b 	bl	80015b8 <recordSingle>
/* Send switch and decision settings during tracking */
        if (isAutoTrack())
 8001b62:	f001 fa1d 	bl	8002fa0 <isAutoTrack>
 8001b66:	b378      	cbz	r0, 8001bc8 <prvMonitorTask+0x4e0>
        {
            sendResponse("dd",decisionStatus);
 8001b68:	4813      	ldr	r0, [pc, #76]	; (8001bb8 <prvMonitorTask+0x4d0>)
 8001b6a:	4621      	mov	r1, r4
 8001b6c:	e026      	b.n	8001bbc <prvMonitorTask+0x4d4>
 8001b6e:	bf00      	nop
 8001b70:	20000841 	.word	0x20000841
 8001b74:	0800751f 	.word	0x0800751f
 8001b78:	2000084a 	.word	0x2000084a
 8001b7c:	08007503 	.word	0x08007503
 8001b80:	20000838 	.word	0x20000838
 8001b84:	2000082c 	.word	0x2000082c
 8001b88:	20000844 	.word	0x20000844
 8001b8c:	20000820 	.word	0x20000820
 8001b90:	2000083e 	.word	0x2000083e
 8001b94:	20000843 	.word	0x20000843
 8001b98:	2000084a 	.word	0x2000084a
 8001b9c:	2000084c 	.word	0x2000084c
 8001ba0:	20000842 	.word	0x20000842
 8001ba4:	08007522 	.word	0x08007522
 8001ba8:	20000858 	.word	0x20000858
 8001bac:	08007525 	.word	0x08007525
 8001bb0:	08007506 	.word	0x08007506
 8001bb4:	08007528 	.word	0x08007528
 8001bb8:	0800752b 	.word	0x0800752b
 8001bbc:	f7fe fc6e 	bl	800049c <sendResponse>
            recordSingle("dd",decisionStatus);
 8001bc0:	48ad      	ldr	r0, [pc, #692]	; (8001e78 <prvMonitorTask+0x790>)
 8001bc2:	4621      	mov	r1, r4
 8001bc4:	f7ff fcf8 	bl	80015b8 <recordSingle>
        }
/* Read the interface fault indicators and send out */
        sendResponse("dI",getIndicators());
 8001bc8:	f000 fca2 	bl	8002510 <getIndicators>
 8001bcc:	4601      	mov	r1, r0
 8001bce:	48ab      	ldr	r0, [pc, #684]	; (8001e7c <prvMonitorTask+0x794>)
 8001bd0:	f7fe fc64 	bl	800049c <sendResponse>
 8001bd4:	2400      	movs	r4, #0
 8001bd6:	4625      	mov	r5, r4

/*------------- COMPUTE BATTERY STATE -----------------------*/
/* Access each battery charge accumulated since the last time, and update the SoC. */
        for (i=0; i<NUM_BATS; i++)
        {
            batteryCharge[i] += getBatteryAccumulatedCharge(i);
 8001bd8:	4fa9      	ldr	r7, [pc, #676]	; (8001e80 <prvMonitorTask+0x798>)
 8001bda:	4628      	mov	r0, r5
 8001bdc:	f854 9007 	ldr.w	r9, [r4, r7]
 8001be0:	f001 fb48 	bl	8003274 <getBatteryAccumulatedCharge>
 8001be4:	eb00 0309 	add.w	r3, r0, r9
 8001be8:	51e3      	str	r3, [r4, r7]
            uint32_t chargeMax = getBatteryCapacity(i)*36*100*256;
 8001bea:	4628      	mov	r0, r5
 8001bec:	f001 f95c 	bl	8002ea8 <getBatteryCapacity>
 8001bf0:	f44f 2261 	mov.w	r2, #921600	; 0xe1000
 8001bf4:	4350      	muls	r0, r2
            if (batteryCharge[i] > chargeMax) batteryCharge[i] = chargeMax;
 8001bf6:	59e1      	ldr	r1, [r4, r7]
 8001bf8:	4281      	cmp	r1, r0
 8001bfa:	bf88      	it	hi
 8001bfc:	5138      	strhi	r0, [r7, r4]
            batterySoC[i] = batteryCharge[i]/(getBatteryCapacity(i)*36);
 8001bfe:	4628      	mov	r0, r5
 8001c00:	593f      	ldr	r7, [r7, r4]
 8001c02:	f001 f951 	bl	8002ea8 <getBatteryCapacity>
 8001c06:	2324      	movs	r3, #36	; 0x24
 8001c08:	4358      	muls	r0, r3
 8001c0a:	4a9e      	ldr	r2, [pc, #632]	; (8001e84 <prvMonitorTask+0x79c>)
 8001c0c:	fbb7 f0f0 	udiv	r0, r7, r0
 8001c10:	f822 0015 	strh.w	r0, [r2, r5, lsl #1]
 8001c14:	3501      	adds	r5, #1
 8001c16:	3404      	adds	r4, #4
/* Read the interface fault indicators and send out */
        sendResponse("dI",getIndicators());

/*------------- COMPUTE BATTERY STATE -----------------------*/
/* Access each battery charge accumulated since the last time, and update the SoC. */
        for (i=0; i<NUM_BATS; i++)
 8001c18:	2d03      	cmp	r5, #3
 8001c1a:	d1dd      	bne.n	8001bd8 <prvMonitorTask+0x4f0>
 8001c1c:	2400      	movs	r4, #0
            batterySoC[i] = batteryCharge[i]/(getBatteryCapacity(i)*36);
        }
/* Collect battery charge fill state estimations. */
        for (i=0; i<NUM_BATS; i++)
        {
            uint16_t batteryAbsVoltage = abs(getBatteryVoltage(i));
 8001c1e:	4620      	mov	r0, r4
 8001c20:	f001 fb3e 	bl	80032a0 <getBatteryVoltage>
 8001c24:	2800      	cmp	r0, #0
 8001c26:	bfb8      	it	lt
 8001c28:	4240      	neglt	r0, r0
            batteryFillState[i] = normalF;
 8001c2a:	4997      	ldr	r1, [pc, #604]	; (8001e88 <prvMonitorTask+0x7a0>)
            if ((batteryAbsVoltage < LOW_VOLTAGE) || (batterySoC[i] < LOW_SOC))
 8001c2c:	b283      	uxth	r3, r0
        }
/* Collect battery charge fill state estimations. */
        for (i=0; i<NUM_BATS; i++)
        {
            uint16_t batteryAbsVoltage = abs(getBatteryVoltage(i));
            batteryFillState[i] = normalF;
 8001c2e:	2700      	movs	r7, #0
            if ((batteryAbsVoltage < LOW_VOLTAGE) || (batterySoC[i] < LOW_SOC))
 8001c30:	f5b3 6f30 	cmp.w	r3, #2816	; 0xb00
        }
/* Collect battery charge fill state estimations. */
        for (i=0; i<NUM_BATS; i++)
        {
            uint16_t batteryAbsVoltage = abs(getBatteryVoltage(i));
            batteryFillState[i] = normalF;
 8001c34:	5467      	strb	r7, [r4, r1]
            if ((batteryAbsVoltage < LOW_VOLTAGE) || (batterySoC[i] < LOW_SOC))
 8001c36:	d305      	bcc.n	8001c44 <prvMonitorTask+0x55c>
 8001c38:	4892      	ldr	r0, [pc, #584]	; (8001e84 <prvMonitorTask+0x79c>)
 8001c3a:	f830 2014 	ldrh.w	r2, [r0, r4, lsl #1]
 8001c3e:	f5b2 5f70 	cmp.w	r2, #15360	; 0x3c00
 8001c42:	d201      	bcs.n	8001c48 <prvMonitorTask+0x560>
                batteryFillState[i] = lowF;
 8001c44:	2501      	movs	r5, #1
 8001c46:	550d      	strb	r5, [r1, r4]
 8001c48:	3401      	adds	r4, #1
            uint32_t chargeMax = getBatteryCapacity(i)*36*100*256;
            if (batteryCharge[i] > chargeMax) batteryCharge[i] = chargeMax;
            batterySoC[i] = batteryCharge[i]/(getBatteryCapacity(i)*36);
        }
/* Collect battery charge fill state estimations. */
        for (i=0; i<NUM_BATS; i++)
 8001c4a:	2c03      	cmp	r4, #3
 8001c4c:	d1e7      	bne.n	8001c1e <prvMonitorTask+0x536>
/* Check for the undervoltage indicator set, and if so, mark the battery as
missing, otherwise if the battery was marked as missing and suddenly appears,
mark as isolated. Perform a current and SoC recalibration in case it was never
done. This is simply the measured current as the battery shouldn't be
sourcing any of the quiescent current.*/
        uint16_t indicators = getIndicators();
 8001c4e:	f000 fc5f 	bl	8002510 <getIndicators>
 8001c52:	2500      	movs	r5, #0
 8001c54:	4680      	mov	r8, r0
 8001c56:	462c      	mov	r4, r5
        for  (i=0; i<NUM_BATS; i++)
        {
            uint8_t lastOpState = batteryOpState[i];
            if (((indicators >> 2*i) & (0x02)) == 0)    /* Undervoltage */
 8001c58:	fa48 f305 	asr.w	r3, r8, r5
done. This is simply the measured current as the battery shouldn't be
sourcing any of the quiescent current.*/
        uint16_t indicators = getIndicators();
        for  (i=0; i<NUM_BATS; i++)
        {
            uint8_t lastOpState = batteryOpState[i];
 8001c5c:	4f8b      	ldr	r7, [pc, #556]	; (8001e8c <prvMonitorTask+0x7a4>)
            if (((indicators >> 2*i) & (0x02)) == 0)    /* Undervoltage */
 8001c5e:	f013 0002 	ands.w	r0, r3, #2
done. This is simply the measured current as the battery shouldn't be
sourcing any of the quiescent current.*/
        uint16_t indicators = getIndicators();
        for  (i=0; i<NUM_BATS; i++)
        {
            uint8_t lastOpState = batteryOpState[i];
 8001c62:	5de1      	ldrb	r1, [r4, r7]
            if (((indicators >> 2*i) & (0x02)) == 0)    /* Undervoltage */
 8001c64:	d104      	bne.n	8001c70 <prvMonitorTask+0x588>
            {
                batteryOpState[i] = missingO;
 8001c66:	2303      	movs	r3, #3
 8001c68:	55e3      	strb	r3, [r4, r7]
                batterySoC[i] = 0;
 8001c6a:	4f86      	ldr	r7, [pc, #536]	; (8001e84 <prvMonitorTask+0x79c>)
 8001c6c:	53e8      	strh	r0, [r5, r7]
 8001c6e:	e02c      	b.n	8001cca <prvMonitorTask+0x5e2>
            }
/* Slip in a newly detected battery and calibrate its current. */
            else if (lastOpState == missingO)
 8001c70:	2903      	cmp	r1, #3
 8001c72:	d12a      	bne.n	8001cca <prvMonitorTask+0x5e2>
            {
                batteryOpState[i] = isolatedO;
 8001c74:	2202      	movs	r2, #2
 8001c76:	55e2      	strb	r2, [r4, r7]
                currentOffsets.data[i] = 0;
 8001c78:	4f85      	ldr	r7, [pc, #532]	; (8001e90 <prvMonitorTask+0x7a8>)
 8001c7a:	2100      	movs	r1, #0
 8001c7c:	53e9      	strh	r1, [r5, r7]
	            vTaskDelay(getCalibrationDelay());
 8001c7e:	f001 f983 	bl	8002f88 <getCalibrationDelay>
 8001c82:	f003 fd7d 	bl	8005780 <vTaskDelay>
                currentOffsets.data[i] = getCurrent(i);
 8001c86:	4620      	mov	r0, r4
 8001c88:	f001 fb30 	bl	80032ec <getCurrent>
 8001c8c:	5378      	strh	r0, [r7, r5]
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8001c8e:	4620      	mov	r0, r4
 8001c90:	f001 fb06 	bl	80032a0 <getBatteryVoltage>
 8001c94:	4682      	mov	sl, r0
                                           getTemperature(),getBatteryType(i));
 8001c96:	f001 fb2f 	bl	80032f8 <getTemperature>
 8001c9a:	4607      	mov	r7, r0
            {
                batteryOpState[i] = isolatedO;
                currentOffsets.data[i] = 0;
	            vTaskDelay(getCalibrationDelay());
                currentOffsets.data[i] = getCurrent(i);
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8001c9c:	4620      	mov	r0, r4
 8001c9e:	f001 f8fd 	bl	8002e9c <getBatteryType>
 8001ca2:	4639      	mov	r1, r7
 8001ca4:	4602      	mov	r2, r0
 8001ca6:	4650      	mov	r0, sl
 8001ca8:	f7ff fcde 	bl	8001668 <computeSoC>
 8001cac:	4f75      	ldr	r7, [pc, #468]	; (8001e84 <prvMonitorTask+0x79c>)
 8001cae:	5378      	strh	r0, [r7, r5]
                                           getTemperature(),getBatteryType(i));
                batteryCharge[i] = getBatteryCapacity(i)*36*batterySoC[i];
 8001cb0:	4620      	mov	r0, r4
 8001cb2:	f001 f8f9 	bl	8002ea8 <getBatteryCapacity>
 8001cb6:	2324      	movs	r3, #36	; 0x24
 8001cb8:	4358      	muls	r0, r3
 8001cba:	5bea      	ldrh	r2, [r5, r7]
 8001cbc:	4970      	ldr	r1, [pc, #448]	; (8001e80 <prvMonitorTask+0x798>)
 8001cbe:	fb02 f000 	mul.w	r0, r2, r0
 8001cc2:	f841 0024 	str.w	r0, [r1, r4, lsl #2]
                writeConfigBlock();
 8001cc6:	f001 f85d 	bl	8002d84 <writeConfigBlock>
 8001cca:	3401      	adds	r4, #1
 8001ccc:	3502      	adds	r5, #2
missing, otherwise if the battery was marked as missing and suddenly appears,
mark as isolated. Perform a current and SoC recalibration in case it was never
done. This is simply the measured current as the battery shouldn't be
sourcing any of the quiescent current.*/
        uint16_t indicators = getIndicators();
        for  (i=0; i<NUM_BATS; i++)
 8001cce:	2c03      	cmp	r4, #3
 8001cd0:	d1c2      	bne.n	8001c58 <prvMonitorTask+0x570>
/* Rank the batteries by charge state. Bubble sort to have highest SoC first
pushing all missing batteries to the low end (SoC = 0 set above). */
        uint8_t k;
        uint16_t temp;
        uint8_t batteryFillStateSort[NUM_BATS];        
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
 8001cd2:	2201      	movs	r2, #1
 8001cd4:	2302      	movs	r3, #2
 8001cd6:	f88d 200c 	strb.w	r2, [sp, #12]
 8001cda:	f88d 300d 	strb.w	r3, [sp, #13]
 8001cde:	f88d 400e 	strb.w	r4, [sp, #14]
/* Check for the undervoltage indicator set, and if so, mark the battery as
missing, otherwise if the battery was marked as missing and suddenly appears,
mark as isolated. Perform a current and SoC recalibration in case it was never
done. This is simply the measured current as the battery shouldn't be
sourcing any of the quiescent current.*/
        uint16_t indicators = getIndicators();
 8001ce2:	2700      	movs	r7, #0
        uint16_t temp;
        uint8_t batteryFillStateSort[NUM_BATS];        
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
        {
            for (k=0; k<NUM_BATS-i-1; k++)
 8001ce4:	429f      	cmp	r7, r3
 8001ce6:	da19      	bge.n	8001d1c <prvMonitorTask+0x634>
            {
              if (batterySoC[batteryFillStateSort[k]-1] <
                  batterySoC[batteryFillStateSort[k+1]-1])
 8001ce8:	1c7a      	adds	r2, r7, #1
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
        {
            for (k=0; k<NUM_BATS-i-1; k++)
            {
              if (batterySoC[batteryFillStateSort[k]-1] <
 8001cea:	a91a      	add	r1, sp, #104	; 0x68
 8001cec:	19cc      	adds	r4, r1, r7
                  batterySoC[batteryFillStateSort[k+1]-1])
 8001cee:	1889      	adds	r1, r1, r2
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
        {
            for (k=0; k<NUM_BATS-i-1; k++)
            {
              if (batterySoC[batteryFillStateSort[k]-1] <
 8001cf0:	f814 0c5c 	ldrb.w	r0, [r4, #-92]
                  batterySoC[batteryFillStateSort[k+1]-1])
 8001cf4:	f811 5c5c 	ldrb.w	r5, [r1, #-92]
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
        {
            for (k=0; k<NUM_BATS-i-1; k++)
            {
              if (batterySoC[batteryFillStateSort[k]-1] <
 8001cf8:	4f62      	ldr	r7, [pc, #392]	; (8001e84 <prvMonitorTask+0x79c>)
 8001cfa:	f100 3eff 	add.w	lr, r0, #4294967295	; 0xffffffff
                  batterySoC[batteryFillStateSort[k+1]-1])
 8001cfe:	f105 3cff 	add.w	ip, r5, #4294967295	; 0xffffffff
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
        {
            for (k=0; k<NUM_BATS-i-1; k++)
            {
              if (batterySoC[batteryFillStateSort[k]-1] <
 8001d02:	f837 901e 	ldrh.w	r9, [r7, lr, lsl #1]
 8001d06:	f837 701c 	ldrh.w	r7, [r7, ip, lsl #1]
 8001d0a:	45b9      	cmp	r9, r7
                  batterySoC[batteryFillStateSort[k+1]-1])
              {
                temp = batteryFillStateSort[k];
                batteryFillStateSort[k] = batteryFillStateSort[k+1];
 8001d0c:	bf38      	it	cc
 8001d0e:	f804 5c5c 	strbcc.w	r5, [r4, #-92]
        uint16_t temp;
        uint8_t batteryFillStateSort[NUM_BATS];        
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
        {
            for (k=0; k<NUM_BATS-i-1; k++)
 8001d12:	b2d7      	uxtb	r7, r2
              if (batterySoC[batteryFillStateSort[k]-1] <
                  batterySoC[batteryFillStateSort[k+1]-1])
              {
                temp = batteryFillStateSort[k];
                batteryFillStateSort[k] = batteryFillStateSort[k+1];
                batteryFillStateSort[k+1] = temp;
 8001d14:	bf38      	it	cc
 8001d16:	f801 0c5c 	strbcc.w	r0, [r1, #-92]
 8001d1a:	e7e3      	b.n	8001ce4 <prvMonitorTask+0x5fc>
pushing all missing batteries to the low end (SoC = 0 set above). */
        uint8_t k;
        uint16_t temp;
        uint8_t batteryFillStateSort[NUM_BATS];        
        for (i=0; i<NUM_BATS; i++) batteryFillStateSort[i] = i+1;
        for (i=0; i<NUM_BATS-1; i++)
 8001d1c:	3b01      	subs	r3, #1
 8001d1e:	d1e0      	bne.n	8001ce2 <prvMonitorTask+0x5fa>
 8001d20:	461a      	mov	r2, r3
 8001d22:	469b      	mov	fp, r3
        uint8_t shortestBattery = 0;
        uint32_t longestTime = 0;
        uint32_t shortestTime = 0xFFFFFFFF;
        for (i=0; i<NUM_BATS; i++)
        {
            if (batteryOpState[i] != missingO)
 8001d24:	4859      	ldr	r0, [pc, #356]	; (8001e8c <prvMonitorTask+0x7a4>)
 8001d26:	5c19      	ldrb	r1, [r3, r0]
 8001d28:	2903      	cmp	r1, #3
 8001d2a:	d009      	beq.n	8001d40 <prvMonitorTask+0x658>
            {
                if (batteryIsolationTime[i] > longestTime)
 8001d2c:	4c59      	ldr	r4, [pc, #356]	; (8001e94 <prvMonitorTask+0x7ac>)
 8001d2e:	f854 5023 	ldr.w	r5, [r4, r3, lsl #2]
 8001d32:	4295      	cmp	r5, r2
 8001d34:	d904      	bls.n	8001d40 <prvMonitorTask+0x658>
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 8001d36:	f103 0e01 	add.w	lr, r3, #1
 8001d3a:	fa5f fb8e 	uxtb.w	fp, lr
 8001d3e:	462a      	mov	r2, r5
 8001d40:	3301      	adds	r3, #1
/* Find the batteries with the longest and shortest isolation times. */
        uint8_t longestBattery = 0;
        uint8_t shortestBattery = 0;
        uint32_t longestTime = 0;
        uint32_t shortestTime = 0xFFFFFFFF;
        for (i=0; i<NUM_BATS; i++)
 8001d42:	2b03      	cmp	r3, #3
 8001d44:	d1ee      	bne.n	8001d24 <prvMonitorTask+0x63c>
        uint8_t highestBattery = batteryFillStateSort[0];
        uint8_t lowestBattery = batteryFillStateSort[numBats-1];
/* decisionStatus is a variable used to record the reason for any decision */
        decisionStatus = 0;
/* Deallocate charger if battery is in float state */
        if (getBatteryChargingPhase(batteryUnderCharge-1) == floatC)
 8001d46:	4c54      	ldr	r4, [pc, #336]	; (8001e98 <prvMonitorTask+0x7b0>)
batteries to hold the priority loads. */
/* The code is for any number of batteries, but fixed for two loads and one
panel. */
/* @TODO update code for more panels (chargers) and loads. */
        uint8_t highestBattery = batteryFillStateSort[0];
        uint8_t lowestBattery = batteryFillStateSort[numBats-1];
 8001d48:	af1a      	add	r7, sp, #104	; 0x68
/* decisionStatus is a variable used to record the reason for any decision */
        decisionStatus = 0;
/* Deallocate charger if battery is in float state */
        if (getBatteryChargingPhase(batteryUnderCharge-1) == floatC)
 8001d4a:	7821      	ldrb	r1, [r4, #0]
batteries to hold the priority loads. */
/* The code is for any number of batteries, but fixed for two loads and one
panel. */
/* @TODO update code for more panels (chargers) and loads. */
        uint8_t highestBattery = batteryFillStateSort[0];
        uint8_t lowestBattery = batteryFillStateSort[numBats-1];
 8001d4c:	19b8      	adds	r0, r7, r6
 8001d4e:	f810 7c5d 	ldrb.w	r7, [r0, #-93]
/* decisionStatus is a variable used to record the reason for any decision */
        decisionStatus = 0;
/* Deallocate charger if battery is in float state */
        if (getBatteryChargingPhase(batteryUnderCharge-1) == floatC)
 8001d52:	1e48      	subs	r0, r1, #1
must be taken out of its isolation period. Failing that, repeat for low state
batteries to hold the priority loads. */
/* The code is for any number of batteries, but fixed for two loads and one
panel. */
/* @TODO update code for more panels (chargers) and loads. */
        uint8_t highestBattery = batteryFillStateSort[0];
 8001d54:	f89d 500c 	ldrb.w	r5, [sp, #12]
        uint8_t lowestBattery = batteryFillStateSort[numBats-1];
/* decisionStatus is a variable used to record the reason for any decision */
        decisionStatus = 0;
/* Deallocate charger if battery is in float state */
        if (getBatteryChargingPhase(batteryUnderCharge-1) == floatC)
 8001d58:	f000 fb4c 	bl	80023f4 <getBatteryChargingPhase>
 8001d5c:	2802      	cmp	r0, #2
 8001d5e:	d101      	bne.n	8001d64 <prvMonitorTask+0x67c>
            batteryUnderCharge = 0;
 8001d60:	2200      	movs	r2, #0
 8001d62:	7022      	strb	r2, [r4, #0]
/* Deallocate charger if battery is in absorption state and switch avoidance
is on. */
        if (isSwitchAvoidance() &&
 8001d64:	f001 f922 	bl	8002fac <isSwitchAvoidance>
 8001d68:	b140      	cbz	r0, 8001d7c <prvMonitorTask+0x694>
           (getBatteryChargingPhase(batteryUnderCharge-1) == floatC))
 8001d6a:	7823      	ldrb	r3, [r4, #0]
 8001d6c:	1e58      	subs	r0, r3, #1
 8001d6e:	f000 fb41 	bl	80023f4 <getBatteryChargingPhase>
/* Deallocate charger if battery is in float state */
        if (getBatteryChargingPhase(batteryUnderCharge-1) == floatC)
            batteryUnderCharge = 0;
/* Deallocate charger if battery is in absorption state and switch avoidance
is on. */
        if (isSwitchAvoidance() &&
 8001d72:	2802      	cmp	r0, #2
 8001d74:	d102      	bne.n	8001d7c <prvMonitorTask+0x694>
           (getBatteryChargingPhase(batteryUnderCharge-1) == floatC))
            batteryUnderCharge = 0;
 8001d76:	4c48      	ldr	r4, [pc, #288]	; (8001e98 <prvMonitorTask+0x7b0>)
 8001d78:	2000      	movs	r0, #0
 8001d7a:	7020      	strb	r0, [r4, #0]

/* One battery: just allocate load and charger to it */
        if (numBats == 1)
 8001d7c:	2e01      	cmp	r6, #1
 8001d7e:	d106      	bne.n	8001d8e <prvMonitorTask+0x6a6>
        {
            batteryUnderCharge = batteryFillStateSort[0];
            batteryUnderLoad = batteryUnderCharge;
 8001d80:	4c46      	ldr	r4, [pc, #280]	; (8001e9c <prvMonitorTask+0x7b4>)
            batteryUnderCharge = 0;

/* One battery: just allocate load and charger to it */
        if (numBats == 1)
        {
            batteryUnderCharge = batteryFillStateSort[0];
 8001d82:	4e45      	ldr	r6, [pc, #276]	; (8001e98 <prvMonitorTask+0x7b0>)
            batteryUnderLoad = batteryUnderCharge;
 8001d84:	7025      	strb	r5, [r4, #0]
            batteryUnderCharge = 0;

/* One battery: just allocate load and charger to it */
        if (numBats == 1)
        {
            batteryUnderCharge = batteryFillStateSort[0];
 8001d86:	7035      	strb	r5, [r6, #0]
            batteryUnderLoad = batteryUnderCharge;
            decisionStatus = 0x100;
 8001d88:	f44f 7480 	mov.w	r4, #256	; 0x100
 8001d8c:	e0ff      	b.n	8001f8e <prvMonitorTask+0x8a6>
        }
/* Two batteries: just allocate load to highest and charger to lowest. */
        else if (numBats == 2)
 8001d8e:	2e02      	cmp	r6, #2
 8001d90:	d115      	bne.n	8001dbe <prvMonitorTask+0x6d6>
        {
            batteryUnderCharge = batteryFillStateSort[1];
 8001d92:	f89d 400d 	ldrb.w	r4, [sp, #13]
 8001d96:	4e40      	ldr	r6, [pc, #256]	; (8001e98 <prvMonitorTask+0x7b0>)
            batteryUnderLoad = batteryFillStateSort[0];
 8001d98:	4f40      	ldr	r7, [pc, #256]	; (8001e9c <prvMonitorTask+0x7b4>)
            decisionStatus = 0x100;
        }
/* Two batteries: just allocate load to highest and charger to lowest. */
        else if (numBats == 2)
        {
            batteryUnderCharge = batteryFillStateSort[1];
 8001d9a:	7034      	strb	r4, [r6, #0]
            batteryUnderLoad = batteryFillStateSort[0];
 8001d9c:	703d      	strb	r5, [r7, #0]
/* If we allow the load and charger to connect to the same battery, do this in
the case that the top battery is low or critical. This may boost the voltage
to the load. */
            if (!(getMonitorStrategy() & SEPARATE_LOAD) &&
 8001d9e:	f001 f90b 	bl	8002fb8 <getMonitorStrategy>
 8001da2:	07c1      	lsls	r1, r0, #31
 8001da4:	f100 80ef 	bmi.w	8001f86 <prvMonitorTask+0x89e>
               (batteryFillState[batteryUnderLoad-1] != normalF))
 8001da8:	7839      	ldrb	r1, [r7, #0]
 8001daa:	4837      	ldr	r0, [pc, #220]	; (8001e88 <prvMonitorTask+0x7a0>)
 8001dac:	1845      	adds	r5, r0, r1
            batteryUnderCharge = batteryFillStateSort[1];
            batteryUnderLoad = batteryFillStateSort[0];
/* If we allow the load and charger to connect to the same battery, do this in
the case that the top battery is low or critical. This may boost the voltage
to the load. */
            if (!(getMonitorStrategy() & SEPARATE_LOAD) &&
 8001dae:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8001db2:	2a00      	cmp	r2, #0
 8001db4:	f000 80e7 	beq.w	8001f86 <prvMonitorTask+0x89e>
               (batteryFillState[batteryUnderLoad-1] != normalF))
                batteryUnderLoad = batteryUnderCharge;
 8001db8:	7833      	ldrb	r3, [r6, #0]
 8001dba:	703b      	strb	r3, [r7, #0]
 8001dbc:	e0e3      	b.n	8001f86 <prvMonitorTask+0x89e>
            decisionStatus = 0x200;
        }
/* More than two batteries: manage isolation and charge state. */
        else if (numBats > 2)
 8001dbe:	2e03      	cmp	r6, #3
 8001dc0:	f040 80e4 	bne.w	8001f8c <prvMonitorTask+0x8a4>
        {
/*--- All batteries normal fill state. Isolated battery already allocated. ---*/
            if (batteryFillState[lowestBattery-1] == normalF)
 8001dc4:	4e30      	ldr	r6, [pc, #192]	; (8001e88 <prvMonitorTask+0x7a0>)
 8001dc6:	4b34      	ldr	r3, [pc, #208]	; (8001e98 <prvMonitorTask+0x7b0>)
 8001dc8:	19f1      	adds	r1, r6, r7
 8001dca:	f811 1c01 	ldrb.w	r1, [r1, #-1]
 8001dce:	2900      	cmp	r1, #0
 8001dd0:	d142      	bne.n	8001e58 <prvMonitorTask+0x770>
/* (1) If the charger is unallocated, set to the lowest SoC battery if this
battery is not in float state (float state would be an unusual case that could
arise from a weak battery that cannot be charged to full SoC).
Use the isolated one only if it is not in a float charge state. */
                decisionStatus = 0x300;
                if (batteryUnderCharge == 0)
 8001dd2:	781c      	ldrb	r4, [r3, #0]
 8001dd4:	b9bc      	cbnz	r4, 8001e06 <prvMonitorTask+0x71e>
deciding which oneto charge and which to load, switching them out at intervals
and when critically low, and resetting the state of charge estimation
algorithm during lightly loaded periods.
*/

void prvMonitorTask(void *pvParameters)
 8001dd6:	ad1a      	add	r5, sp, #104	; 0x68
 8001dd8:	1929      	adds	r1, r5, r4
                if (batteryUnderCharge == 0)
                {
                    decisionStatus |= 0x01;
                    for (i=0; i<numBats; i++)
                    {
                        batteryUnderCharge = batteryFillStateSort[numBats-i-1];
 8001dda:	f811 7c5a 	ldrb.w	r7, [r1, #-90]
 8001dde:	4e2e      	ldr	r6, [pc, #184]	; (8001e98 <prvMonitorTask+0x7b0>)
                        if (getBatteryChargingPhase(batteryUnderCharge-1) != floatC)
 8001de0:	1e78      	subs	r0, r7, #1
                if (batteryUnderCharge == 0)
                {
                    decisionStatus |= 0x01;
                    for (i=0; i<numBats; i++)
                    {
                        batteryUnderCharge = batteryFillStateSort[numBats-i-1];
 8001de2:	7037      	strb	r7, [r6, #0]
                        if (getBatteryChargingPhase(batteryUnderCharge-1) != floatC)
 8001de4:	f000 fb06 	bl	80023f4 <getBatteryChargingPhase>
 8001de8:	2802      	cmp	r0, #2
 8001dea:	d104      	bne.n	8001df6 <prvMonitorTask+0x70e>
 8001dec:	3c01      	subs	r4, #1
Use the isolated one only if it is not in a float charge state. */
                decisionStatus = 0x300;
                if (batteryUnderCharge == 0)
                {
                    decisionStatus |= 0x01;
                    for (i=0; i<numBats; i++)
 8001dee:	4262      	negs	r2, r4
 8001df0:	b2d3      	uxtb	r3, r2
 8001df2:	2b02      	cmp	r3, #2
 8001df4:	d9ef      	bls.n	8001dd6 <prvMonitorTask+0x6ee>
                            break;
                    }
/* However if this has allocated the charger to the loaded battery, then
reallocate the loaded battery. This will allow the charger to swap back and
forth as the loaded battery droops and the charged battery completes charge. */
                    if (batteryUnderLoad == batteryUnderCharge)
 8001df6:	4829      	ldr	r0, [pc, #164]	; (8001e9c <prvMonitorTask+0x7b4>)
 8001df8:	7831      	ldrb	r1, [r6, #0]
 8001dfa:	7805      	ldrb	r5, [r0, #0]
 8001dfc:	428d      	cmp	r5, r1
 8001dfe:	d105      	bne.n	8001e0c <prvMonitorTask+0x724>
                        batteryUnderLoad = 0;
 8001e00:	2700      	movs	r7, #0
 8001e02:	7007      	strb	r7, [r0, #0]
 8001e04:	e002      	b.n	8001e0c <prvMonitorTask+0x724>
            {
/* (1) If the charger is unallocated, set to the lowest SoC battery if this
battery is not in float state (float state would be an unusual case that could
arise from a weak battery that cannot be charged to full SoC).
Use the isolated one only if it is not in a float charge state. */
                decisionStatus = 0x300;
 8001e06:	f44f 7440 	mov.w	r4, #768	; 0x300
 8001e0a:	e001      	b.n	8001e10 <prvMonitorTask+0x728>
                if (batteryUnderCharge == 0)
                {
                    decisionStatus |= 0x01;
 8001e0c:	f240 3401 	movw	r4, #769	; 0x301
                        batteryUnderLoad = 0;
                }
/* (2) If the loads are unallocated, set to the highest SoC unallocated battery.
Avoid the battery that has been idle for the longest time, and also battery
under charge if the strategies require it. */
                if (batteryUnderLoad == 0)
 8001e10:	4e22      	ldr	r6, [pc, #136]	; (8001e9c <prvMonitorTask+0x7b4>)
 8001e12:	7835      	ldrb	r5, [r6, #0]
 8001e14:	2d00      	cmp	r5, #0
 8001e16:	f040 8080 	bne.w	8001f1a <prvMonitorTask+0x832>
                {
                    decisionStatus |= 0x10;
 8001e1a:	f044 0410 	orr.w	r4, r4, #16
                    for (i=0; i<numBats; i++)
                    {
                        batteryUnderLoad = batteryFillStateSort[i];
 8001e1e:	aa03      	add	r2, sp, #12
 8001e20:	5cab      	ldrb	r3, [r5, r2]
 8001e22:	4f1e      	ldr	r7, [pc, #120]	; (8001e9c <prvMonitorTask+0x7b4>)
 8001e24:	703b      	strb	r3, [r7, #0]
                        if (!(getMonitorStrategy() & PRESERVE_ISOLATION) ||
 8001e26:	f001 f8c7 	bl	8002fb8 <getMonitorStrategy>
 8001e2a:	f000 0002 	and.w	r0, r0, #2
 8001e2e:	b2c1      	uxtb	r1, r0
 8001e30:	b139      	cbz	r1, 8001e42 <prvMonitorTask+0x75a>
 8001e32:	783e      	ldrb	r6, [r7, #0]
 8001e34:	455e      	cmp	r6, fp
 8001e36:	d104      	bne.n	8001e42 <prvMonitorTask+0x75a>
 8001e38:	3501      	adds	r5, #1
Avoid the battery that has been idle for the longest time, and also battery
under charge if the strategies require it. */
                if (batteryUnderLoad == 0)
                {
                    decisionStatus |= 0x10;
                    for (i=0; i<numBats; i++)
 8001e3a:	b2e9      	uxtb	r1, r5
 8001e3c:	2902      	cmp	r1, #2
 8001e3e:	d9ee      	bls.n	8001e1e <prvMonitorTask+0x736>
 8001e40:	e06b      	b.n	8001f1a <prvMonitorTask+0x832>
                    {
                        batteryUnderLoad = batteryFillStateSort[i];
                        if (!(getMonitorStrategy() & PRESERVE_ISOLATION) ||
                            (batteryUnderLoad != longestBattery))
                        {
                            if (!(getMonitorStrategy() & SEPARATE_LOAD)) break;
 8001e42:	f001 f8b9 	bl	8002fb8 <getMonitorStrategy>
 8001e46:	07c2      	lsls	r2, r0, #31
 8001e48:	d567      	bpl.n	8001f1a <prvMonitorTask+0x832>
                            if (batteryUnderLoad != batteryUnderCharge) break;
 8001e4a:	4f14      	ldr	r7, [pc, #80]	; (8001e9c <prvMonitorTask+0x7b4>)
 8001e4c:	4b12      	ldr	r3, [pc, #72]	; (8001e98 <prvMonitorTask+0x7b0>)
 8001e4e:	783a      	ldrb	r2, [r7, #0]
 8001e50:	7818      	ldrb	r0, [r3, #0]
 8001e52:	4282      	cmp	r2, r0
 8001e54:	d0f0      	beq.n	8001e38 <prvMonitorTask+0x750>
 8001e56:	e060      	b.n	8001f1a <prvMonitorTask+0x832>
                        }
                    }
                }
            }
/*--- At least one battery is normal, and some others are low or critical. ---*/
            else if (batteryFillState[highestBattery-1] == normalF)
 8001e58:	1972      	adds	r2, r6, r5
 8001e5a:	f812 0c01 	ldrb.w	r0, [r2, #-1]
 8001e5e:	2800      	cmp	r0, #0
 8001e60:	d156      	bne.n	8001f10 <prvMonitorTask+0x828>
            {
                decisionStatus = 0x400;
/* (1) If the charger is unallocated or is allocated to a normal battery,
set to the lowest SoC unallocated battery regardless if it is isolated. */
                uint8_t weakestBattery = batteryFillStateSort[numBats-1];                
                if ((batteryUnderCharge == 0) || 
 8001e62:	781b      	ldrb	r3, [r3, #0]
 8001e64:	b11b      	cbz	r3, 8001e6e <prvMonitorTask+0x786>
                    (batteryFillState[batteryUnderCharge-1] == normalF))
 8001e66:	18f6      	adds	r6, r6, r3
            {
                decisionStatus = 0x400;
/* (1) If the charger is unallocated or is allocated to a normal battery,
set to the lowest SoC unallocated battery regardless if it is isolated. */
                uint8_t weakestBattery = batteryFillStateSort[numBats-1];                
                if ((batteryUnderCharge == 0) || 
 8001e68:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 8001e6c:	b9c2      	cbnz	r2, 8001ea0 <prvMonitorTask+0x7b8>
                    (batteryFillState[batteryUnderCharge-1] == normalF))
                {
                    decisionStatus |= 0x01;
                    batteryUnderCharge = weakestBattery;
 8001e6e:	480a      	ldr	r0, [pc, #40]	; (8001e98 <prvMonitorTask+0x7b0>)
set to the lowest SoC unallocated battery regardless if it is isolated. */
                uint8_t weakestBattery = batteryFillStateSort[numBats-1];                
                if ((batteryUnderCharge == 0) || 
                    (batteryFillState[batteryUnderCharge-1] == normalF))
                {
                    decisionStatus |= 0x01;
 8001e70:	f240 4401 	movw	r4, #1025	; 0x401
                    batteryUnderCharge = weakestBattery;
 8001e74:	7007      	strb	r7, [r0, #0]
 8001e76:	e015      	b.n	8001ea4 <prvMonitorTask+0x7bc>
 8001e78:	0800752b 	.word	0x0800752b
 8001e7c:	0800752e 	.word	0x0800752e
 8001e80:	2000082c 	.word	0x2000082c
 8001e84:	20000838 	.word	0x20000838
 8001e88:	20000858 	.word	0x20000858
 8001e8c:	2000083e 	.word	0x2000083e
 8001e90:	2000084c 	.word	0x2000084c
 8001e94:	20000820 	.word	0x20000820
 8001e98:	2000084a 	.word	0x2000084a
 8001e9c:	20000843 	.word	0x20000843
                }
            }
/*--- At least one battery is normal, and some others are low or critical. ---*/
            else if (batteryFillState[highestBattery-1] == normalF)
            {
                decisionStatus = 0x400;
 8001ea0:	f44f 6480 	mov.w	r4, #1024	; 0x400
                    decisionStatus |= 0x01;
                    batteryUnderCharge = weakestBattery;
                }
/* (2) But if the lowest battery is critical we'd better work on that
regardless. */
                if (batteryFillState[weakestBattery-1] == criticalF)
 8001ea4:	2902      	cmp	r1, #2
 8001ea6:	d103      	bne.n	8001eb0 <prvMonitorTask+0x7c8>
                {
                    decisionStatus |= 0x02;
                    batteryUnderCharge = weakestBattery;
 8001ea8:	4975      	ldr	r1, [pc, #468]	; (8002080 <prvMonitorTask+0x998>)
                }
/* (2) But if the lowest battery is critical we'd better work on that
regardless. */
                if (batteryFillState[weakestBattery-1] == criticalF)
                {
                    decisionStatus |= 0x02;
 8001eaa:	f044 0402 	orr.w	r4, r4, #2
                    batteryUnderCharge = weakestBattery;
 8001eae:	700f      	strb	r7, [r1, #0]
                }
/* (3) If the loads are unallocated or if the battery under load is low or
critical, set to the highest SoC unallocated battery ... */
                if ((batteryUnderLoad == 0) ||
 8001eb0:	4f74      	ldr	r7, [pc, #464]	; (8002084 <prvMonitorTask+0x99c>)
 8001eb2:	783e      	ldrb	r6, [r7, #0]
 8001eb4:	b12e      	cbz	r6, 8001ec2 <prvMonitorTask+0x7da>
                    (batteryFillState[batteryUnderLoad-1] != normalF))
 8001eb6:	4b74      	ldr	r3, [pc, #464]	; (8002088 <prvMonitorTask+0x9a0>)
 8001eb8:	199e      	adds	r6, r3, r6
                    decisionStatus |= 0x02;
                    batteryUnderCharge = weakestBattery;
                }
/* (3) If the loads are unallocated or if the battery under load is low or
critical, set to the highest SoC unallocated battery ... */
                if ((batteryUnderLoad == 0) ||
 8001eba:	f816 2c01 	ldrb.w	r2, [r6, #-1]
 8001ebe:	b362      	cbz	r2, 8001f1a <prvMonitorTask+0x832>
 8001ec0:	2600      	movs	r6, #0
                    (batteryFillState[batteryUnderLoad-1] != normalF))
                {
                    decisionStatus |= 0x10;
                    for (i=0; i<numBats; i++)
                    {
                        batteryUnderLoad = batteryFillStateSort[i];
 8001ec2:	a803      	add	r0, sp, #12
 8001ec4:	5c31      	ldrb	r1, [r6, r0]
 8001ec6:	4f6f      	ldr	r7, [pc, #444]	; (8002084 <prvMonitorTask+0x99c>)
                        if (batteryUnderLoad != longestBattery)
 8001ec8:	4559      	cmp	r1, fp
                    (batteryFillState[batteryUnderLoad-1] != normalF))
                {
                    decisionStatus |= 0x10;
                    for (i=0; i<numBats; i++)
                    {
                        batteryUnderLoad = batteryFillStateSort[i];
 8001eca:	7039      	strb	r1, [r7, #0]
 8001ecc:	46b9      	mov	r9, r7
                        if (batteryUnderLoad != longestBattery)
 8001ece:	d104      	bne.n	8001eda <prvMonitorTask+0x7f2>
 8001ed0:	3601      	adds	r6, #1
critical, set to the highest SoC unallocated battery ... */
                if ((batteryUnderLoad == 0) ||
                    (batteryFillState[batteryUnderLoad-1] != normalF))
                {
                    decisionStatus |= 0x10;
                    for (i=0; i<numBats; i++)
 8001ed2:	b2f1      	uxtb	r1, r6
 8001ed4:	2902      	cmp	r1, #2
 8001ed6:	d9f4      	bls.n	8001ec2 <prvMonitorTask+0x7da>
 8001ed8:	e003      	b.n	8001ee2 <prvMonitorTask+0x7fa>
                    {
                        batteryUnderLoad = batteryFillStateSort[i];
                        if (batteryUnderLoad != longestBattery)
                        {
                            if (!(getMonitorStrategy() & SEPARATE_LOAD)) break;
 8001eda:	f001 f86d 	bl	8002fb8 <getMonitorStrategy>
 8001ede:	07c3      	lsls	r3, r0, #31
 8001ee0:	d403      	bmi.n	8001eea <prvMonitorTask+0x802>
                        }
                    }
/* ... however if it still ends up on a low battery then there is only one
normal battery which is also isolated, so this must be overridden (this should
not the charging battery if our logic is correct so far). */
                    if ((batteryUnderLoad == 0) ||
 8001ee2:	f899 7000 	ldrb.w	r7, [r9]
 8001ee6:	b177      	cbz	r7, 8001f06 <prvMonitorTask+0x81e>
 8001ee8:	e005      	b.n	8001ef6 <prvMonitorTask+0x80e>
                    {
                        batteryUnderLoad = batteryFillStateSort[i];
                        if (batteryUnderLoad != longestBattery)
                        {
                            if (!(getMonitorStrategy() & SEPARATE_LOAD)) break;
                            if (batteryUnderLoad != batteryUnderCharge) break;
 8001eea:	4b65      	ldr	r3, [pc, #404]	; (8002080 <prvMonitorTask+0x998>)
 8001eec:	783a      	ldrb	r2, [r7, #0]
 8001eee:	7818      	ldrb	r0, [r3, #0]
 8001ef0:	4282      	cmp	r2, r0
 8001ef2:	d0ed      	beq.n	8001ed0 <prvMonitorTask+0x7e8>
 8001ef4:	e7f5      	b.n	8001ee2 <prvMonitorTask+0x7fa>
                    }
/* ... however if it still ends up on a low battery then there is only one
normal battery which is also isolated, so this must be overridden (this should
not the charging battery if our logic is correct so far). */
                    if ((batteryUnderLoad == 0) ||
                        (batteryFillState[batteryUnderLoad-1] != normalF))
 8001ef6:	4a64      	ldr	r2, [pc, #400]	; (8002088 <prvMonitorTask+0x9a0>)
 8001ef8:	19d3      	adds	r3, r2, r7
                        }
                    }
/* ... however if it still ends up on a low battery then there is only one
normal battery which is also isolated, so this must be overridden (this should
not the charging battery if our logic is correct so far). */
                    if ((batteryUnderLoad == 0) ||
 8001efa:	f813 0c01 	ldrb.w	r0, [r3, #-1]
 8001efe:	b910      	cbnz	r0, 8001f06 <prvMonitorTask+0x81e>
/* (3) If the loads are unallocated or if the battery under load is low or
critical, set to the highest SoC unallocated battery ... */
                if ((batteryUnderLoad == 0) ||
                    (batteryFillState[batteryUnderLoad-1] != normalF))
                {
                    decisionStatus |= 0x10;
 8001f00:	f044 0410 	orr.w	r4, r4, #16
 8001f04:	e009      	b.n	8001f1a <prvMonitorTask+0x832>
not the charging battery if our logic is correct so far). */
                    if ((batteryUnderLoad == 0) ||
                        (batteryFillState[batteryUnderLoad-1] != normalF))
                    {
                        decisionStatus |= 0x20;
                        batteryUnderLoad = batteryFillStateSort[0];
 8001f06:	4e5f      	ldr	r6, [pc, #380]	; (8002084 <prvMonitorTask+0x99c>)
normal battery which is also isolated, so this must be overridden (this should
not the charging battery if our logic is correct so far). */
                    if ((batteryUnderLoad == 0) ||
                        (batteryFillState[batteryUnderLoad-1] != normalF))
                    {
                        decisionStatus |= 0x20;
 8001f08:	f044 0430 	orr.w	r4, r4, #48	; 0x30
                        batteryUnderLoad = batteryFillStateSort[0];
 8001f0c:	7035      	strb	r5, [r6, #0]
 8001f0e:	e004      	b.n	8001f1a <prvMonitorTask+0x832>
/* Allocate charger and loads as best we can. If the battery under load is
critical we must turn off the low priority loads. */
            else
            {
                decisionStatus = 0x500;
                batteryUnderLoad = batteryFillStateSort[0];
 8001f10:	4c5c      	ldr	r4, [pc, #368]	; (8002084 <prvMonitorTask+0x99c>)
                batteryUnderCharge = batteryFillStateSort[numBats-1];
 8001f12:	701f      	strb	r7, [r3, #0]
/* Allocate charger and loads as best we can. If the battery under load is
critical we must turn off the low priority loads. */
            else
            {
                decisionStatus = 0x500;
                batteryUnderLoad = batteryFillStateSort[0];
 8001f14:	7025      	strb	r5, [r4, #0]
/*--- Otherwise all batteries are low or critical. ---*/
/* Allocate charger and loads as best we can. If the battery under load is
critical we must turn off the low priority loads. */
            else
            {
                decisionStatus = 0x500;
 8001f16:	f44f 64a0 	mov.w	r4, #1280	; 0x500

/*------------------------CLEAN UP --------------------------------*/
/* If charging voltage is lower than the battery voltage, turn off charging
altogether. This will allow more flexibility in managing isolation during night
periods. */
            if (getBatteryVoltage(batteryUnderCharge-1) > getPanelVoltage(0))
 8001f1a:	4f59      	ldr	r7, [pc, #356]	; (8002080 <prvMonitorTask+0x998>)
 8001f1c:	783e      	ldrb	r6, [r7, #0]
 8001f1e:	1e70      	subs	r0, r6, #1
 8001f20:	f001 f9be 	bl	80032a0 <getBatteryVoltage>
 8001f24:	4605      	mov	r5, r0
 8001f26:	2000      	movs	r0, #0
 8001f28:	f001 f9d8 	bl	80032dc <getPanelVoltage>
 8001f2c:	4285      	cmp	r5, r0
 8001f2e:	dd01      	ble.n	8001f34 <prvMonitorTask+0x84c>
            {
                batteryUnderCharge = 0;
 8001f30:	2200      	movs	r2, #0
 8001f32:	703a      	strb	r2, [r7, #0]
            {
                uint8_t lastOpState = batteryOpState[i];
                if (batteryOpState[i] != missingO)
                {
                    batteryOpState[i] = isolatedO; /* reset operational state */
                    if ((batteryUnderLoad > 0) && (i == batteryUnderLoad-1))
 8001f34:	4b53      	ldr	r3, [pc, #332]	; (8002084 <prvMonitorTask+0x99c>)
                    {
                        batteryOpState[i] = loadedO;
                    }
                    if ((batteryUnderCharge > 0) && (i == batteryUnderCharge-1))
 8001f36:	7838      	ldrb	r0, [r7, #0]
            {
                uint8_t lastOpState = batteryOpState[i];
                if (batteryOpState[i] != missingO)
                {
                    batteryOpState[i] = isolatedO; /* reset operational state */
                    if ((batteryUnderLoad > 0) && (i == batteryUnderLoad-1))
 8001f38:	7819      	ldrb	r1, [r3, #0]
 8001f3a:	4a54      	ldr	r2, [pc, #336]	; (800208c <prvMonitorTask+0x9a4>)
 8001f3c:	1e4e      	subs	r6, r1, #1
                    {
                        batteryOpState[i] = loadedO;
                    }
                    if ((batteryUnderCharge > 0) && (i == batteryUnderCharge-1))
 8001f3e:	1e45      	subs	r5, r0, #1
 8001f40:	2300      	movs	r3, #0
            }
/* Work out changes in battery operational states. */
            for (i=0; i<NUM_BATS; i++)
            {
                uint8_t lastOpState = batteryOpState[i];
                if (batteryOpState[i] != missingO)
 8001f42:	f812 7b01 	ldrb.w	r7, [r2], #1
 8001f46:	2f03      	cmp	r7, #3
 8001f48:	d019      	beq.n	8001f7e <prvMonitorTask+0x896>
                {
                    batteryOpState[i] = isolatedO; /* reset operational state */
 8001f4a:	2702      	movs	r7, #2
 8001f4c:	f802 7c01 	strb.w	r7, [r2, #-1]
                    if ((batteryUnderLoad > 0) && (i == batteryUnderLoad-1))
 8001f50:	b121      	cbz	r1, 8001f5c <prvMonitorTask+0x874>
 8001f52:	42b3      	cmp	r3, r6
 8001f54:	d102      	bne.n	8001f5c <prvMonitorTask+0x874>
                    {
                        batteryOpState[i] = loadedO;
 8001f56:	2700      	movs	r7, #0
 8001f58:	f802 7c01 	strb.w	r7, [r2, #-1]
                    }
                    if ((batteryUnderCharge > 0) && (i == batteryUnderCharge-1))
 8001f5c:	b120      	cbz	r0, 8001f68 <prvMonitorTask+0x880>
 8001f5e:	42ab      	cmp	r3, r5
 8001f60:	d102      	bne.n	8001f68 <prvMonitorTask+0x880>
                    {
                        batteryOpState[i] = chargingO;
 8001f62:	2701      	movs	r7, #1
 8001f64:	f802 7c01 	strb.w	r7, [r2, #-1]
                    }
/* Restart isolation timer if not isolated or if charger and loads on same
battery (isolation is not possible due to leakage of charging current to other
batteries). Do not reset to zero so that the current isolated timer can handover
later. */
                    if ((batteryOpState[i] != isolatedO) ||
 8001f68:	f812 7c01 	ldrb.w	r7, [r2, #-1]
 8001f6c:	2f02      	cmp	r7, #2
 8001f6e:	d101      	bne.n	8001f74 <prvMonitorTask+0x88c>
 8001f70:	4281      	cmp	r1, r0
 8001f72:	d104      	bne.n	8001f7e <prvMonitorTask+0x896>
                        (batteryUnderLoad == batteryUnderCharge))
                        batteryIsolationTime[i] = 10;
 8001f74:	4f46      	ldr	r7, [pc, #280]	; (8002090 <prvMonitorTask+0x9a8>)
 8001f76:	f04f 0c0a 	mov.w	ip, #10
 8001f7a:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
 8001f7e:	3301      	adds	r3, #1
            if (getBatteryVoltage(batteryUnderCharge-1) > getPanelVoltage(0))
            {
                batteryUnderCharge = 0;
            }
/* Work out changes in battery operational states. */
            for (i=0; i<NUM_BATS; i++)
 8001f80:	2b03      	cmp	r3, #3
 8001f82:	d1de      	bne.n	8001f42 <prvMonitorTask+0x85a>
 8001f84:	e003      	b.n	8001f8e <prvMonitorTask+0x8a6>
the case that the top battery is low or critical. This may boost the voltage
to the load. */
            if (!(getMonitorStrategy() & SEPARATE_LOAD) &&
               (batteryFillState[batteryUnderLoad-1] != normalF))
                batteryUnderLoad = batteryUnderCharge;
            decisionStatus = 0x200;
 8001f86:	f44f 7400 	mov.w	r4, #512	; 0x200
 8001f8a:	e000      	b.n	8001f8e <prvMonitorTask+0x8a6>
panel. */
/* @TODO update code for more panels (chargers) and loads. */
        uint8_t highestBattery = batteryFillStateSort[0];
        uint8_t lowestBattery = batteryFillStateSort[numBats-1];
/* decisionStatus is a variable used to record the reason for any decision */
        decisionStatus = 0;
 8001f8c:	2400      	movs	r4, #0
                        batteryIsolationTime[i] = 10;
                }
            }
        }
/* Set Switches. Turn off low priority loads if batteries are all critical */
        if (isAutoTrack())
 8001f8e:	f001 f807 	bl	8002fa0 <isAutoTrack>
 8001f92:	b1b0      	cbz	r0, 8001fc2 <prvMonitorTask+0x8da>
        {
            setSwitch(batteryUnderLoad,LOAD_2);
 8001f94:	4f3b      	ldr	r7, [pc, #236]	; (8002084 <prvMonitorTask+0x99c>)
 8001f96:	2101      	movs	r1, #1
 8001f98:	7838      	ldrb	r0, [r7, #0]
 8001f9a:	f000 fae9 	bl	8002570 <setSwitch>
            if (batteryFillState[batteryUnderLoad-1] == criticalF)
 8001f9e:	7838      	ldrb	r0, [r7, #0]
 8001fa0:	4939      	ldr	r1, [pc, #228]	; (8002088 <prvMonitorTask+0x9a0>)
 8001fa2:	180d      	adds	r5, r1, r0
 8001fa4:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 8001fa8:	2a02      	cmp	r2, #2
 8001faa:	d102      	bne.n	8001fb2 <prvMonitorTask+0x8ca>
            {
                setSwitch(0,LOAD_1);
 8001fac:	2000      	movs	r0, #0
 8001fae:	4601      	mov	r1, r0
 8001fb0:	e000      	b.n	8001fb4 <prvMonitorTask+0x8cc>
            }
            else
            {
                setSwitch(batteryUnderLoad,LOAD_1);
 8001fb2:	2100      	movs	r1, #0
 8001fb4:	f000 fadc 	bl	8002570 <setSwitch>
            }
            setSwitch(batteryUnderCharge,PANEL);
 8001fb8:	4831      	ldr	r0, [pc, #196]	; (8002080 <prvMonitorTask+0x998>)
 8001fba:	2102      	movs	r1, #2
 8001fbc:	7800      	ldrb	r0, [r0, #0]
 8001fbe:	f000 fad7 	bl	8002570 <setSwitch>

/*---------------- RESET SoC AFTER IDLE TIME --------------------*/
/* Compute state of charge estimates from OCV if currents are low for an hour.
The steady current indicator is incremented on each cycle that the current is
below a threshold of about 80mA. */
        uint32_t monitorHour = 3600*1000/(portTICK_RATE_MS*getMonitorDelay());
 8001fc2:	f000 ffdb 	bl	8002f7c <getMonitorDelay>
 8001fc6:	f04f 080a 	mov.w	r8, #10
 8001fca:	fb08 f600 	mul.w	r6, r8, r0
 8001fce:	4b31      	ldr	r3, [pc, #196]	; (8002094 <prvMonitorTask+0x9ac>)
            }
/* Update the isolation time of each battery. If a battery has been isolated for
over 8 hours, compute SoC and drop isolation time back to zero to allow other
batteries to go isolated. */
            batteryIsolationTime[i]++;
            if (batteryIsolationTime[i] > 8*monitorHour)
 8001fd0:	2500      	movs	r5, #0

/*---------------- RESET SoC AFTER IDLE TIME --------------------*/
/* Compute state of charge estimates from OCV if currents are low for an hour.
The steady current indicator is incremented on each cycle that the current is
below a threshold of about 80mA. */
        uint32_t monitorHour = 3600*1000/(portTICK_RATE_MS*getMonitorDelay());
 8001fd2:	fbb3 f9f6 	udiv	r9, r3, r6
            }
/* Update the isolation time of each battery. If a battery has been isolated for
over 8 hours, compute SoC and drop isolation time back to zero to allow other
batteries to go isolated. */
            batteryIsolationTime[i]++;
            if (batteryIsolationTime[i] > 8*monitorHour)
 8001fd6:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 8001fda:	462f      	mov	r7, r5
 8001fdc:	462e      	mov	r6, r5
The steady current indicator is incremented on each cycle that the current is
below a threshold of about 80mA. */
        uint32_t monitorHour = 3600*1000/(portTICK_RATE_MS*getMonitorDelay());
        for (i=0; i<NUM_BATS; i++)
        {
            if (abs(getBatteryCurrent(i)) < 30)
 8001fde:	4630      	mov	r0, r6
 8001fe0:	f001 f958 	bl	8003294 <getBatteryCurrent>
 8001fe4:	2800      	cmp	r0, #0
 8001fe6:	bfb8      	it	lt
 8001fe8:	4240      	neglt	r0, r0
 8001fea:	281d      	cmp	r0, #29
 8001fec:	492a      	ldr	r1, [pc, #168]	; (8002098 <prvMonitorTask+0x9b0>)
 8001fee:	dc02      	bgt.n	8001ff6 <prvMonitorTask+0x90e>
                batteryCurrentSteady[i]++;
 8001ff0:	5b48      	ldrh	r0, [r1, r5]
 8001ff2:	1c42      	adds	r2, r0, #1
 8001ff4:	e000      	b.n	8001ff8 <prvMonitorTask+0x910>
            else
                batteryCurrentSteady[i] = 0;
 8001ff6:	2200      	movs	r2, #0
 8001ff8:	534a      	strh	r2, [r1, r5]
            if (batteryCurrentSteady[i] > monitorHour)
 8001ffa:	5b4b      	ldrh	r3, [r1, r5]
 8001ffc:	454b      	cmp	r3, r9
 8001ffe:	d913      	bls.n	8002028 <prvMonitorTask+0x940>
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8002000:	4630      	mov	r0, r6
 8002002:	f001 f94d 	bl	80032a0 <getBatteryVoltage>
 8002006:	4683      	mov	fp, r0
                                           getTemperature(),getBatteryType(i));
 8002008:	f001 f976 	bl	80032f8 <getTemperature>
 800200c:	4680      	mov	r8, r0
                batteryCurrentSteady[i]++;
            else
                batteryCurrentSteady[i] = 0;
            if (batteryCurrentSteady[i] > monitorHour)
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 800200e:	4630      	mov	r0, r6
 8002010:	f000 ff44 	bl	8002e9c <getBatteryType>
 8002014:	4641      	mov	r1, r8
 8002016:	4602      	mov	r2, r0
 8002018:	4658      	mov	r0, fp
 800201a:	f7ff fb25 	bl	8001668 <computeSoC>
 800201e:	491f      	ldr	r1, [pc, #124]	; (800209c <prvMonitorTask+0x9b4>)
                                           getTemperature(),getBatteryType(i));
                batteryCurrentSteady[i] = 0;
 8002020:	2200      	movs	r2, #0
                batteryCurrentSteady[i]++;
            else
                batteryCurrentSteady[i] = 0;
            if (batteryCurrentSteady[i] > monitorHour)
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8002022:	5348      	strh	r0, [r1, r5]
                                           getTemperature(),getBatteryType(i));
                batteryCurrentSteady[i] = 0;
 8002024:	481c      	ldr	r0, [pc, #112]	; (8002098 <prvMonitorTask+0x9b0>)
 8002026:	522a      	strh	r2, [r5, r0]
            }
/* Update the isolation time of each battery. If a battery has been isolated for
over 8 hours, compute SoC and drop isolation time back to zero to allow other
batteries to go isolated. */
            batteryIsolationTime[i]++;
 8002028:	f8df 8064 	ldr.w	r8, [pc, #100]	; 8002090 <prvMonitorTask+0x9a8>
 800202c:	f857 3008 	ldr.w	r3, [r7, r8]
 8002030:	1c59      	adds	r1, r3, #1
            if (batteryIsolationTime[i] > 8*monitorHour)
 8002032:	4551      	cmp	r1, sl
                batteryCurrentSteady[i] = 0;
            }
/* Update the isolation time of each battery. If a battery has been isolated for
over 8 hours, compute SoC and drop isolation time back to zero to allow other
batteries to go isolated. */
            batteryIsolationTime[i]++;
 8002034:	f847 1008 	str.w	r1, [r7, r8]
            if (batteryIsolationTime[i] > 8*monitorHour)
 8002038:	d913      	bls.n	8002062 <prvMonitorTask+0x97a>
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 800203a:	4630      	mov	r0, r6
 800203c:	f001 f930 	bl	80032a0 <getBatteryVoltage>
                                           getTemperature(),getBatteryType(i));
 8002040:	9001      	str	r0, [sp, #4]
 8002042:	f001 f959 	bl	80032f8 <getTemperature>
 8002046:	4683      	mov	fp, r0
over 8 hours, compute SoC and drop isolation time back to zero to allow other
batteries to go isolated. */
            batteryIsolationTime[i]++;
            if (batteryIsolationTime[i] > 8*monitorHour)
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 8002048:	4630      	mov	r0, r6
 800204a:	f000 ff27 	bl	8002e9c <getBatteryType>
 800204e:	4659      	mov	r1, fp
 8002050:	4602      	mov	r2, r0
 8002052:	9801      	ldr	r0, [sp, #4]
 8002054:	f7ff fb08 	bl	8001668 <computeSoC>
 8002058:	4b10      	ldr	r3, [pc, #64]	; (800209c <prvMonitorTask+0x9b4>)
                                           getTemperature(),getBatteryType(i));
                batteryIsolationTime[i] = 0;
 800205a:	2100      	movs	r1, #0
over 8 hours, compute SoC and drop isolation time back to zero to allow other
batteries to go isolated. */
            batteryIsolationTime[i]++;
            if (batteryIsolationTime[i] > 8*monitorHour)
            {
                batterySoC[i] = computeSoC(getBatteryVoltage(i),
 800205c:	5358      	strh	r0, [r3, r5]
                                           getTemperature(),getBatteryType(i));
                batteryIsolationTime[i] = 0;
 800205e:	f847 1008 	str.w	r1, [r7, r8]
 8002062:	3601      	adds	r6, #1
 8002064:	3704      	adds	r7, #4
 8002066:	3502      	adds	r5, #2
/*---------------- RESET SoC AFTER IDLE TIME --------------------*/
/* Compute state of charge estimates from OCV if currents are low for an hour.
The steady current indicator is incremented on each cycle that the current is
below a threshold of about 80mA. */
        uint32_t monitorHour = 3600*1000/(portTICK_RATE_MS*getMonitorDelay());
        for (i=0; i<NUM_BATS; i++)
 8002068:	2e03      	cmp	r6, #3
 800206a:	d1b8      	bne.n	8001fde <prvMonitorTask+0x8f6>
                batteryIsolationTime[i] = 0;
            }
        }

/* Wait until the next tick cycle */
		vTaskDelay(getMonitorDelay());
 800206c:	f000 ff86 	bl	8002f7c <getMonitorDelay>
 8002070:	f003 fb86 	bl	8005780 <vTaskDelay>
/* Reset watchdog counter */
        monitorWatchdogCount = 0;
 8002074:	480a      	ldr	r0, [pc, #40]	; (80020a0 <prvMonitorTask+0x9b8>)
 8002076:	2200      	movs	r2, #0
 8002078:	7002      	strb	r2, [r0, #0]
    }
 800207a:	f7ff bb99 	b.w	80017b0 <prvMonitorTask+0xc8>
 800207e:	bf00      	nop
 8002080:	2000084a 	.word	0x2000084a
 8002084:	20000843 	.word	0x20000843
 8002088:	20000858 	.word	0x20000858
 800208c:	2000083e 	.word	0x2000083e
 8002090:	20000820 	.word	0x20000820
 8002094:	0036ee80 	.word	0x0036ee80
 8002098:	20000844 	.word	0x20000844
 800209c:	20000838 	.word	0x20000838
 80020a0:	20000841 	.word	0x20000841

080020a4 <getBatteryCurrentOffset>:
*/

int16_t getBatteryCurrentOffset(int battery)
{
    return currentOffsets.dataArray.battery[battery];
}
 80020a4:	4b01      	ldr	r3, [pc, #4]	; (80020ac <getBatteryCurrentOffset+0x8>)
 80020a6:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
 80020aa:	4770      	bx	lr
 80020ac:	2000084c 	.word	0x2000084c

080020b0 <startCalibration>:

*/

void startCalibration()
{
    calibrate = true;
 80020b0:	4b01      	ldr	r3, [pc, #4]	; (80020b8 <startCalibration+0x8>)
 80020b2:	2201      	movs	r2, #1
 80020b4:	701a      	strb	r2, [r3, #0]
 80020b6:	4770      	bx	lr
 80020b8:	20000842 	.word	0x20000842

080020bc <checkMonitorWatchdog>:

The watchdog counter is decremented. If it reaches zero then the task is reset.
*/

void checkMonitorWatchdog(void)
{
 80020bc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    if (monitorWatchdogCount++ > 10*getMonitorDelay()/getWatchdogDelay())
 80020be:	4d15      	ldr	r5, [pc, #84]	; (8002114 <checkMonitorWatchdog+0x58>)
 80020c0:	782c      	ldrb	r4, [r5, #0]
 80020c2:	f000 ff5b 	bl	8002f7c <getMonitorDelay>
 80020c6:	4606      	mov	r6, r0
 80020c8:	f000 ff46 	bl	8002f58 <getWatchdogDelay>
 80020cc:	210a      	movs	r1, #10
 80020ce:	4371      	muls	r1, r6
 80020d0:	fbb1 f0f0 	udiv	r0, r1, r0
 80020d4:	1c63      	adds	r3, r4, #1
 80020d6:	4284      	cmp	r4, r0
 80020d8:	702b      	strb	r3, [r5, #0]
 80020da:	d918      	bls.n	800210e <checkMonitorWatchdog+0x52>
    {
        vTaskDelete(prvMonitorTask);
 80020dc:	480e      	ldr	r0, [pc, #56]	; (8002118 <checkMonitorWatchdog+0x5c>)
 80020de:	f003 f9c5 	bl	800546c <vTaskDelete>
	    xTaskCreate(prvMonitorTask, (signed portCHAR * ) "Monitor", \
 80020e2:	2300      	movs	r3, #0
 80020e4:	2201      	movs	r2, #1
 80020e6:	9200      	str	r2, [sp, #0]
 80020e8:	9301      	str	r3, [sp, #4]
 80020ea:	9302      	str	r3, [sp, #8]
 80020ec:	9303      	str	r3, [sp, #12]
 80020ee:	2280      	movs	r2, #128	; 0x80
 80020f0:	490a      	ldr	r1, [pc, #40]	; (800211c <checkMonitorWatchdog+0x60>)
 80020f2:	4809      	ldr	r0, [pc, #36]	; (8002118 <checkMonitorWatchdog+0x5c>)
 80020f4:	f003 f8f4 	bl	80052e0 <xTaskGenericCreate>
                    configMINIMAL_STACK_SIZE, NULL, MONITOR_TASK_PRIORITY, NULL);
        sendStringLowPriority("D","Monitor Restarted");
 80020f8:	4809      	ldr	r0, [pc, #36]	; (8002120 <checkMonitorWatchdog+0x64>)
 80020fa:	490a      	ldr	r1, [pc, #40]	; (8002124 <checkMonitorWatchdog+0x68>)
 80020fc:	f7fe f914 	bl	8000328 <sendStringLowPriority>
        recordString("D","Monitor Restarted");
 8002100:	4807      	ldr	r0, [pc, #28]	; (8002120 <checkMonitorWatchdog+0x64>)
 8002102:	4908      	ldr	r1, [pc, #32]	; (8002124 <checkMonitorWatchdog+0x68>)
    }
}
 8002104:	b004      	add	sp, #16
 8002106:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    {
        vTaskDelete(prvMonitorTask);
	    xTaskCreate(prvMonitorTask, (signed portCHAR * ) "Monitor", \
                    configMINIMAL_STACK_SIZE, NULL, MONITOR_TASK_PRIORITY, NULL);
        sendStringLowPriority("D","Monitor Restarted");
        recordString("D","Monitor Restarted");
 800210a:	f7ff b997 	b.w	800143c <recordString>
    }
}
 800210e:	b004      	add	sp, #16
 8002110:	bd70      	pop	{r4, r5, r6, pc}
 8002112:	bf00      	nop
 8002114:	20000841 	.word	0x20000841
 8002118:	080016e9 	.word	0x080016e9
 800211c:	080074b5 	.word	0x080074b5
 8002120:	080074e2 	.word	0x080074e2
 8002124:	08007531 	.word	0x08007531

08002128 <prvChargerTask>:
static void initGlobals(void)
{
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
    {
        batteryChargingPhase[i] = bulkC;
 8002128:	4aa7      	ldr	r2, [pc, #668]	; (80023c8 <prvChargerTask+0x2a0>)
 800212a:	2300      	movs	r3, #0
This task runs over long times, implementing the charging algorithm on a
battery that have been designated for charging.
*/

void prvChargerTask(void *pvParameters)
{
 800212c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
static void initGlobals(void)
{
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
    {
        batteryChargingPhase[i] = bulkC;
 8002130:	7013      	strb	r3, [r2, #0]
 8002132:	7053      	strb	r3, [r2, #1]
 8002134:	7093      	strb	r3, [r2, #2]
    initGlobals();

    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
    {
        voltageAv[i] = 0;
 8002136:	49a5      	ldr	r1, [pc, #660]	; (80023cc <prvChargerTask+0x2a4>)
        currentAv[i] = 0;
 8002138:	4ca5      	ldr	r4, [pc, #660]	; (80023d0 <prvChargerTask+0x2a8>)
        absorptionPhaseTime[i] = 0;
 800213a:	4da6      	ldr	r5, [pc, #664]	; (80023d4 <prvChargerTask+0x2ac>)
        absorptionPhaseCurrent[i] = 0;
 800213c:	4ea6      	ldr	r6, [pc, #664]	; (80023d8 <prvChargerTask+0x2b0>)
        chargingMeasure[i] = 0;
 800213e:	4fa7      	ldr	r7, [pc, #668]	; (80023dc <prvChargerTask+0x2b4>)
    initGlobals();

    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
    {
        voltageAv[i] = 0;
 8002140:	2000      	movs	r0, #0
 8002142:	5258      	strh	r0, [r3, r1]
        currentAv[i] = 0;
 8002144:	5318      	strh	r0, [r3, r4]
        absorptionPhaseTime[i] = 0;
 8002146:	5358      	strh	r0, [r3, r5]
        absorptionPhaseCurrent[i] = 0;
 8002148:	5398      	strh	r0, [r3, r6]
        chargingMeasure[i] = 0;
 800214a:	53d8      	strh	r0, [r3, r7]
 800214c:	3302      	adds	r3, #2
    static uint16_t bulkCurrent = 0;

    initGlobals();

    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++)
 800214e:	2b06      	cmp	r3, #6
 8002150:	d1f1      	bne.n	8002136 <prvChargerTask+0xe>
 8002152:	f44f 5548 	mov.w	r5, #12800	; 0x3200
 8002156:	f44f 47c8 	mov.w	r7, #25600	; 0x6400
    }

	while (1)
	{
/* Wait until the next tick cycle */
	    vTaskDelay(getChargerDelay());
 800215a:	f000 ff03 	bl	8002f64 <getChargerDelay>
 800215e:	f003 fb0f 	bl	8005780 <vTaskDelay>
/* Reset watchdog counter */
        chargerWatchdogCount = 0;
 8002162:	4a9f      	ldr	r2, [pc, #636]	; (80023e0 <prvChargerTask+0x2b8>)
 8002164:	2600      	movs	r6, #0
 8002166:	7016      	strb	r6, [r2, #0]

/* Get the battery being charged, if any, from the switch settings.
These monitor task will set these to select the battery to charge. */
        uint8_t switchSettings = getSwitchControlBits();
 8002168:	f000 fa26 	bl	80025b8 <getSwitchControlBits>
        battery = (switchSettings >> 4) & 0x03;
/* If this is different to the battery currently under charge, change over. */
        if (battery != batteryUnderCharge)  /* Change of battery to charge */
 800216c:	4c9d      	ldr	r4, [pc, #628]	; (80023e4 <prvChargerTask+0x2bc>)
        chargerWatchdogCount = 0;

/* Get the battery being charged, if any, from the switch settings.
These monitor task will set these to select the battery to charge. */
        uint8_t switchSettings = getSwitchControlBits();
        battery = (switchSettings >> 4) & 0x03;
 800216e:	f3c0 1101 	ubfx	r1, r0, #4, #2
/* If this is different to the battery currently under charge, change over. */
        if (battery != batteryUnderCharge)  /* Change of battery to charge */
 8002172:	7823      	ldrb	r3, [r4, #0]
 8002174:	428b      	cmp	r3, r1
 8002176:	d009      	beq.n	800218c <prvChargerTask+0x64>
        {
            batteryUnderCharge = battery;   /* Set new battery to charge */
 8002178:	7021      	strb	r1, [r4, #0]
            voltageAv[battery-1] = 0;
 800217a:	4a94      	ldr	r2, [pc, #592]	; (80023cc <prvChargerTask+0x2a4>)
            currentAv[battery-1] = 0;
 800217c:	4c94      	ldr	r4, [pc, #592]	; (80023d0 <prvChargerTask+0x2a8>)
        battery = (switchSettings >> 4) & 0x03;
/* If this is different to the battery currently under charge, change over. */
        if (battery != batteryUnderCharge)  /* Change of battery to charge */
        {
            batteryUnderCharge = battery;   /* Set new battery to charge */
            voltageAv[battery-1] = 0;
 800217e:	1e4d      	subs	r5, r1, #1
 8002180:	f822 6015 	strh.w	r6, [r2, r5, lsl #1]
            currentAv[battery-1] = 0;
 8002184:	f824 6015 	strh.w	r6, [r4, r5, lsl #1]
            dutyCycle = 50*256;
 8002188:	f44f 5548 	mov.w	r5, #12800	; 0x3200
        }

/* If a battery is allocated to a load, reset its charging phase to "bulk".
Only do this if it is not also under charge, as in such a case the charger may
be supplying the load current. */
        uint8_t batteryUnderLoad1 = switchSettings & 0x03;
 800218c:	f000 0603 	and.w	r6, r0, #3
        if (batteryUnderLoad1 != battery)
 8002190:	428e      	cmp	r6, r1
 8002192:	d004      	beq.n	800219e <prvChargerTask+0x76>
            batteryChargingPhase[batteryUnderLoad1-1] = bulkC;
 8002194:	4b8c      	ldr	r3, [pc, #560]	; (80023c8 <prvChargerTask+0x2a0>)
 8002196:	2200      	movs	r2, #0
 8002198:	199c      	adds	r4, r3, r6
 800219a:	f804 2c01 	strb.w	r2, [r4, #-1]
        uint8_t batteryUnderLoad2 = (switchSettings >> 2) & 0x03;
 800219e:	f3c0 0081 	ubfx	r0, r0, #2, #2
        if (batteryUnderLoad2 != battery)
 80021a2:	4288      	cmp	r0, r1
 80021a4:	d004      	beq.n	80021b0 <prvChargerTask+0x88>
            batteryChargingPhase[batteryUnderLoad2-1] = bulkC;
 80021a6:	4e88      	ldr	r6, [pc, #544]	; (80023c8 <prvChargerTask+0x2a0>)
 80021a8:	2300      	movs	r3, #0
 80021aa:	1834      	adds	r4, r6, r0
 80021ac:	f804 3c01 	strb.w	r3, [r4, #-1]

/* Compute the averaged voltages and currents to manage phase switchover.
Use first order exponential filters, separate coefficients. */
        if (battery > 0)
 80021b0:	2900      	cmp	r1, #0
 80021b2:	d0d2      	beq.n	800215a <prvChargerTask+0x32>
        {
            uint8_t index = battery-1;
 80021b4:	3901      	subs	r1, #1
            int16_t current = getBatteryCurrent(index)-getBatteryCurrentOffset(index);
 80021b6:	b2cc      	uxtb	r4, r1
 80021b8:	4620      	mov	r0, r4
 80021ba:	f001 f86b 	bl	8003294 <getBatteryCurrent>
 80021be:	4681      	mov	r9, r0
 80021c0:	4620      	mov	r0, r4
 80021c2:	f7ff ff6f 	bl	80020a4 <getBatteryCurrentOffset>
 80021c6:	ebc0 0209 	rsb	r2, r0, r9
            int16_t voltage = getBatteryVoltage(index);
 80021ca:	4620      	mov	r0, r4
/* Compute the averaged voltages and currents to manage phase switchover.
Use first order exponential filters, separate coefficients. */
        if (battery > 0)
        {
            uint8_t index = battery-1;
            int16_t current = getBatteryCurrent(index)-getBatteryCurrentOffset(index);
 80021cc:	fa1f f982 	uxth.w	r9, r2
            int16_t voltage = getBatteryVoltage(index);
 80021d0:	f001 f866 	bl	80032a0 <getBatteryVoltage>
/* Seed the filter with the most recent measurement (rather than zero) */
            if (voltageAv[index] == 0) voltageAv[index] = voltage;
 80021d4:	4e7d      	ldr	r6, [pc, #500]	; (80023cc <prvChargerTask+0x2a4>)
Use first order exponential filters, separate coefficients. */
        if (battery > 0)
        {
            uint8_t index = battery-1;
            int16_t current = getBatteryCurrent(index)-getBatteryCurrentOffset(index);
            int16_t voltage = getBatteryVoltage(index);
 80021d6:	4680      	mov	r8, r0
/* Seed the filter with the most recent measurement (rather than zero) */
            if (voltageAv[index] == 0) voltageAv[index] = voltage;
 80021d8:	f936 0014 	ldrsh.w	r0, [r6, r4, lsl #1]
 80021dc:	b908      	cbnz	r0, 80021e2 <prvChargerTask+0xba>
 80021de:	f826 8014 	strh.w	r8, [r6, r4, lsl #1]
            if (currentAv[index] == 0) currentAv[index] = current;
 80021e2:	4b7b      	ldr	r3, [pc, #492]	; (80023d0 <prvChargerTask+0x2a8>)
 80021e4:	f933 1014 	ldrsh.w	r1, [r3, r4, lsl #1]
 80021e8:	b909      	cbnz	r1, 80021ee <prvChargerTask+0xc6>
 80021ea:	f823 9014 	strh.w	r9, [r3, r4, lsl #1]
/* IIR filters with fairly short time constant */
            voltageAv[index] = voltageAv[index] +
 80021ee:	f836 a014 	ldrh.w	sl, [r6, r4, lsl #1]
                        ((getAlphaV()*(voltage - voltageAv[index]))>>8);
 80021f2:	f000 fe8f 	bl	8002f14 <getAlphaV>
 80021f6:	f936 2014 	ldrsh.w	r2, [r6, r4, lsl #1]
            currentAv[index] = currentAv[index] +
                        ((getAlphaC()*(current - currentAv[index]))>>8);
 80021fa:	fa0f f989 	sxth.w	r9, r9
/* Seed the filter with the most recent measurement (rather than zero) */
            if (voltageAv[index] == 0) voltageAv[index] = voltage;
            if (currentAv[index] == 0) currentAv[index] = current;
/* IIR filters with fairly short time constant */
            voltageAv[index] = voltageAv[index] +
                        ((getAlphaV()*(voltage - voltageAv[index]))>>8);
 80021fe:	ebc2 0c08 	rsb	ip, r2, r8
 8002202:	fb0c f000 	mul.w	r0, ip, r0
            int16_t voltage = getBatteryVoltage(index);
/* Seed the filter with the most recent measurement (rather than zero) */
            if (voltageAv[index] == 0) voltageAv[index] = voltage;
            if (currentAv[index] == 0) currentAv[index] = current;
/* IIR filters with fairly short time constant */
            voltageAv[index] = voltageAv[index] +
 8002206:	eb0a 2320 	add.w	r3, sl, r0, asr #8
 800220a:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
                        ((getAlphaV()*(voltage - voltageAv[index]))>>8);
            currentAv[index] = currentAv[index] +
 800220e:	4e70      	ldr	r6, [pc, #448]	; (80023d0 <prvChargerTask+0x2a8>)
 8002210:	f836 8014 	ldrh.w	r8, [r6, r4, lsl #1]
                        ((getAlphaC()*(current - currentAv[index]))>>8);
 8002214:	f000 fe84 	bl	8002f20 <getAlphaC>
 8002218:	f936 1014 	ldrsh.w	r1, [r6, r4, lsl #1]

/* Manage the float phase voltage limit. */
            if (batteryChargingPhase[index] == floatC)
 800221c:	4b6a      	ldr	r3, [pc, #424]	; (80023c8 <prvChargerTask+0x2a0>)
            if (currentAv[index] == 0) currentAv[index] = current;
/* IIR filters with fairly short time constant */
            voltageAv[index] = voltageAv[index] +
                        ((getAlphaV()*(voltage - voltageAv[index]))>>8);
            currentAv[index] = currentAv[index] +
                        ((getAlphaC()*(current - currentAv[index]))>>8);
 800221e:	ebc1 0209 	rsb	r2, r1, r9
 8002222:	4350      	muls	r0, r2
            if (voltageAv[index] == 0) voltageAv[index] = voltage;
            if (currentAv[index] == 0) currentAv[index] = current;
/* IIR filters with fairly short time constant */
            voltageAv[index] = voltageAv[index] +
                        ((getAlphaV()*(voltage - voltageAv[index]))>>8);
            currentAv[index] = currentAv[index] +
 8002224:	eb08 2020 	add.w	r0, r8, r0, asr #8
 8002228:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
                        ((getAlphaC()*(current - currentAv[index]))>>8);

/* Manage the float phase voltage limit. */
            if (batteryChargingPhase[index] == floatC)
 800222c:	5d1e      	ldrb	r6, [r3, r4]
 800222e:	2e02      	cmp	r6, #2
 8002230:	d119      	bne.n	8002266 <prvChargerTask+0x13e>
                adaptDutyCycle(voltageAv[index],getFloatVoltage(index),&dutyCycle);
 8002232:	4966      	ldr	r1, [pc, #408]	; (80023cc <prvChargerTask+0x2a4>)
 8002234:	4620      	mov	r0, r4
 8002236:	f831 a014 	ldrh.w	sl, [r1, r4, lsl #1]
 800223a:	f000 fe63 	bl	8002f04 <getFloatVoltage>
 800223e:	4606      	mov	r6, r0
Based on an heuristic measure from battery data.
*/

static int16_t voltageLimit(uint16_t limitV)
{
    int32_t voltageOffset = (1984*(6835-getTemperature())) >> 16;
 8002240:	f001 f85a 	bl	80032f8 <getTemperature>
 8002244:	4b68      	ldr	r3, [pc, #416]	; (80023e8 <prvChargerTask+0x2c0>)
 8002246:	4969      	ldr	r1, [pc, #420]	; (80023ec <prvChargerTask+0x2c4>)
 8002248:	4358      	muls	r0, r3
    return limitV + voltageOffset;
 800224a:	ebc6 020a 	rsb	r2, r6, sl
Based on an heuristic measure from battery data.
*/

static int16_t voltageLimit(uint16_t limitV)
{
    int32_t voltageOffset = (1984*(6835-getTemperature())) >> 16;
 800224e:	1840      	adds	r0, r0, r1

static void adaptDutyCycle(int16_t voltage, int16_t vLimit, uint16_t* dutyCycle)
{
    uint32_t newDutyCycle = *dutyCycle;
    int16_t vLimitAdjusted = voltageLimit(vLimit);
    int16_t voltageDiff = (voltage - vLimitAdjusted);
 8002250:	eba2 4620 	sub.w	r6, r2, r0, asr #16
    if (voltageDiff > 0)
 8002254:	b232      	sxth	r2, r6
 8002256:	2a00      	cmp	r2, #0
 8002258:	dd01      	ble.n	800225e <prvChargerTask+0x136>
    {
/* Speed up the return to the voltage limit as the difference is greater */
/*        newDutyCycle = (newDutyCycle*((vLimitAdjusted-11*256)*115)/(voltage-11*256))>>7;*/
        newDutyCycle = (newDutyCycle*115)>>7;
 800225a:	2373      	movs	r3, #115	; 0x73
 800225c:	e000      	b.n	8002260 <prvChargerTask+0x138>
    }
    else
    {
/* Increase by about 9% */
        newDutyCycle = (newDutyCycle*140)>>7;
 800225e:	238c      	movs	r3, #140	; 0x8c
 8002260:	435d      	muls	r5, r3
 8002262:	09ed      	lsrs	r5, r5, #7
    }
    *dutyCycle = newDutyCycle;
 8002264:	b2ad      	uxth	r5, r5
/* Manage the float phase voltage limit. */
            if (batteryChargingPhase[index] == floatC)
                adaptDutyCycle(voltageAv[index],getFloatVoltage(index),&dutyCycle);

/* Manage the absorption phase voltage limit. */
            adaptDutyCycle(voltageAv[index],getAbsorptionVoltage(index),&dutyCycle);
 8002266:	4e59      	ldr	r6, [pc, #356]	; (80023cc <prvChargerTask+0x2a4>)
 8002268:	4620      	mov	r0, r4
 800226a:	f836 a014 	ldrh.w	sl, [r6, r4, lsl #1]
 800226e:	f000 fe41 	bl	8002ef4 <getAbsorptionVoltage>
 8002272:	4680      	mov	r8, r0
Based on an heuristic measure from battery data.
*/

static int16_t voltageLimit(uint16_t limitV)
{
    int32_t voltageOffset = (1984*(6835-getTemperature())) >> 16;
 8002274:	f001 f840 	bl	80032f8 <getTemperature>
 8002278:	4a5b      	ldr	r2, [pc, #364]	; (80023e8 <prvChargerTask+0x2c0>)
 800227a:	4b5c      	ldr	r3, [pc, #368]	; (80023ec <prvChargerTask+0x2c4>)
 800227c:	4350      	muls	r0, r2
    return limitV + voltageOffset;
 800227e:	ebc8 010a 	rsb	r1, r8, sl
Based on an heuristic measure from battery data.
*/

static int16_t voltageLimit(uint16_t limitV)
{
    int32_t voltageOffset = (1984*(6835-getTemperature())) >> 16;
 8002282:	18c0      	adds	r0, r0, r3

static void adaptDutyCycle(int16_t voltage, int16_t vLimit, uint16_t* dutyCycle)
{
    uint32_t newDutyCycle = *dutyCycle;
    int16_t vLimitAdjusted = voltageLimit(vLimit);
    int16_t voltageDiff = (voltage - vLimitAdjusted);
 8002284:	eba1 4c20 	sub.w	ip, r1, r0, asr #16
    if (voltageDiff > 0)
 8002288:	fa0f fa8c 	sxth.w	sl, ip
 800228c:	f1ba 0f00 	cmp.w	sl, #0
 8002290:	dd01      	ble.n	8002296 <prvChargerTask+0x16e>
    {
/* Speed up the return to the voltage limit as the difference is greater */
/*        newDutyCycle = (newDutyCycle*((vLimitAdjusted-11*256)*115)/(voltage-11*256))>>7;*/
        newDutyCycle = (newDutyCycle*115)>>7;
 8002292:	2173      	movs	r1, #115	; 0x73
 8002294:	e000      	b.n	8002298 <prvChargerTask+0x170>
    }
    else
    {
/* Increase by about 9% */
        newDutyCycle = (newDutyCycle*140)>>7;
 8002296:	218c      	movs	r1, #140	; 0x8c

/* Manage the absorption phase voltage limit. */
            adaptDutyCycle(voltageAv[index],getAbsorptionVoltage(index),&dutyCycle);

/* Manage the change from bulk to absorption phase. */
            if (voltageAv[index] > voltageLimit(getAbsorptionVoltage(index)))
 8002298:	4620      	mov	r0, r4
        newDutyCycle = (newDutyCycle*115)>>7;
    }
    else
    {
/* Increase by about 9% */
        newDutyCycle = (newDutyCycle*140)>>7;
 800229a:	434d      	muls	r5, r1

/* Manage the absorption phase voltage limit. */
            adaptDutyCycle(voltageAv[index],getAbsorptionVoltage(index),&dutyCycle);

/* Manage the change from bulk to absorption phase. */
            if (voltageAv[index] > voltageLimit(getAbsorptionVoltage(index)))
 800229c:	f836 6014 	ldrh.w	r6, [r6, r4, lsl #1]
 80022a0:	f000 fe28 	bl	8002ef4 <getAbsorptionVoltage>
 80022a4:	4680      	mov	r8, r0
Based on an heuristic measure from battery data.
*/

static int16_t voltageLimit(uint16_t limitV)
{
    int32_t voltageOffset = (1984*(6835-getTemperature())) >> 16;
 80022a6:	f001 f827 	bl	80032f8 <getTemperature>
 80022aa:	4a4f      	ldr	r2, [pc, #316]	; (80023e8 <prvChargerTask+0x2c0>)
 80022ac:	4b4f      	ldr	r3, [pc, #316]	; (80023ec <prvChargerTask+0x2c4>)
 80022ae:	4350      	muls	r0, r2
 80022b0:	18c0      	adds	r0, r0, r3
    return limitV + voltageOffset;
 80022b2:	eb08 4120 	add.w	r1, r8, r0, asr #16

/* Manage the absorption phase voltage limit. */
            adaptDutyCycle(voltageAv[index],getAbsorptionVoltage(index),&dutyCycle);

/* Manage the change from bulk to absorption phase. */
            if (voltageAv[index] > voltageLimit(getAbsorptionVoltage(index)))
 80022b6:	b236      	sxth	r6, r6
 80022b8:	b20a      	sxth	r2, r1
        newDutyCycle = (newDutyCycle*115)>>7;
    }
    else
    {
/* Increase by about 9% */
        newDutyCycle = (newDutyCycle*140)>>7;
 80022ba:	09ed      	lsrs	r5, r5, #7

/* Manage the absorption phase voltage limit. */
            adaptDutyCycle(voltageAv[index],getAbsorptionVoltage(index),&dutyCycle);

/* Manage the change from bulk to absorption phase. */
            if (voltageAv[index] > voltageLimit(getAbsorptionVoltage(index)))
 80022bc:	4296      	cmp	r6, r2
    else
    {
/* Increase by about 9% */
        newDutyCycle = (newDutyCycle*140)>>7;
    }
    *dutyCycle = newDutyCycle;
 80022be:	b2ad      	uxth	r5, r5
 80022c0:	4b41      	ldr	r3, [pc, #260]	; (80023c8 <prvChargerTask+0x2a0>)

/* Manage the absorption phase voltage limit. */
            adaptDutyCycle(voltageAv[index],getAbsorptionVoltage(index),&dutyCycle);

/* Manage the change from bulk to absorption phase. */
            if (voltageAv[index] > voltageLimit(getAbsorptionVoltage(index)))
 80022c2:	dd01      	ble.n	80022c8 <prvChargerTask+0x1a0>
                batteryChargingPhase[index] = absorptionC;  /* Change. */
 80022c4:	2001      	movs	r0, #1
 80022c6:	5518      	strb	r0, [r3, r4]

/* Check that battery doesn't remain too long in absorption phase while the
current is not falling (within a 5% error). 0.5 hour max. Then go to float. */
            if (batteryChargingPhase[index] == absorptionC)
 80022c8:	5d19      	ldrb	r1, [r3, r4]
 80022ca:	2901      	cmp	r1, #1
 80022cc:	d12b      	bne.n	8002326 <prvChargerTask+0x1fe>
            {
                if (((absorptionPhaseCurrent[index]*240)/256 < currentAv[index]))
 80022ce:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80023d8 <prvChargerTask+0x2b0>
 80022d2:	20f0      	movs	r0, #240	; 0xf0
 80022d4:	f938 2014 	ldrsh.w	r2, [r8, r4, lsl #1]
 80022d8:	4e3d      	ldr	r6, [pc, #244]	; (80023d0 <prvChargerTask+0x2a8>)
 80022da:	4350      	muls	r0, r2
 80022dc:	f836 3014 	ldrh.w	r3, [r6, r4, lsl #1]
 80022e0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80022e4:	fb90 f6f1 	sdiv	r6, r0, r1
 80022e8:	b21a      	sxth	r2, r3
 80022ea:	4296      	cmp	r6, r2
 80022ec:	4e39      	ldr	r6, [pc, #228]	; (80023d4 <prvChargerTask+0x2ac>)
 80022ee:	da15      	bge.n	800231c <prvChargerTask+0x1f4>
                {
                    absorptionPhaseTime[index]++;
 80022f0:	f836 e014 	ldrh.w	lr, [r6, r4, lsl #1]
 80022f4:	f10e 0c01 	add.w	ip, lr, #1
 80022f8:	fa1f fa8c 	uxth.w	sl, ip
 80022fc:	f826 a014 	strh.w	sl, [r6, r4, lsl #1]
                    if (absorptionPhaseTime[index] > 1800000/getChargerDelay())
 8002300:	f000 fe30 	bl	8002f64 <getChargerDelay>
 8002304:	4b3a      	ldr	r3, [pc, #232]	; (80023f0 <prvChargerTask+0x2c8>)
 8002306:	fbb3 f1f0 	udiv	r1, r3, r0
 800230a:	458a      	cmp	sl, r1
 800230c:	d90b      	bls.n	8002326 <prvChargerTask+0x1fe>
                    {
                        batteryChargingPhase[index] = floatC;
 800230e:	482e      	ldr	r0, [pc, #184]	; (80023c8 <prvChargerTask+0x2a0>)
 8002310:	2202      	movs	r2, #2
                        absorptionPhaseTime[index] = 0;
 8002312:	2300      	movs	r3, #0
                if (((absorptionPhaseCurrent[index]*240)/256 < currentAv[index]))
                {
                    absorptionPhaseTime[index]++;
                    if (absorptionPhaseTime[index] > 1800000/getChargerDelay())
                    {
                        batteryChargingPhase[index] = floatC;
 8002314:	5502      	strb	r2, [r0, r4]
                        absorptionPhaseTime[index] = 0;
 8002316:	f826 3014 	strh.w	r3, [r6, r4, lsl #1]
 800231a:	e002      	b.n	8002322 <prvChargerTask+0x1fa>
                        absorptionPhaseCurrent[index] = 0;
                    }
                }
                else
                {
                    absorptionPhaseTime[index] = 0;
 800231c:	2000      	movs	r0, #0
 800231e:	f826 0014 	strh.w	r0, [r6, r4, lsl #1]
                    absorptionPhaseCurrent[index] = currentAv[index];
 8002322:	f828 3014 	strh.w	r3, [r8, r4, lsl #1]
            }

/* Manage the change to float phase when the current drops below the float
threshold. This is done on the averaged current as rapid response is not
essential. (Note: measured currents are negative while charging). */
            if ((batteryChargingPhase[index] == absorptionC) &&
 8002326:	4e28      	ldr	r6, [pc, #160]	; (80023c8 <prvChargerTask+0x2a0>)
 8002328:	5d33      	ldrb	r3, [r6, r4]
 800232a:	2b01      	cmp	r3, #1
 800232c:	d10b      	bne.n	8002346 <prvChargerTask+0x21e>
                (-currentAv[index] < getFloatStageCurrent(index)))
 800232e:	4928      	ldr	r1, [pc, #160]	; (80023d0 <prvChargerTask+0x2a8>)
 8002330:	4620      	mov	r0, r4
 8002332:	f931 8014 	ldrsh.w	r8, [r1, r4, lsl #1]
 8002336:	f000 fdcf 	bl	8002ed8 <getFloatStageCurrent>
 800233a:	f1c8 0a00 	rsb	sl, r8, #0
            }

/* Manage the change to float phase when the current drops below the float
threshold. This is done on the averaged current as rapid response is not
essential. (Note: measured currents are negative while charging). */
            if ((batteryChargingPhase[index] == absorptionC) &&
 800233e:	4582      	cmp	sl, r0
 8002340:	da01      	bge.n	8002346 <prvChargerTask+0x21e>
                (-currentAv[index] < getFloatStageCurrent(index)))
                batteryChargingPhase[index] = floatC;
 8002342:	2202      	movs	r2, #2
 8002344:	5532      	strb	r2, [r6, r4]

/* Manage the change to bulk phase when the terminal voltage drops below the
absorption threshold, and the duty cycle reaches 100%. */
            if ((batteryChargingPhase[index] == absorptionC) &&
 8002346:	4e20      	ldr	r6, [pc, #128]	; (80023c8 <prvChargerTask+0x2a0>)
 8002348:	5d30      	ldrb	r0, [r6, r4]
 800234a:	2801      	cmp	r0, #1
 800234c:	d117      	bne.n	800237e <prvChargerTask+0x256>
                (voltageAv[index] < voltageLimit(getAbsorptionVoltage(index))) &&
 800234e:	4b1f      	ldr	r3, [pc, #124]	; (80023cc <prvChargerTask+0x2a4>)
 8002350:	4620      	mov	r0, r4
 8002352:	f833 8014 	ldrh.w	r8, [r3, r4, lsl #1]
 8002356:	f000 fdcd 	bl	8002ef4 <getAbsorptionVoltage>
 800235a:	4682      	mov	sl, r0
Based on an heuristic measure from battery data.
*/

static int16_t voltageLimit(uint16_t limitV)
{
    int32_t voltageOffset = (1984*(6835-getTemperature())) >> 16;
 800235c:	f000 ffcc 	bl	80032f8 <getTemperature>
 8002360:	4921      	ldr	r1, [pc, #132]	; (80023e8 <prvChargerTask+0x2c0>)
 8002362:	4a22      	ldr	r2, [pc, #136]	; (80023ec <prvChargerTask+0x2c4>)
 8002364:	4348      	muls	r0, r1
 8002366:	1880      	adds	r0, r0, r2
    return limitV + voltageOffset;
 8002368:	eb0a 4320 	add.w	r3, sl, r0, asr #16
                (-currentAv[index] < getFloatStageCurrent(index)))
                batteryChargingPhase[index] = floatC;

/* Manage the change to bulk phase when the terminal voltage drops below the
absorption threshold, and the duty cycle reaches 100%. */
            if ((batteryChargingPhase[index] == absorptionC) &&
 800236c:	fa0f fc88 	sxth.w	ip, r8
 8002370:	b219      	sxth	r1, r3
 8002372:	458c      	cmp	ip, r1
 8002374:	da03      	bge.n	800237e <prvChargerTask+0x256>
                (voltageAv[index] < voltageLimit(getAbsorptionVoltage(index))) &&
 8002376:	42bd      	cmp	r5, r7
 8002378:	d101      	bne.n	800237e <prvChargerTask+0x256>
                (dutyCycle == dutyCycleMax))
                batteryChargingPhase[index] = bulkC;
 800237a:	2700      	movs	r7, #0
 800237c:	5537      	strb	r7, [r6, r4]
then if the peak is greater than the battery's current limit, reduce the
maximum duty cycle. Limit the duty cycle to this.
This is done on the directly measured current for rapid response. */
            if (dutyCycle < MIN_DUTYCYCLE) dutyCycle = MIN_DUTYCYCLE;
            int32_t currentPeak = -((int32_t)current*100)/dutyCycle;
            if (currentPeak > getBulkCurrentLimit(index))
 800237e:	4620      	mov	r0, r4
 8002380:	f000 fd9a 	bl	8002eb8 <getBulkCurrentLimit>
Compute the peak current from duty cycle (assumes current goes from 0 to a peak)
then if the peak is greater than the battery's current limit, reduce the
maximum duty cycle. Limit the duty cycle to this.
This is done on the directly measured current for rapid response. */
            if (dutyCycle < MIN_DUTYCYCLE) dutyCycle = MIN_DUTYCYCLE;
            int32_t currentPeak = -((int32_t)current*100)/dutyCycle;
 8002384:	f06f 0663 	mvn.w	r6, #99	; 0x63
 8002388:	fb06 f909 	mul.w	r9, r6, r9
/* Overcurrent protection:
Compute the peak current from duty cycle (assumes current goes from 0 to a peak)
then if the peak is greater than the battery's current limit, reduce the
maximum duty cycle. Limit the duty cycle to this.
This is done on the directly measured current for rapid response. */
            if (dutyCycle < MIN_DUTYCYCLE) dutyCycle = MIN_DUTYCYCLE;
 800238c:	2dff      	cmp	r5, #255	; 0xff
 800238e:	bf98      	it	ls
 8002390:	f44f 7580 	movls.w	r5, #256	; 0x100
            int32_t currentPeak = -((int32_t)current*100)/dutyCycle;
 8002394:	fb99 f7f5 	sdiv	r7, r9, r5
            if (currentPeak > getBulkCurrentLimit(index))
 8002398:	4287      	cmp	r7, r0
 800239a:	dd07      	ble.n	80023ac <prvChargerTask+0x284>
                dutyCycleMax = getBulkCurrentLimit(index)*256/currentPeak;
 800239c:	4620      	mov	r0, r4
 800239e:	f000 fd8b 	bl	8002eb8 <getBulkCurrentLimit>
 80023a2:	0204      	lsls	r4, r0, #8
 80023a4:	fb94 f2f7 	sdiv	r2, r4, r7
 80023a8:	b297      	uxth	r7, r2
 80023aa:	e001      	b.n	80023b0 <prvChargerTask+0x288>
            else dutyCycleMax = 100*256;
 80023ac:	f44f 47c8 	mov.w	r7, #25600	; 0x6400

/* Set the duty cycle. */
/* Never let duty cycle go near zero else it will not recover. Set to a value
that will allow it to grow again if needed (round-off error problem). */
            if (dutyCycle < MIN_DUTYCYCLE) dutyCycle = MIN_DUTYCYCLE;
 80023b0:	2dff      	cmp	r5, #255	; 0xff
 80023b2:	bf98      	it	ls
 80023b4:	f44f 7580 	movls.w	r5, #256	; 0x100
 80023b8:	42bd      	cmp	r5, r7
 80023ba:	bf28      	it	cs
 80023bc:	463d      	movcs	r5, r7
            if (dutyCycle > dutyCycleMax) dutyCycle = dutyCycleMax;
            pwmSetDutyCycle(dutyCycle);
 80023be:	4628      	mov	r0, r5
 80023c0:	f000 f95e 	bl	8002680 <pwmSetDutyCycle>
 80023c4:	e6c9      	b.n	800215a <prvChargerTask+0x32>
 80023c6:	bf00      	nop
 80023c8:	20000876 	.word	0x20000876
 80023cc:	20000868 	.word	0x20000868
 80023d0:	20000862 	.word	0x20000862
 80023d4:	2000086e 	.word	0x2000086e
 80023d8:	2000087a 	.word	0x2000087a
 80023dc:	2000085c 	.word	0x2000085c
 80023e0:	20000874 	.word	0x20000874
 80023e4:	20000875 	.word	0x20000875
 80023e8:	fffff840 	.word	0xfffff840
 80023ec:	00ceeb40 	.word	0x00ceeb40
 80023f0:	001b7740 	.word	0x001b7740

080023f4 <getBatteryChargingPhase>:
*/

battery_Ch_States getBatteryChargingPhase(int battery)
{
    return batteryChargingPhase[battery];
}
 80023f4:	4b01      	ldr	r3, [pc, #4]	; (80023fc <getBatteryChargingPhase+0x8>)
 80023f6:	5c18      	ldrb	r0, [r3, r0]
 80023f8:	4770      	bx	lr
 80023fa:	bf00      	nop
 80023fc:	20000876 	.word	0x20000876

08002400 <checkChargerWatchdog>:

The watchdog counter is decremented. If it reaches zero then the task is reset.
*/

void checkChargerWatchdog(void)
{
 8002400:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    if (chargerWatchdogCount++ > 10*getChargerDelay()/getWatchdogDelay())
 8002402:	4d15      	ldr	r5, [pc, #84]	; (8002458 <checkChargerWatchdog+0x58>)
 8002404:	782c      	ldrb	r4, [r5, #0]
 8002406:	f000 fdad 	bl	8002f64 <getChargerDelay>
 800240a:	4606      	mov	r6, r0
 800240c:	f000 fda4 	bl	8002f58 <getWatchdogDelay>
 8002410:	210a      	movs	r1, #10
 8002412:	4371      	muls	r1, r6
 8002414:	fbb1 f0f0 	udiv	r0, r1, r0
 8002418:	1c63      	adds	r3, r4, #1
 800241a:	4284      	cmp	r4, r0
 800241c:	702b      	strb	r3, [r5, #0]
 800241e:	d918      	bls.n	8002452 <checkChargerWatchdog+0x52>
    {
        vTaskDelete(prvChargerTask);
 8002420:	480e      	ldr	r0, [pc, #56]	; (800245c <checkChargerWatchdog+0x5c>)
 8002422:	f003 f823 	bl	800546c <vTaskDelete>
	    xTaskCreate(prvChargerTask, (signed portCHAR * ) "Charger", \
 8002426:	2300      	movs	r3, #0
 8002428:	2201      	movs	r2, #1
 800242a:	9200      	str	r2, [sp, #0]
 800242c:	9301      	str	r3, [sp, #4]
 800242e:	9302      	str	r3, [sp, #8]
 8002430:	9303      	str	r3, [sp, #12]
 8002432:	2280      	movs	r2, #128	; 0x80
 8002434:	490a      	ldr	r1, [pc, #40]	; (8002460 <checkChargerWatchdog+0x60>)
 8002436:	4809      	ldr	r0, [pc, #36]	; (800245c <checkChargerWatchdog+0x5c>)
 8002438:	f002 ff52 	bl	80052e0 <xTaskGenericCreate>
                    configMINIMAL_STACK_SIZE, NULL, CHARGER_TASK_PRIORITY, NULL);
        sendStringLowPriority("D","Charger Restarted");
 800243c:	4809      	ldr	r0, [pc, #36]	; (8002464 <checkChargerWatchdog+0x64>)
 800243e:	490a      	ldr	r1, [pc, #40]	; (8002468 <checkChargerWatchdog+0x68>)
 8002440:	f7fd ff72 	bl	8000328 <sendStringLowPriority>
        recordString("D","Charger Restarted");
 8002444:	4807      	ldr	r0, [pc, #28]	; (8002464 <checkChargerWatchdog+0x64>)
 8002446:	4908      	ldr	r1, [pc, #32]	; (8002468 <checkChargerWatchdog+0x68>)
    }
}
 8002448:	b004      	add	sp, #16
 800244a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    {
        vTaskDelete(prvChargerTask);
	    xTaskCreate(prvChargerTask, (signed portCHAR * ) "Charger", \
                    configMINIMAL_STACK_SIZE, NULL, CHARGER_TASK_PRIORITY, NULL);
        sendStringLowPriority("D","Charger Restarted");
        recordString("D","Charger Restarted");
 800244e:	f7fe bff5 	b.w	800143c <recordString>
    }
}
 8002452:	b004      	add	sp, #16
 8002454:	bd70      	pop	{r4, r5, r6, pc}
 8002456:	bf00      	nop
 8002458:	20000874 	.word	0x20000874
 800245c:	08002129 	.word	0x08002129
 8002460:	080074bd 	.word	0x080074bd
 8002464:	080074e2 	.word	0x080074e2
 8002468:	08007543 	.word	0x08007543

0800246c <dmaAdcSetup>:
time, and we need to grab it before the next conversions start. This must be
called after each transfer to reset the memory buffer to the beginning.
*/

static void dmaAdcSetup(void)
{
 800246c:	b510      	push	{r4, lr}
	/* Enable DMA1 Clock */
    rcc_periph_clock_enable(RCC_DMA1);
	dma_channel_reset(DMA1,DMA_CHANNEL1);
 800246e:	4c1b      	ldr	r4, [pc, #108]	; (80024dc <dmaAdcSetup+0x70>)
*/

static void dmaAdcSetup(void)
{
	/* Enable DMA1 Clock */
    rcc_periph_clock_enable(RCC_DMA1);
 8002470:	f44f 7020 	mov.w	r0, #640	; 0x280
 8002474:	f004 ff40 	bl	80072f8 <rcc_periph_clock_enable>
	dma_channel_reset(DMA1,DMA_CHANNEL1);
 8002478:	4620      	mov	r0, r4
 800247a:	2101      	movs	r1, #1
 800247c:	f004 fc3e 	bl	8006cfc <dma_channel_reset>
	dma_set_priority(DMA1,DMA_CHANNEL1,DMA_CCR_PL_LOW);
 8002480:	4620      	mov	r0, r4
 8002482:	2101      	movs	r1, #1
 8002484:	2200      	movs	r2, #0
 8002486:	f004 fc4a 	bl	8006d1e <dma_set_priority>
/* We want all 32 bits from the ADC to include ADC2 data */
	dma_set_memory_size(DMA1,DMA_CHANNEL1,DMA_CCR_MSIZE_32BIT);
 800248a:	4620      	mov	r0, r4
 800248c:	2101      	movs	r1, #1
 800248e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8002492:	f004 fc50 	bl	8006d36 <dma_set_memory_size>
	dma_set_peripheral_size(DMA1,DMA_CHANNEL1,DMA_CCR_PSIZE_32BIT);
 8002496:	f44f 7200 	mov.w	r2, #512	; 0x200
 800249a:	4620      	mov	r0, r4
 800249c:	2101      	movs	r1, #1
 800249e:	f004 fc56 	bl	8006d4e <dma_set_peripheral_size>
	dma_enable_memory_increment_mode(DMA1,DMA_CHANNEL1);
 80024a2:	4620      	mov	r0, r4
 80024a4:	2101      	movs	r1, #1
 80024a6:	f004 fc5e 	bl	8006d66 <dma_enable_memory_increment_mode>
	dma_set_read_from_peripheral(DMA1,DMA_CHANNEL1);
 80024aa:	4620      	mov	r0, r4
 80024ac:	2101      	movs	r1, #1
 80024ae:	f004 fc63 	bl	8006d78 <dma_set_read_from_peripheral>
/* The register to target is the ADC1 regular data register */
	dma_set_peripheral_address(DMA1,DMA_CHANNEL1,(uint32_t) &ADC_DR(ADC1));
 80024b2:	4620      	mov	r0, r4
 80024b4:	2101      	movs	r1, #1
 80024b6:	4a0a      	ldr	r2, [pc, #40]	; (80024e0 <dmaAdcSetup+0x74>)
 80024b8:	f004 fc70 	bl	8006d9c <dma_set_peripheral_address>
/* The array v[] receives the converted output */
	dma_set_memory_address(DMA1,DMA_CHANNEL1,(uint32_t) v);
 80024bc:	4620      	mov	r0, r4
 80024be:	2101      	movs	r1, #1
 80024c0:	4a08      	ldr	r2, [pc, #32]	; (80024e4 <dmaAdcSetup+0x78>)
 80024c2:	f004 fc74 	bl	8006dae <dma_set_memory_address>
	dma_set_number_of_data(DMA1,DMA_CHANNEL1,NUM_CHANNEL);
 80024c6:	4620      	mov	r0, r4
 80024c8:	2101      	movs	r1, #1
 80024ca:	2210      	movs	r2, #16
 80024cc:	f004 fc78 	bl	8006dc0 <dma_set_number_of_data>
	dma_enable_channel(DMA1,DMA_CHANNEL1);
 80024d0:	4620      	mov	r0, r4
 80024d2:	2101      	movs	r1, #1
}
 80024d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
/* The register to target is the ADC1 regular data register */
	dma_set_peripheral_address(DMA1,DMA_CHANNEL1,(uint32_t) &ADC_DR(ADC1));
/* The array v[] receives the converted output */
	dma_set_memory_address(DMA1,DMA_CHANNEL1,(uint32_t) v);
	dma_set_number_of_data(DMA1,DMA_CHANNEL1,NUM_CHANNEL);
	dma_enable_channel(DMA1,DMA_CHANNEL1);
 80024d8:	f004 bc57 	b.w	8006d8a <dma_enable_channel>
 80024dc:	40020000 	.word	0x40020000
 80024e0:	4001244c 	.word	0x4001244c
 80024e4:	20000884 	.word	0x20000884

080024e8 <adcValue>:
@returns uint32_t : last value measured by the A/D converter.
*/

uint32_t adcValue(uint8_t channel)
{
    if (channel > NUM_CHANNEL) return 0;
 80024e8:	2810      	cmp	r0, #16
 80024ea:	d803      	bhi.n	80024f4 <adcValue+0xc>
    return v[channel];
 80024ec:	4b02      	ldr	r3, [pc, #8]	; (80024f8 <adcValue+0x10>)
 80024ee:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80024f2:	4770      	bx	lr
@returns uint32_t : last value measured by the A/D converter.
*/

uint32_t adcValue(uint8_t channel)
{
    if (channel > NUM_CHANNEL) return 0;
 80024f4:	2000      	movs	r0, #0
    return v[channel];
}
 80024f6:	4770      	bx	lr
 80024f8:	20000884 	.word	0x20000884

080024fc <adcEOC>:
@returns uint8_t: boolean true if the flag was set; false otherwise.
*/

uint8_t adcEOC(void)
{
    if (adceoc > 0)
 80024fc:	4b03      	ldr	r3, [pc, #12]	; (800250c <adcEOC+0x10>)
 80024fe:	7818      	ldrb	r0, [r3, #0]
 8002500:	b110      	cbz	r0, 8002508 <adcEOC+0xc>
    {
        adceoc = 0;
 8002502:	2200      	movs	r2, #0
 8002504:	701a      	strb	r2, [r3, #0]
        return 1;
 8002506:	2001      	movs	r0, #1
    }
    return 0;
}
 8002508:	4770      	bx	lr
 800250a:	bf00      	nop
 800250c:	20000880 	.word	0x20000880

08002510 <getIndicators>:

@returns uint16_t
*/

uint16_t getIndicators(void)
{
 8002510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint16_t indicators = 0;
    indicators |= ((gpio_port_read(BATTERY1_STATUS_PORT) >> 
 8002512:	4c15      	ldr	r4, [pc, #84]	; (8002568 <getIndicators+0x58>)
 8002514:	4620      	mov	r0, r4
 8002516:	f004 fc5e 	bl	8006dd6 <gpio_port_read>
 800251a:	4607      	mov	r7, r0
                                    BATTERY1_STATUS_SHIFT) & 0x03) << 0;
    indicators |= ((gpio_port_read(BATTERY2_STATUS_PORT) >> 
 800251c:	4813      	ldr	r0, [pc, #76]	; (800256c <getIndicators+0x5c>)
 800251e:	f004 fc5a 	bl	8006dd6 <gpio_port_read>
 8002522:	4606      	mov	r6, r0
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
 8002524:	4620      	mov	r0, r4
 8002526:	f004 fc56 	bl	8006dd6 <gpio_port_read>
{
    uint16_t indicators = 0;
    indicators |= ((gpio_port_read(BATTERY1_STATUS_PORT) >> 
                                    BATTERY1_STATUS_SHIFT) & 0x03) << 0;
    indicators |= ((gpio_port_read(BATTERY2_STATUS_PORT) >> 
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
 800252a:	f3c6 21c1 	ubfx	r1, r6, #11, #2
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
                                    BATTERY3_STATUS_SHIFT) & 0x03) << 4;
 800252e:	f000 0030 	and.w	r0, r0, #48	; 0x30
uint16_t getIndicators(void)
{
    uint16_t indicators = 0;
    indicators |= ((gpio_port_read(BATTERY1_STATUS_PORT) >> 
                                    BATTERY1_STATUS_SHIFT) & 0x03) << 0;
    indicators |= ((gpio_port_read(BATTERY2_STATUS_PORT) >> 
 8002532:	ea40 0681 	orr.w	r6, r0, r1, lsl #2
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
                                    BATTERY3_STATUS_SHIFT) & 0x03) << 4;
    indicators |= ((gpio_port_read(LOAD1_STATUS_PORT) >> 
 8002536:	4620      	mov	r0, r4
 8002538:	f004 fc4d 	bl	8006dd6 <gpio_port_read>
                                    LOAD1_STATUS_SHIFT) & 0x03) << 6;
 800253c:	0882      	lsrs	r2, r0, #2
    indicators |= ((gpio_port_read(LOAD2_STATUS_PORT) >> 
 800253e:	4620      	mov	r0, r4
                                    BATTERY1_STATUS_SHIFT) & 0x03) << 0;
    indicators |= ((gpio_port_read(BATTERY2_STATUS_PORT) >> 
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
                                    BATTERY3_STATUS_SHIFT) & 0x03) << 4;
    indicators |= ((gpio_port_read(LOAD1_STATUS_PORT) >> 
 8002540:	f002 05c0 	and.w	r5, r2, #192	; 0xc0
                                    LOAD1_STATUS_SHIFT) & 0x03) << 6;
    indicators |= ((gpio_port_read(LOAD2_STATUS_PORT) >> 
 8002544:	f004 fc47 	bl	8006dd6 <gpio_port_read>
*/

uint16_t getIndicators(void)
{
    uint16_t indicators = 0;
    indicators |= ((gpio_port_read(BATTERY1_STATUS_PORT) >> 
 8002548:	f007 0703 	and.w	r7, r7, #3
                                    BATTERY1_STATUS_SHIFT) & 0x03) << 0;
    indicators |= ((gpio_port_read(BATTERY2_STATUS_PORT) >> 
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
 800254c:	433e      	orrs	r6, r7
                                    BATTERY3_STATUS_SHIFT) & 0x03) << 4;
    indicators |= ((gpio_port_read(LOAD1_STATUS_PORT) >> 
                                    LOAD1_STATUS_SHIFT) & 0x03) << 6;
    indicators |= ((gpio_port_read(LOAD2_STATUS_PORT) >> 
                                    LOAD2_STATUS_SHIFT) & 0x03) << 8;
 800254e:	f3c0 2381 	ubfx	r3, r0, #10, #2
                                    BATTERY1_STATUS_SHIFT) & 0x03) << 0;
    indicators |= ((gpio_port_read(BATTERY2_STATUS_PORT) >> 
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
                                    BATTERY3_STATUS_SHIFT) & 0x03) << 4;
    indicators |= ((gpio_port_read(LOAD1_STATUS_PORT) >> 
 8002552:	4335      	orrs	r5, r6
                                    LOAD1_STATUS_SHIFT) & 0x03) << 6;
    indicators |= ((gpio_port_read(LOAD2_STATUS_PORT) >> 
                                    LOAD2_STATUS_SHIFT) & 0x03) << 8;
    indicators |= ((gpio_port_read(PANEL_STATUS_PORT) >> 
 8002554:	4620      	mov	r0, r4
                                    BATTERY2_STATUS_SHIFT) & 0x03) << 2;
    indicators |= ((gpio_port_read(BATTERY3_STATUS_PORT) >> 
                                    BATTERY3_STATUS_SHIFT) & 0x03) << 4;
    indicators |= ((gpio_port_read(LOAD1_STATUS_PORT) >> 
                                    LOAD1_STATUS_SHIFT) & 0x03) << 6;
    indicators |= ((gpio_port_read(LOAD2_STATUS_PORT) >> 
 8002556:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
                                    LOAD2_STATUS_SHIFT) & 0x03) << 8;
    indicators |= ((gpio_port_read(PANEL_STATUS_PORT) >> 
 800255a:	f004 fc3c 	bl	8006dd6 <gpio_port_read>
                                    PANEL_STATUS_SHIFT) & 0x03) << 10;
 800255e:	f3c0 1181 	ubfx	r1, r0, #6, #2
    return indicators;
}
 8002562:	ea45 2081 	orr.w	r0, r5, r1, lsl #10
 8002566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002568:	40010c00 	.word	0x40010c00
 800256c:	40010800 	.word	0x40010800

08002570 <setSwitch>:
@parameter[in] uint8_t battery: (1-3, 0 = none)
@parameter[in] uint8_t setting: load (0-1), panel 2.
*/

void setSwitch(uint8_t battery, uint8_t setting)
{
 8002570:	b538      	push	{r3, r4, r5, lr}
 8002572:	4604      	mov	r4, r0
    uint16_t switchControl = gpio_port_read(SWITCH_CONTROL_PORT);
 8002574:	480f      	ldr	r0, [pc, #60]	; (80025b4 <setSwitch+0x44>)
@parameter[in] uint8_t battery: (1-3, 0 = none)
@parameter[in] uint8_t setting: load (0-1), panel 2.
*/

void setSwitch(uint8_t battery, uint8_t setting)
{
 8002576:	460d      	mov	r5, r1
    uint16_t switchControl = gpio_port_read(SWITCH_CONTROL_PORT);
 8002578:	f004 fc2d 	bl	8006dd6 <gpio_port_read>
    uint16_t switchControlBits = ((switchControl >> SWITCH_CONTROL_SHIFT) & 0x3F);
/* Each two-bit field represents load 1 bits 0-1, load2 bits 2-3 panel bits 4-5,
and the setting is the battery to be connected (no two batteries can be connected
to a load/panel at the same time). The final bit pattern of settings go into PB8-13.
Preserve the lower 8 bits. */
    if ((battery <= 3) && (setting <= 2))
 800257c:	2c03      	cmp	r4, #3
 800257e:	d817      	bhi.n	80025b0 <setSwitch+0x40>
 8002580:	2d02      	cmp	r5, #2
 8002582:	d815      	bhi.n	80025b0 <setSwitch+0x40>
    {
        switchControlBits &= (~(0x03 << (setting<<1)));
 8002584:	006d      	lsls	r5, r5, #1
 8002586:	2103      	movs	r1, #3
 8002588:	fa01 f105 	lsl.w	r1, r1, r5
        switchControlBits |= ((battery & 0x03) << (setting<<1));
 800258c:	fa04 f505 	lsl.w	r5, r4, r5
*/

void setSwitch(uint8_t battery, uint8_t setting)
{
    uint16_t switchControl = gpio_port_read(SWITCH_CONTROL_PORT);
    uint16_t switchControlBits = ((switchControl >> SWITCH_CONTROL_SHIFT) & 0x3F);
 8002590:	f3c0 1385 	ubfx	r3, r0, #6, #6
and the setting is the battery to be connected (no two batteries can be connected
to a load/panel at the same time). The final bit pattern of settings go into PB8-13.
Preserve the lower 8 bits. */
    if ((battery <= 3) && (setting <= 2))
    {
        switchControlBits &= (~(0x03 << (setting<<1)));
 8002594:	ea23 0201 	bic.w	r2, r3, r1
        switchControlBits |= ((battery & 0x03) << (setting<<1));
 8002598:	432a      	orrs	r2, r5
        switchControl &= ~(0x3F << SWITCH_CONTROL_SHIFT);
        gpio_port_write(SWITCH_CONTROL_PORT,
                    (switchControl | (switchControlBits << SWITCH_CONTROL_SHIFT)));
 800259a:	b293      	uxth	r3, r2
Preserve the lower 8 bits. */
    if ((battery <= 3) && (setting <= 2))
    {
        switchControlBits &= (~(0x03 << (setting<<1)));
        switchControlBits |= ((battery & 0x03) << (setting<<1));
        switchControl &= ~(0x3F << SWITCH_CONTROL_SHIFT);
 800259c:	f420 607c 	bic.w	r0, r0, #4032	; 0xfc0
        gpio_port_write(SWITCH_CONTROL_PORT,
 80025a0:	ea40 1183 	orr.w	r1, r0, r3, lsl #6
 80025a4:	4803      	ldr	r0, [pc, #12]	; (80025b4 <setSwitch+0x44>)
 80025a6:	b289      	uxth	r1, r1
                    (switchControl | (switchControlBits << SWITCH_CONTROL_SHIFT)));
    }
}
 80025a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if ((battery <= 3) && (setting <= 2))
    {
        switchControlBits &= (~(0x03 << (setting<<1)));
        switchControlBits |= ((battery & 0x03) << (setting<<1));
        switchControl &= ~(0x3F << SWITCH_CONTROL_SHIFT);
        gpio_port_write(SWITCH_CONTROL_PORT,
 80025ac:	f004 bc16 	b.w	8006ddc <gpio_port_write>
 80025b0:	bd38      	pop	{r3, r4, r5, pc}
 80025b2:	bf00      	nop
 80025b4:	40011000 	.word	0x40011000

080025b8 <getSwitchControlBits>:

@returns uint16_t: the switch settings from the relevant port.
*/

uint8_t getSwitchControlBits(void)
{
 80025b8:	b508      	push	{r3, lr}
    return ((gpio_port_read(SWITCH_CONTROL_PORT) >> SWITCH_CONTROL_SHIFT) & 0x3F);
 80025ba:	4803      	ldr	r0, [pc, #12]	; (80025c8 <getSwitchControlBits+0x10>)
 80025bc:	f004 fc0b 	bl	8006dd6 <gpio_port_read>
}
 80025c0:	f3c0 1085 	ubfx	r0, r0, #6, #6
 80025c4:	bd08      	pop	{r3, pc}
 80025c6:	bf00      	nop
 80025c8:	40011000 	.word	0x40011000

080025cc <overCurrentReset>:

void overCurrentReset(uint8_t interface)
{
    uint32_t port;
    uint16_t bit;
    switch (interface)
 80025cc:	2805      	cmp	r0, #5
 80025ce:	d810      	bhi.n	80025f2 <overCurrentReset+0x26>
 80025d0:	e8df f000 	tbb	[pc, r0]
 80025d4:	06031714 	.word	0x06031714
 80025d8:	0c09      	.short	0x0c09
            port = BATTERY2_OVERCURRENT_RESET_PORT;
            bit = BATTERY2_OVERCURRENT_RESET_BIT;
            break;
        case 2:
            port = BATTERY3_OVERCURRENT_RESET_PORT;
            bit = BATTERY3_OVERCURRENT_RESET_BIT;
 80025da:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80025de:	e012      	b.n	8002606 <overCurrentReset+0x3a>
            break;
        case 3:
            port = LOAD1_OVERCURRENT_RESET_PORT;
            bit = LOAD1_OVERCURRENT_RESET_BIT;
 80025e0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80025e4:	e003      	b.n	80025ee <overCurrentReset+0x22>
            break;
        case 4:
            port = LOAD2_OVERCURRENT_RESET_PORT;
            bit = LOAD2_OVERCURRENT_RESET_BIT;
 80025e6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80025ea:	e000      	b.n	80025ee <overCurrentReset+0x22>
            break;
        case 5:
            port = PANEL_OVERCURRENT_RESET_PORT;
            bit = PANEL_OVERCURRENT_RESET_BIT;
 80025ec:	2120      	movs	r1, #32
        case 4:
            port = LOAD2_OVERCURRENT_RESET_PORT;
            bit = LOAD2_OVERCURRENT_RESET_BIT;
            break;
        case 5:
            port = PANEL_OVERCURRENT_RESET_PORT;
 80025ee:	4b07      	ldr	r3, [pc, #28]	; (800260c <overCurrentReset+0x40>)
            bit = PANEL_OVERCURRENT_RESET_BIT;
            break;
 80025f0:	e001      	b.n	80025f6 <overCurrentReset+0x2a>
    }
    if (interface < 6) gpio_set(port,bit);
 80025f2:	2805      	cmp	r0, #5
 80025f4:	d809      	bhi.n	800260a <overCurrentReset+0x3e>
 80025f6:	4618      	mov	r0, r3
 80025f8:	f004 bbe8 	b.w	8006dcc <gpio_set>
    uint16_t bit;
    switch (interface)
    {
        case 0:
            port = BATTERY1_OVERCURRENT_RESET_PORT;
            bit = BATTERY1_OVERCURRENT_RESET_BIT;
 80025fc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8002600:	e001      	b.n	8002606 <overCurrentReset+0x3a>
            break;
        case 1:
            port = BATTERY2_OVERCURRENT_RESET_PORT;
            bit = BATTERY2_OVERCURRENT_RESET_BIT;
 8002602:	f44f 4180 	mov.w	r1, #16384	; 0x4000
        case 0:
            port = BATTERY1_OVERCURRENT_RESET_PORT;
            bit = BATTERY1_OVERCURRENT_RESET_BIT;
            break;
        case 1:
            port = BATTERY2_OVERCURRENT_RESET_PORT;
 8002606:	4b02      	ldr	r3, [pc, #8]	; (8002610 <overCurrentReset+0x44>)
 8002608:	e7f5      	b.n	80025f6 <overCurrentReset+0x2a>
 800260a:	4770      	bx	lr
 800260c:	40011000 	.word	0x40011000
 8002610:	40010800 	.word	0x40010800

08002614 <overCurrentRelease>:

void overCurrentRelease(uint8_t interface)
{
    uint32_t port;
    uint16_t bit;
    switch (interface)
 8002614:	2805      	cmp	r0, #5
 8002616:	d810      	bhi.n	800263a <overCurrentRelease+0x26>
 8002618:	e8df f000 	tbb	[pc, r0]
 800261c:	06031714 	.word	0x06031714
 8002620:	0c09      	.short	0x0c09
            port = BATTERY2_OVERCURRENT_RESET_PORT;
            bit = BATTERY2_OVERCURRENT_RESET_BIT;
            break;
        case 2:
            port = BATTERY3_OVERCURRENT_RESET_PORT;
            bit = BATTERY3_OVERCURRENT_RESET_BIT;
 8002622:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8002626:	e012      	b.n	800264e <overCurrentRelease+0x3a>
            break;
        case 3:
            port = LOAD1_OVERCURRENT_RESET_PORT;
            bit = LOAD1_OVERCURRENT_RESET_BIT;
 8002628:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800262c:	e003      	b.n	8002636 <overCurrentRelease+0x22>
            break;
        case 4:
            port = LOAD2_OVERCURRENT_RESET_PORT;
            bit = LOAD2_OVERCURRENT_RESET_BIT;
 800262e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8002632:	e000      	b.n	8002636 <overCurrentRelease+0x22>
            break;
        case 5:
            port = PANEL_OVERCURRENT_RESET_PORT;
            bit = PANEL_OVERCURRENT_RESET_BIT;
 8002634:	2120      	movs	r1, #32
        case 4:
            port = LOAD2_OVERCURRENT_RESET_PORT;
            bit = LOAD2_OVERCURRENT_RESET_BIT;
            break;
        case 5:
            port = PANEL_OVERCURRENT_RESET_PORT;
 8002636:	4b07      	ldr	r3, [pc, #28]	; (8002654 <overCurrentRelease+0x40>)
            bit = PANEL_OVERCURRENT_RESET_BIT;
            break;
 8002638:	e001      	b.n	800263e <overCurrentRelease+0x2a>
    }
    if (interface < 6) gpio_clear(port,bit);
 800263a:	2805      	cmp	r0, #5
 800263c:	d809      	bhi.n	8002652 <overCurrentRelease+0x3e>
 800263e:	4618      	mov	r0, r3
 8002640:	f004 bbc6 	b.w	8006dd0 <gpio_clear>
    uint16_t bit;
    switch (interface)
    {
        case 0:
            port = BATTERY1_OVERCURRENT_RESET_PORT;
            bit = BATTERY1_OVERCURRENT_RESET_BIT;
 8002644:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8002648:	e001      	b.n	800264e <overCurrentRelease+0x3a>
            break;
        case 1:
            port = BATTERY2_OVERCURRENT_RESET_PORT;
            bit = BATTERY2_OVERCURRENT_RESET_BIT;
 800264a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
        case 0:
            port = BATTERY1_OVERCURRENT_RESET_PORT;
            bit = BATTERY1_OVERCURRENT_RESET_BIT;
            break;
        case 1:
            port = BATTERY2_OVERCURRENT_RESET_PORT;
 800264e:	4b02      	ldr	r3, [pc, #8]	; (8002658 <overCurrentRelease+0x44>)
 8002650:	e7f5      	b.n	800263e <overCurrentRelease+0x2a>
 8002652:	4770      	bx	lr
 8002654:	40011000 	.word	0x40011000
 8002658:	40010800 	.word	0x40010800

0800265c <setSwitchControlBits>:

@param[in] uint16_t settings: the switch settings from the relevant port.
*/

void setSwitchControlBits(uint8_t settings)
{
 800265c:	b538      	push	{r3, r4, r5, lr}
    uint16_t switchControl = gpio_port_read(SWITCH_CONTROL_PORT);
 800265e:	4c07      	ldr	r4, [pc, #28]	; (800267c <setSwitchControlBits+0x20>)

@param[in] uint16_t settings: the switch settings from the relevant port.
*/

void setSwitchControlBits(uint8_t settings)
{
 8002660:	4605      	mov	r5, r0
    uint16_t switchControl = gpio_port_read(SWITCH_CONTROL_PORT);
 8002662:	4620      	mov	r0, r4
 8002664:	f004 fbb7 	bl	8006dd6 <gpio_port_read>
    switchControl &= ~(0x3F << SWITCH_CONTROL_SHIFT);
 8002668:	f420 607c 	bic.w	r0, r0, #4032	; 0xfc0
    gpio_port_write(SWITCH_CONTROL_PORT,
 800266c:	ea40 1185 	orr.w	r1, r0, r5, lsl #6
 8002670:	b289      	uxth	r1, r1
 8002672:	4620      	mov	r0, r4
                (switchControl | (settings << SWITCH_CONTROL_SHIFT)));
}
 8002674:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

void setSwitchControlBits(uint8_t settings)
{
    uint16_t switchControl = gpio_port_read(SWITCH_CONTROL_PORT);
    switchControl &= ~(0x3F << SWITCH_CONTROL_SHIFT);
    gpio_port_write(SWITCH_CONTROL_PORT,
 8002678:	f004 bbb0 	b.w	8006ddc <gpio_port_write>
 800267c:	40011000 	.word	0x40011000

08002680 <pwmSetDutyCycle>:
@parameter[in] uint8_t dutyCycle: Duty cycle in percentage.
*/

void pwmSetDutyCycle(uint16_t dutyCycle)
{
    uint32_t threshold = ((PWM_PERIOD*dutyCycle)/100)>>8;
 8002680:	2290      	movs	r2, #144	; 0x90
 8002682:	4342      	muls	r2, r0

@parameter[in] uint8_t dutyCycle: Duty cycle in percentage.
*/

void pwmSetDutyCycle(uint16_t dutyCycle)
{
 8002684:	b510      	push	{r4, lr}
    uint32_t threshold = ((PWM_PERIOD*dutyCycle)/100)>>8;
	timer_set_oc_value(TIM1, TIM_OC1, threshold);    
 8002686:	4c06      	ldr	r4, [pc, #24]	; (80026a0 <pwmSetDutyCycle+0x20>)
 8002688:	2100      	movs	r1, #0
 800268a:	4620      	mov	r0, r4
 800268c:	0a12      	lsrs	r2, r2, #8
 800268e:	f004 fdb1 	bl	80071f4 <timer_set_oc_value>
	timer_generate_event(TIM1, TIM_EGR_UG);
 8002692:	4620      	mov	r0, r4
 8002694:	2101      	movs	r1, #1
}
 8002696:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void pwmSetDutyCycle(uint16_t dutyCycle)
{
    uint32_t threshold = ((PWM_PERIOD*dutyCycle)/100)>>8;
	timer_set_oc_value(TIM1, TIM_OC1, threshold);    
	timer_generate_event(TIM1, TIM_EGR_UG);
 800269a:	f004 bdc9 	b.w	8007230 <timer_generate_event>
 800269e:	bf00      	nop
 80026a0:	40012c00 	.word	0x40012c00

080026a4 <prvSetupHardware>:
/** @brief Initialise the hardware

*/

void prvSetupHardware(void)
{
 80026a4:	b510      	push	{r4, lr}
clocks are turned on.
*/

static void clockSetup(void)
{
	rcc_clock_setup_in_hse_8mhz_out_72mhz();
 80026a6:	f004 f9ed 	bl	8006a84 <rcc_clock_setup_in_hse_8mhz_out_72mhz>
*/

static void gpioSetup(void)
{
/* Enable all GPIO clocks. */
    rcc_periph_clock_enable(RCC_GPIOA);
 80026aa:	f240 3002 	movw	r0, #770	; 0x302
 80026ae:	f004 fe23 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_GPIOB);
 80026b2:	f240 3003 	movw	r0, #771	; 0x303
 80026b6:	f004 fe1f 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_GPIOC);
 80026ba:	f44f 7041 	mov.w	r0, #772	; 0x304
 80026be:	f004 fe1b 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_AFIO);
 80026c2:	f44f 7040 	mov.w	r0, #768	; 0x300
 80026c6:	f004 fe17 	bl	80072f8 <rcc_periph_clock_enable>

#ifndef USE_SWD
/* Disable SWD and JTAG to allow full use of the ports PA13, PA14, PA15 */
    gpio_primary_remap(AFIO_MAPR_SWJ_CFG_JTAG_OFF_SW_OFF,0);
 80026ca:	2100      	movs	r1, #0
 80026cc:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80026d0:	f004 f918 	bl	8006904 <gpio_primary_remap>
#endif

/* PA inputs analogue for currents, voltages and ambient temperature */
#ifdef PA_ANALOGUE_INPUTS
    gpio_set_mode(GPIOA, GPIO_MODE_INPUT, GPIO_CNF_INPUT_ANALOG,
 80026d4:	2100      	movs	r1, #0
 80026d6:	460a      	mov	r2, r1
 80026d8:	23ff      	movs	r3, #255	; 0xff
 80026da:	487e      	ldr	r0, [pc, #504]	; (80028d4 <prvSetupHardware+0x230>)
 80026dc:	f004 f8da 	bl	8006894 <gpio_set_mode>
			    PA_ANALOGUE_INPUTS);
#endif
/* PA inputs analogue for currents, voltages and ambient temperature */
#ifdef PA_ANALOGUE_INPUTS
    gpio_set_mode(GPIOC, GPIO_MODE_INPUT, GPIO_CNF_INPUT_ANALOG,
 80026e0:	2100      	movs	r1, #0
 80026e2:	460a      	mov	r2, r1
 80026e4:	231f      	movs	r3, #31
 80026e6:	487c      	ldr	r0, [pc, #496]	; (80028d8 <prvSetupHardware+0x234>)
 80026e8:	f004 f8d4 	bl	8006894 <gpio_set_mode>
			    PC_ANALOGUE_INPUTS);
#endif
/* PA outputs digital */
#ifdef PA_DIGITAL_OUTPUTS
    gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_PUSHPULL,
 80026ec:	2200      	movs	r2, #0
 80026ee:	2103      	movs	r1, #3
 80026f0:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 80026f4:	4877      	ldr	r0, [pc, #476]	; (80028d4 <prvSetupHardware+0x230>)
 80026f6:	f004 f8cd 	bl	8006894 <gpio_set_mode>
			    PA_DIGITAL_OUTPUTS);
    gpio_clear(GPIOA, PA_DIGITAL_OUTPUTS);
 80026fa:	4876      	ldr	r0, [pc, #472]	; (80028d4 <prvSetupHardware+0x230>)
 80026fc:	f44f 4161 	mov.w	r1, #57600	; 0xe100
 8002700:	f004 fb66 	bl	8006dd0 <gpio_clear>
			    PB_DIGITAL_OUTPUTS);
    gpio_clear(GPIOB, PB_DIGITAL_OUTPUTS);
#endif
/* PC outputs digital */
#ifdef PC_DIGITAL_OUTPUTS
    gpio_set_mode(GPIOC, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_PUSHPULL,
 8002704:	2200      	movs	r2, #0
 8002706:	2103      	movs	r1, #3
 8002708:	f643 73e0 	movw	r3, #16352	; 0x3fe0
 800270c:	4872      	ldr	r0, [pc, #456]	; (80028d8 <prvSetupHardware+0x234>)
 800270e:	f004 f8c1 	bl	8006894 <gpio_set_mode>
			    PC_DIGITAL_OUTPUTS);
    gpio_clear(GPIOC, PC_DIGITAL_OUTPUTS);
 8002712:	4871      	ldr	r0, [pc, #452]	; (80028d8 <prvSetupHardware+0x234>)
 8002714:	f643 71e0 	movw	r1, #16352	; 0x3fe0
 8002718:	f004 fb5a 	bl	8006dd0 <gpio_clear>
#endif
/* PA inputs digital */
#ifdef PA_DIGITAL_INPUTS
    gpio_set_mode(GPIOA, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT,
 800271c:	2100      	movs	r1, #0
 800271e:	2201      	movs	r2, #1
 8002720:	486c      	ldr	r0, [pc, #432]	; (80028d4 <prvSetupHardware+0x230>)
 8002722:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8002726:	f004 f8b5 	bl	8006894 <gpio_set_mode>
			    PA_DIGITAL_INPUTS);
#endif
/* PB inputs digital */
#ifdef PB_DIGITAL_INPUTS
    gpio_set_mode(GPIOB, GPIO_MODE_INPUT, GPIO_CNF_INPUT_FLOAT,
 800272a:	2100      	movs	r1, #0
 800272c:	2201      	movs	r2, #1
 800272e:	f640 73ff 	movw	r3, #4095	; 0xfff
 8002732:	486a      	ldr	r0, [pc, #424]	; (80028dc <prvSetupHardware+0x238>)
 8002734:	f004 f8ae 	bl	8006894 <gpio_set_mode>
*/

static void usartSetup(void)
{
/* Enable clocks for GPIO port A (for GPIO_USART1_TX) and USART1. */
    rcc_periph_clock_enable(RCC_GPIOA);
 8002738:	f240 3002 	movw	r0, #770	; 0x302
 800273c:	f004 fddc 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_AFIO);
 8002740:	f44f 7040 	mov.w	r0, #768	; 0x300
 8002744:	f004 fdd8 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_USART1);
 8002748:	f240 300e 	movw	r0, #782	; 0x30e
 800274c:	f004 fdd4 	bl	80072f8 <rcc_periph_clock_enable>
/* Enable the USART1 interrupt. */
	nvic_enable_irq(NVIC_USART1_IRQ);
 8002750:	2025      	movs	r0, #37	; 0x25
 8002752:	f004 fe8d 	bl	8007470 <nvic_enable_irq>
/* Setup GPIO pin GPIO_USART1_RE_TX on GPIO port A for transmit. */
	gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
 8002756:	2103      	movs	r1, #3
 8002758:	485e      	ldr	r0, [pc, #376]	; (80028d4 <prvSetupHardware+0x230>)
 800275a:	2202      	movs	r2, #2
 800275c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002760:	f004 f898 	bl	8006894 <gpio_set_mode>
		      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO_USART1_TX);
/* Setup GPIO pin GPIO_USART1_RE_RX on GPIO port A for receive. */
	gpio_set_mode(GPIOA, GPIO_MODE_INPUT,
 8002764:	2201      	movs	r2, #1
 8002766:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800276a:	2100      	movs	r1, #0
 800276c:	4859      	ldr	r0, [pc, #356]	; (80028d4 <prvSetupHardware+0x230>)
 800276e:	f004 f891 	bl	8006894 <gpio_set_mode>
		      GPIO_CNF_INPUT_FLOAT, GPIO_USART1_RX);
/* Setup UART parameters. */
	usart_set_baudrate(USART1, BAUDRATE);
 8002772:	485b      	ldr	r0, [pc, #364]	; (80028e0 <prvSetupHardware+0x23c>)
 8002774:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
 8002778:	f004 fd5e 	bl	8007238 <usart_set_baudrate>
	usart_set_databits(USART1, 8);
 800277c:	2108      	movs	r1, #8
 800277e:	4858      	ldr	r0, [pc, #352]	; (80028e0 <prvSetupHardware+0x23c>)
 8002780:	f004 fd6e 	bl	8007260 <usart_set_databits>
	usart_set_stopbits(USART1, USART_STOPBITS_1);
 8002784:	2100      	movs	r1, #0
 8002786:	4856      	ldr	r0, [pc, #344]	; (80028e0 <prvSetupHardware+0x23c>)
 8002788:	f004 fd73 	bl	8007272 <usart_set_stopbits>
	usart_set_parity(USART1, USART_PARITY_NONE);
 800278c:	2100      	movs	r1, #0
 800278e:	4854      	ldr	r0, [pc, #336]	; (80028e0 <prvSetupHardware+0x23c>)
 8002790:	f004 fd75 	bl	800727e <usart_set_parity>
	usart_set_flow_control(USART1, USART_FLOWCONTROL_NONE);
 8002794:	2100      	movs	r1, #0
 8002796:	4852      	ldr	r0, [pc, #328]	; (80028e0 <prvSetupHardware+0x23c>)
 8002798:	f004 fd7d 	bl	8007296 <usart_set_flow_control>
	usart_set_mode(USART1, USART_MODE_TX_RX);
 800279c:	210c      	movs	r1, #12
 800279e:	4850      	ldr	r0, [pc, #320]	; (80028e0 <prvSetupHardware+0x23c>)
 80027a0:	f004 fd73 	bl	800728a <usart_set_mode>
/* Enable USART1 receive interrupts. */
	usart_enable_rx_interrupt(USART1);
 80027a4:	484e      	ldr	r0, [pc, #312]	; (80028e0 <prvSetupHardware+0x23c>)
 80027a6:	f004 fd81 	bl	80072ac <usart_enable_rx_interrupt>
	usart_disable_tx_interrupt(USART1);
 80027aa:	484d      	ldr	r0, [pc, #308]	; (80028e0 <prvSetupHardware+0x23c>)
 80027ac:	f004 fd88 	bl	80072c0 <usart_disable_tx_interrupt>
/* Finally enable the USART. */
	usart_enable(USART1);
 80027b0:	484b      	ldr	r0, [pc, #300]	; (80028e0 <prvSetupHardware+0x23c>)
 80027b2:	f004 fd76 	bl	80072a2 <usart_enable>
No interrupt is required.
*/

static void pwmSetup(void)
{
    rcc_periph_clock_enable(RCC_GPIOA);
 80027b6:	f240 3002 	movw	r0, #770	; 0x302
 80027ba:	f004 fd9d 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_AFIO);
 80027be:	f44f 7040 	mov.w	r0, #768	; 0x300
 80027c2:	f004 fd99 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_TIM1);
 80027c6:	f240 300b 	movw	r0, #779	; 0x30b
 80027ca:	f004 fd95 	bl	80072f8 <rcc_periph_clock_enable>
	gpio_set_mode(GPIOA, GPIO_MODE_OUTPUT_50_MHZ,
 80027ce:	2103      	movs	r1, #3
 80027d0:	2202      	movs	r2, #2
 80027d2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80027d6:	483f      	ldr	r0, [pc, #252]	; (80028d4 <prvSetupHardware+0x230>)
 80027d8:	f004 f85c 	bl	8006894 <gpio_set_mode>
		      GPIO_CNF_OUTPUT_ALTFN_PUSHPULL, GPIO8);

/* Reset TIM1 peripheral. */
	timer_reset(TIM1);
 80027dc:	4841      	ldr	r0, [pc, #260]	; (80028e4 <prvSetupHardware+0x240>)
 80027de:	f004 fbbd 	bl	8006f5c <timer_reset>
/* Set Timer global mode:
 - No division
 - Alignment centre mode 1 (up/down counting, interrupt on downcount only)
 - Direction up (when centre mode is set it is read only, changes by hardware)
*/
	timer_set_mode(TIM1, TIM_CR1_CKD_CK_INT, TIM_CR1_CMS_CENTER_1, TIM_CR1_DIR_UP);
 80027e2:	2100      	movs	r1, #0
 80027e4:	460b      	mov	r3, r1
 80027e6:	2220      	movs	r2, #32
 80027e8:	483e      	ldr	r0, [pc, #248]	; (80028e4 <prvSetupHardware+0x240>)
 80027ea:	f004 fbf7 	bl	8006fdc <timer_set_mode>

/* Set Timer output compare mode:
 - Channel 1, PWM mode 2 (output low when CNT < CCR1, high otherwise)
*/
	timer_set_oc_mode(TIM1, TIM_OC1, TIM_OCM_PWM2);
 80027ee:	2207      	movs	r2, #7
 80027f0:	2100      	movs	r1, #0
 80027f2:	483c      	ldr	r0, [pc, #240]	; (80028e4 <prvSetupHardware+0x240>)
 80027f4:	f004 fc07 	bl	8007006 <timer_set_oc_mode>
	timer_enable_oc_output(TIM1, TIM_OC1);
 80027f8:	2100      	movs	r1, #0
 80027fa:	483a      	ldr	r0, [pc, #232]	; (80028e4 <prvSetupHardware+0x240>)
 80027fc:	f004 fcc6 	bl	800718c <timer_enable_oc_output>
	timer_enable_break_main_output(TIM1);
 8002800:	4838      	ldr	r0, [pc, #224]	; (80028e4 <prvSetupHardware+0x240>)
 8002802:	f004 fd07 	bl	8007214 <timer_enable_break_main_output>

/* The ARR (auto-preload register) sets the PWM period to 50 microseconds from the
72 MHz clock.*/
	timer_enable_preload(TIM1);
 8002806:	4837      	ldr	r0, [pc, #220]	; (80028e4 <prvSetupHardware+0x240>)
 8002808:	f004 fbf1 	bl	8006fee <timer_enable_preload>
	timer_set_period(TIM1, PWM_PERIOD);
 800280c:	f44f 5161 	mov.w	r1, #14400	; 0x3840
 8002810:	4834      	ldr	r0, [pc, #208]	; (80028e4 <prvSetupHardware+0x240>)
 8002812:	f004 fbf6 	bl	8007002 <timer_set_period>

/* The CCR1 (capture/compare register 1) sets the PWM duty cycle to default 50% */
    pwmSetDutyCycle(50);
 8002816:	2032      	movs	r0, #50	; 0x32
 8002818:	f7ff ff32 	bl	8002680 <pwmSetDutyCycle>

/* Force an update to load the shadow registers */
	timer_generate_event(TIM1, TIM_EGR_UG);
 800281c:	2101      	movs	r1, #1
 800281e:	4831      	ldr	r0, [pc, #196]	; (80028e4 <prvSetupHardware+0x240>)
 8002820:	f004 fd06 	bl	8007230 <timer_generate_event>

/* Start the Counter. */
	timer_enable_counter(TIM1);
 8002824:	482f      	ldr	r0, [pc, #188]	; (80028e4 <prvSetupHardware+0x240>)
 8002826:	f004 fbe7 	bl	8006ff8 <timer_enable_counter>
{
	clockSetup();
	gpioSetup();
	usartSetup();
    pwmSetup();
	dmaAdcSetup();
 800282a:	f7ff fe1f 	bl	800246c <dmaAdcSetup>
*/

static void adcSetup(void)
{
	/* Enable clocks for ADCs */
    rcc_periph_clock_enable(RCC_GPIOA);
 800282e:	f240 3002 	movw	r0, #770	; 0x302
 8002832:	f004 fd61 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_AFIO);
 8002836:	f44f 7040 	mov.w	r0, #768	; 0x300
 800283a:	f004 fd5d 	bl	80072f8 <rcc_periph_clock_enable>
    rcc_periph_clock_enable(RCC_ADC1);
 800283e:	f240 3009 	movw	r0, #777	; 0x309
 8002842:	f004 fd59 	bl	80072f8 <rcc_periph_clock_enable>
/* ADC clock should be maximum 14MHz, so divide by 8 from 72MHz. */
    rcc_set_adcpre(RCC_CFGR_ADCPRE_PCLK2_DIV8);
 8002846:	2003      	movs	r0, #3
 8002848:	f004 f8f4 	bl	8006a34 <rcc_set_adcpre>
	nvic_enable_irq(NVIC_ADC1_2_IRQ);
 800284c:	2012      	movs	r0, #18
 800284e:	f004 fe0f 	bl	8007470 <nvic_enable_irq>
	/* Make sure the ADC doesn't run during config. */
	adc_off(ADC1);
 8002852:	4825      	ldr	r0, [pc, #148]	; (80028e8 <prvSetupHardware+0x244>)
 8002854:	f003 ff31 	bl	80066ba <adc_off>
	/* Configure ADC1 for multiple conversion. */
	adc_enable_scan_mode(ADC1);
 8002858:	4823      	ldr	r0, [pc, #140]	; (80028e8 <prvSetupHardware+0x244>)
 800285a:	f003 ff33 	bl	80066c4 <adc_enable_scan_mode>
	adc_set_single_conversion_mode(ADC1);
 800285e:	4822      	ldr	r0, [pc, #136]	; (80028e8 <prvSetupHardware+0x244>)
 8002860:	f003 ff3f 	bl	80066e2 <adc_set_single_conversion_mode>
	adc_enable_external_trigger_regular(ADC1, ADC_CR2_EXTSEL_SWSTART);
 8002864:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
 8002868:	481f      	ldr	r0, [pc, #124]	; (80028e8 <prvSetupHardware+0x244>)
 800286a:	f003 fef3 	bl	8006654 <adc_enable_external_trigger_regular>
	adc_set_right_aligned(ADC1);
 800286e:	481e      	ldr	r0, [pc, #120]	; (80028e8 <prvSetupHardware+0x244>)
 8002870:	f003 ff32 	bl	80066d8 <adc_set_right_aligned>
	adc_set_sample_time_on_all_channels(ADC1, ADC_SMPR_SMP_28DOT5CYC);
 8002874:	2103      	movs	r1, #3
 8002876:	481c      	ldr	r0, [pc, #112]	; (80028e8 <prvSetupHardware+0x244>)
 8002878:	f003 ff0a 	bl	8006690 <adc_set_sample_time_on_all_channels>
	adc_enable_dma(ADC1);
 800287c:	481a      	ldr	r0, [pc, #104]	; (80028e8 <prvSetupHardware+0x244>)
 800287e:	f003 ff83 	bl	8006788 <adc_enable_dma>
	adc_enable_eoc_interrupt(ADC1);
 8002882:	4819      	ldr	r0, [pc, #100]	; (80028e8 <prvSetupHardware+0x244>)
 8002884:	f003 ff23 	bl	80066ce <adc_enable_eoc_interrupt>
/* Power on and calibrate */
	adc_power_on(ADC1);
 8002888:	4817      	ldr	r0, [pc, #92]	; (80028e8 <prvSetupHardware+0x244>)
 800288a:	f003 fedb 	bl	8006644 <adc_power_on>
 800288e:	4c17      	ldr	r4, [pc, #92]	; (80028ec <prvSetupHardware+0x248>)
	/* Wait for ADC starting up. */
	uint32_t i;
	for (i = 0; i < 800000; i++)    /* Wait a bit. */
		__asm__("nop");
 8002890:	bf00      	nop
	adc_enable_eoc_interrupt(ADC1);
/* Power on and calibrate */
	adc_power_on(ADC1);
	/* Wait for ADC starting up. */
	uint32_t i;
	for (i = 0; i < 800000; i++)    /* Wait a bit. */
 8002892:	3c01      	subs	r4, #1
 8002894:	d1fc      	bne.n	8002890 <prvSetupHardware+0x1ec>
		__asm__("nop");
	adc_reset_calibration(ADC1);
 8002896:	4814      	ldr	r0, [pc, #80]	; (80028e8 <prvSetupHardware+0x244>)
 8002898:	f003 fee6 	bl	8006668 <adc_reset_calibration>
	adc_calibration(ADC1);
 800289c:	4812      	ldr	r0, [pc, #72]	; (80028e8 <prvSetupHardware+0x244>)
 800289e:	f003 feed 	bl	800667c <adc_calibration>
*/

static void systickSetup()
{
	/* 72MHz / 8 => 9,000,000 counts per second */
	systick_set_clocksource(STK_CSR_CLKSOURCE_AHB_DIV8);
 80028a2:	4620      	mov	r0, r4
 80028a4:	f004 fdc0 	bl	8007428 <systick_set_clocksource>

	/* 9000000/9000 = 1000 overflows per second - every 1ms one interrupt */
	/* SysTick interrupt every N clock pulses: set reload to N-1 */
	systick_set_reload(8999);
 80028a8:	f242 3027 	movw	r0, #8999	; 0x2327
 80028ac:	f004 fdb4 	bl	8007418 <systick_set_reload>

	systick_interrupt_enable();
 80028b0:	f004 fdc6 	bl	8007440 <systick_interrupt_enable>

	/* Start counting. */
	systick_counter_enable();
 80028b4:	f004 fdcc 	bl	8007450 <systick_counter_enable>
	usartSetup();
    pwmSetup();
	dmaAdcSetup();
	adcSetup();
    systickSetup();
	rtc_auto_awake(LSE, 0x7fff);
 80028b8:	2005      	movs	r0, #5
 80028ba:	f647 71ff 	movw	r1, #32767	; 0x7fff
 80028be:	f004 f9fb 	bl	8006cb8 <rtc_auto_awake>

*/

static void iwdgSetup(void)
{
    iwdg_set_period_ms(IWDG_TIMEOUT_MS);
 80028c2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80028c6:	f004 faa3 	bl	8006e10 <iwdg_set_period_ms>
	dmaAdcSetup();
	adcSetup();
    systickSetup();
	rtc_auto_awake(LSE, 0x7fff);
    iwdgSetup();
}
 80028ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
*/

static void iwdgSetup(void)
{
    iwdg_set_period_ms(IWDG_TIMEOUT_MS);
    iwdg_start();
 80028ce:	f004 ba87 	b.w	8006de0 <iwdg_start>
 80028d2:	bf00      	nop
 80028d4:	40010800 	.word	0x40010800
 80028d8:	40011000 	.word	0x40011000
 80028dc:	40010c00 	.word	0x40010c00
 80028e0:	40013800 	.word	0x40013800
 80028e4:	40012c00 	.word	0x40012c00
 80028e8:	40012400 	.word	0x40012400
 80028ec:	000c3500 	.word	0x000c3500

080028f0 <commsEnableTxInterrupt>:
@parameter[in] uint8_t enable: true to enable the interrupt, false to disable.
*/

void commsEnableTxInterrupt(uint8_t enable)
{
    if (enable) usart_enable_tx_interrupt(USART1);
 80028f0:	b110      	cbz	r0, 80028f8 <commsEnableTxInterrupt+0x8>
 80028f2:	4803      	ldr	r0, [pc, #12]	; (8002900 <commsEnableTxInterrupt+0x10>)
 80028f4:	f004 bcdf 	b.w	80072b6 <usart_enable_tx_interrupt>
    else usart_disable_tx_interrupt(USART1);
 80028f8:	4801      	ldr	r0, [pc, #4]	; (8002900 <commsEnableTxInterrupt+0x10>)
 80028fa:	f004 bce1 	b.w	80072c0 <usart_disable_tx_interrupt>
 80028fe:	bf00      	nop
 8002900:	40013800 	.word	0x40013800

08002904 <iwdgReset>:
Must be called by an active task before the timer period expires.
*/

void iwdgReset(void)
{
    iwdg_reset();
 8002904:	f004 baca 	b.w	8006e9c <iwdg_reset>

08002908 <flashReadData>:
@param[in] uint32_t *dataBlock: pointer to data block to write
@param[in] uint16_t size: length of data block
*/

void flashReadData(uint32_t *flashBlock, uint8_t *dataBlock, uint16_t size)
{
 8002908:	b510      	push	{r4, lr}
	uint16_t n;
	uint32_t *flashAddress= flashBlock;

	for(n=0; n<size; n += 4)
 800290a:	2300      	movs	r3, #0
 800290c:	b29c      	uxth	r4, r3
 800290e:	4294      	cmp	r4, r2
 8002910:	d203      	bcs.n	800291a <flashReadData+0x12>
	{
		*(uint32_t*)dataBlock = *(flashAddress++);
 8002912:	58c4      	ldr	r4, [r0, r3]
 8002914:	50cc      	str	r4, [r1, r3]
 8002916:	3304      	adds	r3, #4
 8002918:	e7f8      	b.n	800290c <flashReadData+0x4>
		dataBlock += 4;
	}
}
 800291a:	bd10      	pop	{r4, pc}

0800291c <flashWriteData>:
@returns uint32_t result code: 0 success, bit 0 address out of range,
bit 2: programming error, bit 4: write protect error, bit 7 compare fail.
*/

uint32_t flashWriteData(uint32_t *flashBlock, uint8_t *data, uint16_t size)
{
 800291c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t flashAddress = pageStart;
	uint32_t pageAddress = pageStart;
	uint32_t flashStatus = 0;

	/*check if pageStart is in proper range*/
	if((pageStart < __configBlockStart) || (pageStart >= __configBlockEnd))
 800291e:	4b19      	ldr	r3, [pc, #100]	; (8002984 <flashWriteData+0x68>)
@returns uint32_t result code: 0 success, bit 0 address out of range,
bit 2: programming error, bit 4: write protect error, bit 7 compare fail.
*/

uint32_t flashWriteData(uint32_t *flashBlock, uint8_t *data, uint16_t size)
{
 8002920:	4604      	mov	r4, r0
	uint32_t flashAddress = pageStart;
	uint32_t pageAddress = pageStart;
	uint32_t flashStatus = 0;

	/*check if pageStart is in proper range*/
	if((pageStart < __configBlockStart) || (pageStart >= __configBlockEnd))
 8002922:	6818      	ldr	r0, [r3, #0]
@returns uint32_t result code: 0 success, bit 0 address out of range,
bit 2: programming error, bit 4: write protect error, bit 7 compare fail.
*/

uint32_t flashWriteData(uint32_t *flashBlock, uint8_t *data, uint16_t size)
{
 8002924:	460e      	mov	r6, r1
	uint32_t flashAddress = pageStart;
	uint32_t pageAddress = pageStart;
	uint32_t flashStatus = 0;

	/*check if pageStart is in proper range*/
	if((pageStart < __configBlockStart) || (pageStart >= __configBlockEnd))
 8002926:	4284      	cmp	r4, r0
@returns uint32_t result code: 0 success, bit 0 address out of range,
bit 2: programming error, bit 4: write protect error, bit 7 compare fail.
*/

uint32_t flashWriteData(uint32_t *flashBlock, uint8_t *data, uint16_t size)
{
 8002928:	4617      	mov	r7, r2
	uint32_t flashAddress = pageStart;
	uint32_t pageAddress = pageStart;
	uint32_t flashStatus = 0;

	/*check if pageStart is in proper range*/
	if((pageStart < __configBlockStart) || (pageStart >= __configBlockEnd))
 800292a:	d326      	bcc.n	800297a <flashWriteData+0x5e>
 800292c:	4916      	ldr	r1, [pc, #88]	; (8002988 <flashWriteData+0x6c>)
 800292e:	680a      	ldr	r2, [r1, #0]
 8002930:	4294      	cmp	r4, r2
 8002932:	d222      	bcs.n	800297a <flashWriteData+0x5e>
		return 1;

	/*calculate current page address*/
	if(pageStart % FLASH_PAGE_SIZE)
 8002934:	0563      	lsls	r3, r4, #21
 8002936:	0d5d      	lsrs	r5, r3, #21
 8002938:	b10b      	cbz	r3, 800293e <flashWriteData+0x22>
		pageAddress -= (pageStart % FLASH_PAGE_SIZE);
 800293a:	1b65      	subs	r5, r4, r5
 800293c:	e000      	b.n	8002940 <flashWriteData+0x24>
	/*check if pageStart is in proper range*/
	if((pageStart < __configBlockStart) || (pageStart >= __configBlockEnd))
		return 1;

	/*calculate current page address*/
	if(pageStart % FLASH_PAGE_SIZE)
 800293e:	4625      	mov	r5, r4
		pageAddress -= (pageStart % FLASH_PAGE_SIZE);

	flash_unlock();
 8002940:	f004 fd04 	bl	800734c <flash_unlock>

	/*Erasing page*/
	flash_erase_page(pageAddress);
 8002944:	4628      	mov	r0, r5
 8002946:	f003 ff69 	bl	800681c <flash_erase_page>
	flashStatus = flash_get_status_flags();
 800294a:	f003 ff23 	bl	8006794 <flash_get_status_flags>
	if(flashStatus != FLASH_SR_EOP)
 800294e:	2820      	cmp	r0, #32
 8002950:	d116      	bne.n	8002980 <flashWriteData+0x64>
 8002952:	2500      	movs	r5, #0
		return flashStatus;

	/*programming flash memory*/
	for(n=0; n<size; n += 4)
 8002954:	42bd      	cmp	r5, r7
 8002956:	d20e      	bcs.n	8002976 <flashWriteData+0x5a>
	{
		/*programming word data*/
		flash_program_word(flashAddress+n, *((uint32_t*)(data + n)));
 8002958:	1960      	adds	r0, r4, r5
 800295a:	5971      	ldr	r1, [r6, r5]
 800295c:	f004 fd0e 	bl	800737c <flash_program_word>
		flashStatus = flash_get_status_flags();
 8002960:	f003 ff18 	bl	8006794 <flash_get_status_flags>
		if(flashStatus != FLASH_SR_EOP)
 8002964:	2820      	cmp	r0, #32
 8002966:	d10b      	bne.n	8002980 <flashWriteData+0x64>
			return flashStatus;

		/*verify if correct data is programmed*/
		if(*((uint32_t*)(flashAddress+n)) != *((uint32_t*)(data + n)))
 8002968:	5960      	ldr	r0, [r4, r5]
 800296a:	5971      	ldr	r1, [r6, r5]
 800296c:	4288      	cmp	r0, r1
 800296e:	d106      	bne.n	800297e <flashWriteData+0x62>
	flashStatus = flash_get_status_flags();
	if(flashStatus != FLASH_SR_EOP)
		return flashStatus;

	/*programming flash memory*/
	for(n=0; n<size; n += 4)
 8002970:	1d2a      	adds	r2, r5, #4
 8002972:	b295      	uxth	r5, r2
 8002974:	e7ee      	b.n	8002954 <flashWriteData+0x38>
		/*verify if correct data is programmed*/
		if(*((uint32_t*)(flashAddress+n)) != *((uint32_t*)(data + n)))
			return 0x80;
	}

	return 0;
 8002976:	2000      	movs	r0, #0
 8002978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t pageAddress = pageStart;
	uint32_t flashStatus = 0;

	/*check if pageStart is in proper range*/
	if((pageStart < __configBlockStart) || (pageStart >= __configBlockEnd))
		return 1;
 800297a:	2001      	movs	r0, #1
 800297c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if(flashStatus != FLASH_SR_EOP)
			return flashStatus;

		/*verify if correct data is programmed*/
		if(*((uint32_t*)(flashAddress+n)) != *((uint32_t*)(data + n)))
			return 0x80;
 800297e:	2080      	movs	r0, #128	; 0x80
	}

	return 0;
}
 8002980:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002982:	bf00      	nop
 8002984:	08007800 	.word	0x08007800
 8002988:	08008000 	.word	0x08008000

0800298c <getTimeCounter>:
@returns uint32_t. Time value.
*/

uint32_t getTimeCounter()
{
    return rtc_get_counter_val();
 800298c:	f004 b95e 	b.w	8006c4c <rtc_get_counter_val>

08002990 <setTimeCounter>:
@param[in] time uint32_t. Time value to set.
*/

void setTimeCounter(uint32_t time)
{
    rtc_set_counter_val(time);
 8002990:	f004 b966 	b.w	8006c60 <rtc_set_counter_val>

08002994 <usart1_isr>:

Find out what interrupted and get or send data as appropriate.
*/

void usart1_isr(void)
{
 8002994:	b513      	push	{r0, r1, r4, lr}

/* Check if we were called because of RXNE. */
	if (usart_get_flag(USART1,USART_SR_RXNE))
 8002996:	481a      	ldr	r0, [pc, #104]	; (8002a00 <usart1_isr+0x6c>)
 8002998:	2120      	movs	r1, #32
 800299a:	f004 fc9e 	bl	80072da <usart_get_flag>
 800299e:	b180      	cbz	r0, 80029c2 <usart1_isr+0x2e>
	{
/* Pull in received character. If buffer full we'll just drop it */
        char inCharacter = (char) usart_recv(USART1);
 80029a0:	4817      	ldr	r0, [pc, #92]	; (8002a00 <usart1_isr+0x6c>)
 80029a2:	f004 fc96 	bl	80072d2 <usart_recv>
        if (xQueueSendToBackFromISR(commsReceiveQueue,&inCharacter,NULL) == errQUEUE_FULL)
 80029a6:	4b17      	ldr	r3, [pc, #92]	; (8002a04 <usart1_isr+0x70>)

/* Check if we were called because of RXNE. */
	if (usart_get_flag(USART1,USART_SR_RXNE))
	{
/* Pull in received character. If buffer full we'll just drop it */
        char inCharacter = (char) usart_recv(USART1);
 80029a8:	a902      	add	r1, sp, #8
        if (xQueueSendToBackFromISR(commsReceiveQueue,&inCharacter,NULL) == errQUEUE_FULL)
 80029aa:	2200      	movs	r2, #0

/* Check if we were called because of RXNE. */
	if (usart_get_flag(USART1,USART_SR_RXNE))
	{
/* Pull in received character. If buffer full we'll just drop it */
        char inCharacter = (char) usart_recv(USART1);
 80029ac:	f801 0d04 	strb.w	r0, [r1, #-4]!
        if (xQueueSendToBackFromISR(commsReceiveQueue,&inCharacter,NULL) == errQUEUE_FULL)
 80029b0:	6818      	ldr	r0, [r3, #0]
 80029b2:	4613      	mov	r3, r2
 80029b4:	f003 f9b5 	bl	8005d22 <xQueueGenericSendFromISR>
 80029b8:	b918      	cbnz	r0, 80029c2 <usart1_isr+0x2e>
            lostCharacters++;
 80029ba:	4813      	ldr	r0, [pc, #76]	; (8002a08 <usart1_isr+0x74>)
 80029bc:	6802      	ldr	r2, [r0, #0]
 80029be:	1c51      	adds	r1, r2, #1
 80029c0:	6001      	str	r1, [r0, #0]
	}
/* Check if we were called because of TXE. */
	if (usart_get_flag(USART1,USART_SR_TXE))
 80029c2:	480f      	ldr	r0, [pc, #60]	; (8002a00 <usart1_isr+0x6c>)
 80029c4:	2180      	movs	r1, #128	; 0x80
 80029c6:	f004 fc88 	bl	80072da <usart_get_flag>
 80029ca:	b1b8      	cbz	r0, 80029fc <usart1_isr+0x68>
	{
/* If the queue is empty, disable the tx interrupt until something is sent. */
    	char data;
		if (xQueueReceiveFromISR(commsSendQueue,&data,NULL))
 80029cc:	4c0f      	ldr	r4, [pc, #60]	; (8002a0c <usart1_isr+0x78>)
 80029ce:	f10d 0103 	add.w	r1, sp, #3
 80029d2:	6820      	ldr	r0, [r4, #0]
 80029d4:	2200      	movs	r2, #0
 80029d6:	f003 fa53 	bl	8005e80 <xQueueReceiveFromISR>
 80029da:	4604      	mov	r4, r0
            usart_send(USART1, data);
 80029dc:	4808      	ldr	r0, [pc, #32]	; (8002a00 <usart1_isr+0x6c>)
/* Check if we were called because of TXE. */
	if (usart_get_flag(USART1,USART_SR_TXE))
	{
/* If the queue is empty, disable the tx interrupt until something is sent. */
    	char data;
		if (xQueueReceiveFromISR(commsSendQueue,&data,NULL))
 80029de:	b124      	cbz	r4, 80029ea <usart1_isr+0x56>
            usart_send(USART1, data);
 80029e0:	f89d 1003 	ldrb.w	r1, [sp, #3]
 80029e4:	f004 fc71 	bl	80072ca <usart_send>
 80029e8:	e008      	b.n	80029fc <usart1_isr+0x68>
		else
        {
            int wokenTask;
            usart_disable_tx_interrupt(USART1);
 80029ea:	f004 fc69 	bl	80072c0 <usart_disable_tx_interrupt>
            xSemaphoreGiveFromISR(commsEmptySemaphore,&wokenTask);    /* Flag as empty */
 80029ee:	4b08      	ldr	r3, [pc, #32]	; (8002a10 <usart1_isr+0x7c>)
 80029f0:	4621      	mov	r1, r4
 80029f2:	6818      	ldr	r0, [r3, #0]
 80029f4:	aa01      	add	r2, sp, #4
 80029f6:	4623      	mov	r3, r4
 80029f8:	f003 f993 	bl	8005d22 <xQueueGenericSendFromISR>
        }
	}
}
 80029fc:	bd1c      	pop	{r2, r3, r4, pc}
 80029fe:	bf00      	nop
 8002a00:	40013800 	.word	0x40013800
 8002a04:	20000014 	.word	0x20000014
 8002a08:	200008c4 	.word	0x200008c4
 8002a0c:	2000001c 	.word	0x2000001c
 8002a10:	20000034 	.word	0x20000034

08002a14 <adc1_2_isr>:
variable.
*/

void adc1_2_isr(void)
{
    adceoc = 1;
 8002a14:	4b02      	ldr	r3, [pc, #8]	; (8002a20 <adc1_2_isr+0xc>)
 8002a16:	2201      	movs	r2, #1
 8002a18:	701a      	strb	r2, [r3, #0]
/* Clear DMA to restart at beginning of data array */
    dmaAdcSetup();
 8002a1a:	f7ff bd27 	b.w	800246c <dmaAdcSetup>
 8002a1e:	bf00      	nop
 8002a20:	20000880 	.word	0x20000880

08002a24 <asciiToInt>:

@param[in] char* buffer: externally defined buffer with the string.
@returns int32_t: integer value to be converted to ASCII form.
*/

int32_t asciiToInt(char* buffer)
 8002a24:	1e42      	subs	r2, r0, #1
{
    int32_t number = 0;
 8002a26:	2000      	movs	r0, #0
    while ((*buffer >= '0') && (*buffer <= '9'))
 8002a28:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8002a2c:	3b30      	subs	r3, #48	; 0x30
 8002a2e:	b2d9      	uxtb	r1, r3
 8002a30:	2909      	cmp	r1, #9
 8002a32:	d803      	bhi.n	8002a3c <asciiToInt+0x18>
    {
        number = number*10+(*buffer - '0');
 8002a34:	210a      	movs	r1, #10
 8002a36:	fb01 3000 	mla	r0, r1, r0, r3
 8002a3a:	e7f5      	b.n	8002a28 <asciiToInt+0x4>
        buffer++;
    }
    return number;
}
 8002a3c:	4770      	bx	lr
	...

08002a40 <intToAscii>:
@param[in] int32_t value: integer value to be converted to ASCII form.
@param[in] char* buffer: externally defined buffer to hold the result.
*/

void intToAscii(int32_t value, char* buffer)
{
 8002a40:	b570      	push	{r4, r5, r6, lr}
	uint8_t nr_digits = 0;
    uint8_t i = 0;
    char temp_buffer[25];

/* Add minus sign if negative, and form absolute */
	if (value < 0)
 8002a42:	2800      	cmp	r0, #0
@param[in] int32_t value: integer value to be converted to ASCII form.
@param[in] char* buffer: externally defined buffer to hold the result.
*/

void intToAscii(int32_t value, char* buffer)
{
 8002a44:	b088      	sub	sp, #32
	uint8_t nr_digits = 0;
    uint8_t i = 0;
    char temp_buffer[25];

/* Add minus sign if negative, and form absolute */
	if (value < 0)
 8002a46:	da04      	bge.n	8002a52 <intToAscii+0x12>
	{
		buffer[nr_digits++] = '-';
 8002a48:	222d      	movs	r2, #45	; 0x2d
 8002a4a:	700a      	strb	r2, [r1, #0]
		value = value * -1;
 8002a4c:	4240      	negs	r0, r0
    char temp_buffer[25];

/* Add minus sign if negative, and form absolute */
	if (value < 0)
	{
		buffer[nr_digits++] = '-';
 8002a4e:	2401      	movs	r4, #1
 8002a50:	e001      	b.n	8002a56 <intToAscii+0x16>
		value = value * -1;
	}
/* Stop if value is zero */
	if (value == 0) buffer[nr_digits++] = '0';
 8002a52:	d002      	beq.n	8002a5a <intToAscii+0x1a>
@param[in] char* buffer: externally defined buffer to hold the result.
*/

void intToAscii(int32_t value, char* buffer)
{
	uint8_t nr_digits = 0;
 8002a54:	2400      	movs	r4, #0
    char temp_buffer[25];

/* Add minus sign if negative, and form absolute */
	if (value < 0)
	{
		buffer[nr_digits++] = '-';
 8002a56:	2300      	movs	r3, #0
 8002a58:	e003      	b.n	8002a62 <intToAscii+0x22>
		value = value * -1;
	}
/* Stop if value is zero */
	if (value == 0) buffer[nr_digits++] = '0';
 8002a5a:	2330      	movs	r3, #48	; 0x30
 8002a5c:	700b      	strb	r3, [r1, #0]
 8002a5e:	2201      	movs	r2, #1
 8002a60:	e01d      	b.n	8002a9e <intToAscii+0x5e>
	else
    {
/* Build string in reverse */
        while (value > 0)
	    {
		    temp_buffer[i++] = "0123456789"[value % 10];
 8002a62:	ad08      	add	r5, sp, #32
 8002a64:	18ee      	adds	r6, r5, r3
 8002a66:	250a      	movs	r5, #10
 8002a68:	fb90 f2f5 	sdiv	r2, r0, r5
 8002a6c:	fb05 0012 	mls	r0, r5, r2, r0
 8002a70:	4d0d      	ldr	r5, [pc, #52]	; (8002aa8 <intToAscii+0x68>)
 8002a72:	3301      	adds	r3, #1
 8002a74:	5c28      	ldrb	r0, [r5, r0]
 8002a76:	b2db      	uxtb	r3, r3
 8002a78:	f806 0c1c 	strb.w	r0, [r6, #-28]
/* Stop if value is zero */
	if (value == 0) buffer[nr_digits++] = '0';
	else
    {
/* Build string in reverse */
        while (value > 0)
 8002a7c:	4610      	mov	r0, r2
 8002a7e:	2a00      	cmp	r2, #0
 8002a80:	d1ef      	bne.n	8002a62 <intToAscii+0x22>
	    {
		    temp_buffer[i++] = "0123456789"[value % 10];
 8002a82:	461d      	mov	r5, r3

@param[in] int32_t value: integer value to be converted to ASCII form.
@param[in] char* buffer: externally defined buffer to hold the result.
*/

void intToAscii(int32_t value, char* buffer)
 8002a84:	192a      	adds	r2, r5, r4
 8002a86:	b2d2      	uxtb	r2, r2
 8002a88:	1ad0      	subs	r0, r2, r3
 8002a8a:	b2c0      	uxtb	r0, r0
	    {
		    temp_buffer[i++] = "0123456789"[value % 10];
		    value /= 10;
	    }
/* Copy across correcting the order */
        while (i > 0)
 8002a8c:	b13b      	cbz	r3, 8002a9e <intToAscii+0x5e>
        {
            buffer[nr_digits++] = temp_buffer[--i];
 8002a8e:	1e5e      	subs	r6, r3, #1
 8002a90:	b2f3      	uxtb	r3, r6
 8002a92:	ae08      	add	r6, sp, #32
 8002a94:	18f2      	adds	r2, r6, r3
 8002a96:	f812 2c1c 	ldrb.w	r2, [r2, #-28]
 8002a9a:	540a      	strb	r2, [r1, r0]
 8002a9c:	e7f2      	b.n	8002a84 <intToAscii+0x44>
        }
    }
    buffer[nr_digits] = 0;
 8002a9e:	2300      	movs	r3, #0
 8002aa0:	548b      	strb	r3, [r1, r2]
}
 8002aa2:	b008      	add	sp, #32
 8002aa4:	bd70      	pop	{r4, r5, r6, pc}
 8002aa6:	bf00      	nop
 8002aa8:	08007555 	.word	0x08007555

08002aac <stringCopy>:
@param[in] char* original: original string to be copied.
*/

void stringCopy(char* string, char* original)
{
    uint8_t i=0;
 8002aac:	2300      	movs	r3, #0
    while (original[i] > 0)
 8002aae:	5cca      	ldrb	r2, [r1, r3]
    {
        string[i] = original[i];
 8002ab0:	54c2      	strb	r2, [r0, r3]
*/

void stringCopy(char* string, char* original)
{
    uint8_t i=0;
    while (original[i] > 0)
 8002ab2:	b112      	cbz	r2, 8002aba <stringCopy+0xe>
    {
        string[i] = original[i];
        i++;
 8002ab4:	3301      	adds	r3, #1
 8002ab6:	b2db      	uxtb	r3, r3
 8002ab8:	e7f9      	b.n	8002aae <stringCopy+0x2>
    }
    string[i] = 0;
 8002aba:	4770      	bx	lr

08002abc <stringLength>:
@param[in] char* string: string to be measured for length.
@returns int16_t: length of string.
*/

uint16_t stringLength(char* string)
{
 8002abc:	4602      	mov	r2, r0
    uint8_t i=0;
 8002abe:	2000      	movs	r0, #0
    while (string[i] > 0) i++;
 8002ac0:	5c13      	ldrb	r3, [r2, r0]
 8002ac2:	b113      	cbz	r3, 8002aca <stringLength+0xe>
 8002ac4:	3001      	adds	r0, #1
 8002ac6:	b2c0      	uxtb	r0, r0
 8002ac8:	e7fa      	b.n	8002ac0 <stringLength+0x4>
    return i;
}
 8002aca:	4770      	bx	lr

08002acc <stringAppend>:
@param[in] char* string: original string, returned after appending.
@param[in] char* appendage: string to be appended to end.
*/

void stringAppend(char* string, char* appendage)
{
 8002acc:	b570      	push	{r4, r5, r6, lr}
 8002ace:	4604      	mov	r4, r0
 8002ad0:	460e      	mov	r6, r1
    uint8_t i=0;
    uint8_t j=stringLength(string);
 8002ad2:	f7ff fff3 	bl	8002abc <stringLength>
    while (appendage[i] > 0)
 8002ad6:	2300      	movs	r3, #0
*/

void stringAppend(char* string, char* appendage)
{
    uint8_t i=0;
    uint8_t j=stringLength(string);
 8002ad8:	b2c0      	uxtb	r0, r0
    while (appendage[i] > 0)
 8002ada:	b2da      	uxtb	r2, r3

@param[in] char* string: original string, returned after appending.
@param[in] char* appendage: string to be appended to end.
*/

void stringAppend(char* string, char* appendage)
 8002adc:	18c5      	adds	r5, r0, r3
{
    uint8_t i=0;
    uint8_t j=stringLength(string);
    while (appendage[i] > 0)
 8002ade:	5cb1      	ldrb	r1, [r6, r2]

@param[in] char* string: original string, returned after appending.
@param[in] char* appendage: string to be appended to end.
*/

void stringAppend(char* string, char* appendage)
 8002ae0:	b2ed      	uxtb	r5, r5
 8002ae2:	3301      	adds	r3, #1
{
    uint8_t i=0;
    uint8_t j=stringLength(string);
    while (appendage[i] > 0)
    {
        string[j++] = appendage[i++];
 8002ae4:	5561      	strb	r1, [r4, r5]

void stringAppend(char* string, char* appendage)
{
    uint8_t i=0;
    uint8_t j=stringLength(string);
    while (appendage[i] > 0)
 8002ae6:	2900      	cmp	r1, #0
 8002ae8:	d1f7      	bne.n	8002ada <stringAppend+0xe>
    {
        string[j++] = appendage[i++];
    }
    string[j] = 0;
 8002aea:	bd70      	pop	{r4, r5, r6, pc}

08002aec <stringEqual>:
@param[in] char* string2: 
@returns uint8_t: 1 if strings are equal, 0 otherwise.
*/

uint16_t stringEqual(char* string1,char* string2)
{
 8002aec:	b510      	push	{r4, lr}
    while (*string1 > 0)
 8002aee:	2300      	movs	r3, #0
 8002af0:	5cc2      	ldrb	r2, [r0, r3]
 8002af2:	b13a      	cbz	r2, 8002b04 <stringEqual+0x18>
 8002af4:	3301      	adds	r3, #1
@param[in] char* string1: 
@param[in] char* string2: 
@returns uint8_t: 1 if strings are equal, 0 otherwise.
*/

uint16_t stringEqual(char* string1,char* string2)
 8002af6:	18cc      	adds	r4, r1, r3
{
    while (*string1 > 0)
    {
        if (*string1 != *string2) return 0;
 8002af8:	f814 4c01 	ldrb.w	r4, [r4, #-1]
 8002afc:	4294      	cmp	r4, r2
 8002afe:	d0f7      	beq.n	8002af0 <stringEqual+0x4>
 8002b00:	2000      	movs	r0, #0
        string1++;
        string2++;
    }
    return 1;
}
 8002b02:	bd10      	pop	{r4, pc}
    {
        if (*string1 != *string2) return 0;
        string1++;
        string2++;
    }
    return 1;
 8002b04:	2001      	movs	r0, #1
 8002b06:	bd10      	pop	{r4, pc}

08002b08 <putTimeToString>:

@param[out] timeString char*. Returns pointer to string with formatted date.
*/

void putTimeToString(char* timeString)
{
 8002b08:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002b0c:	b087      	sub	sp, #28
 8002b0e:	4604      	mov	r4, r0
    uint32_t timeCounter = getTimeCounter();
 8002b10:	f7ff ff3c 	bl	800298c <getTimeCounter>
    uint8_t second = timeCounter % 60;
 8002b14:	233c      	movs	r3, #60	; 0x3c
 8002b16:	fbb0 f2f3 	udiv	r2, r0, r3
 8002b1a:	fb03 0512 	mls	r5, r3, r2, r0
    uint8_t minute = (timeCounter/60) % 60;
 8002b1e:	fbb2 f6f3 	udiv	r6, r2, r3
*/

void putTimeToString(char* timeString)
{
    uint32_t timeCounter = getTimeCounter();
    uint8_t second = timeCounter % 60;
 8002b22:	b2e9      	uxtb	r1, r5
    uint8_t minute = (timeCounter/60) % 60;
    uint8_t hour = (timeCounter/3600) % 24;
 8002b24:	f44f 6761 	mov.w	r7, #3600	; 0xe10

void putTimeToString(char* timeString)
{
    uint32_t timeCounter = getTimeCounter();
    uint8_t second = timeCounter % 60;
    uint8_t minute = (timeCounter/60) % 60;
 8002b28:	fb03 2616 	mls	r6, r3, r6, r2
*/

void putTimeToString(char* timeString)
{
    uint32_t timeCounter = getTimeCounter();
    uint8_t second = timeCounter % 60;
 8002b2c:	9101      	str	r1, [sp, #4]
    uint8_t minute = (timeCounter/60) % 60;
    uint8_t hour = (timeCounter/3600) % 24;
 8002b2e:	2318      	movs	r3, #24
 8002b30:	fbb0 f1f7 	udiv	r1, r0, r7
 8002b34:	fbb1 f2f3 	udiv	r2, r1, r3
 8002b38:	fb03 1712 	mls	r7, r3, r2, r1
    uint16_t day = (uint16_t)(timeCounter/86400);
 8002b3c:	494d      	ldr	r1, [pc, #308]	; (8002c74 <putTimeToString+0x16c>)

void putTimeToString(char* timeString)
{
    uint32_t timeCounter = getTimeCounter();
    uint8_t second = timeCounter % 60;
    uint8_t minute = (timeCounter/60) % 60;
 8002b3e:	fa5f f986 	uxtb.w	r9, r6
    uint8_t hour = (timeCounter/3600) % 24;
    uint16_t day = (uint16_t)(timeCounter/86400);
 8002b42:	fbb0 f0f1 	udiv	r0, r0, r1
 8002b46:	b283      	uxth	r3, r0
void putTimeToString(char* timeString)
{
    uint32_t timeCounter = getTimeCounter();
    uint8_t second = timeCounter % 60;
    uint8_t minute = (timeCounter/60) % 60;
    uint8_t hour = (timeCounter/3600) % 24;
 8002b48:	fa5f fa87 	uxtb.w	sl, r7
    uint16_t day = (uint16_t)(timeCounter/86400);
	uint16_t year = 0;
    uint16_t dayOfYear = 365;
 8002b4c:	f240 116d 	movw	r1, #365	; 0x16d
    uint32_t timeCounter = getTimeCounter();
    uint8_t second = timeCounter % 60;
    uint8_t minute = (timeCounter/60) % 60;
    uint8_t hour = (timeCounter/3600) % 24;
    uint16_t day = (uint16_t)(timeCounter/86400);
	uint16_t year = 0;
 8002b50:	2000      	movs	r0, #0
/* Break down into years since 2000 and number of days left in the month */
	for(;;)
    {
        dayOfLastYear = dayOfYear;
		if ((year & 0x03) == 0) dayOfYear = 366;
        else  dayOfYear = 365;
 8002b52:	f010 0f03 	tst.w	r0, #3
 8002b56:	f240 126d 	movw	r2, #365	; 0x16d
 8002b5a:	bf08      	it	eq
 8002b5c:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
		if (day < dayOfYear) break;
 8002b60:	4293      	cmp	r3, r2
 8002b62:	d305      	bcc.n	8002b70 <putTimeToString+0x68>
		day -= dayOfYear;
		year++;
 8002b64:	1c41      	adds	r1, r0, #1
    {
        dayOfLastYear = dayOfYear;
		if ((year & 0x03) == 0) dayOfYear = 366;
        else  dayOfYear = 365;
		if (day < dayOfYear) break;
		day -= dayOfYear;
 8002b66:	1a9b      	subs	r3, r3, r2
		year++;
 8002b68:	b288      	uxth	r0, r1
    {
        dayOfLastYear = dayOfYear;
		if ((year & 0x03) == 0) dayOfYear = 366;
        else  dayOfYear = 365;
		if (day < dayOfYear) break;
		day -= dayOfYear;
 8002b6a:	b29b      	uxth	r3, r3
		year++;
	}
 8002b6c:	4611      	mov	r1, r2
 8002b6e:	e7f0      	b.n	8002b52 <putTimeToString+0x4a>
	year += 2000;
 8002b70:	f500 62fa 	add.w	r2, r0, #2000	; 0x7d0
 8002b74:	b290      	uxth	r0, r2

/* Add in Feb 29 if the last year was a leap year (quirk of above loop) */
	if((dayOfLastYear & 1) && (day > 58)) day++;
 8002b76:	07ca      	lsls	r2, r1, #31
 8002b78:	d503      	bpl.n	8002b82 <putTimeToString+0x7a>
 8002b7a:	2b3a      	cmp	r3, #58	; 0x3a
 8002b7c:	d901      	bls.n	8002b82 <putTimeToString+0x7a>
 8002b7e:	3301      	adds	r3, #1
 8002b80:	b29b      	uxth	r3, r3
	for(;;)
    {
        dayOfLastYear = dayOfYear;
		if ((year & 0x03) == 0) dayOfYear = 366;
        else  dayOfYear = 365;
		if (day < dayOfYear) break;
 8002b82:	f04f 0801 	mov.w	r8, #1

/* Add in Feb 29 if the last year was a leap year (quirk of above loop) */
	if((dayOfLastYear & 1) && (day > 58)) day++;

	uint8_t month;
	for(month = 1; day >= DaysInMonth[month-1]; month++)
 8002b86:	493c      	ldr	r1, [pc, #240]	; (8002c78 <putTimeToString+0x170>)
 8002b88:	eb01 0208 	add.w	r2, r1, r8
 8002b8c:	f812 1c01 	ldrb.w	r1, [r2, #-1]
 8002b90:	428b      	cmp	r3, r1
 8002b92:	d306      	bcc.n	8002ba2 <putTimeToString+0x9a>
		day -= DaysInMonth[month-1];
 8002b94:	1a5a      	subs	r2, r3, r1

/* Add in Feb 29 if the last year was a leap year (quirk of above loop) */
	if((dayOfLastYear & 1) && (day > 58)) day++;

	uint8_t month;
	for(month = 1; day >= DaysInMonth[month-1]; month++)
 8002b96:	f108 0101 	add.w	r1, r8, #1
		day -= DaysInMonth[month-1];
 8002b9a:	b293      	uxth	r3, r2

/* Add in Feb 29 if the last year was a leap year (quirk of above loop) */
	if((dayOfLastYear & 1) && (day > 58)) day++;

	uint8_t month;
	for(month = 1; day >= DaysInMonth[month-1]; month++)
 8002b9c:	fa5f f881 	uxtb.w	r8, r1
 8002ba0:	e7f1      	b.n	8002b86 <putTimeToString+0x7e>
		day -= DaysInMonth[month-1];

	uint8_t dayOfMonth = day + 1;
 8002ba2:	3301      	adds	r3, #1
    char buffer[10];
    intToAscii(year, timeString);
 8002ba4:	4621      	mov	r1, r4

	uint8_t month;
	for(month = 1; day >= DaysInMonth[month-1]; month++)
		day -= DaysInMonth[month-1];

	uint8_t dayOfMonth = day + 1;
 8002ba6:	fa5f fb83 	uxtb.w	fp, r3
    char buffer[10];
    intToAscii(year, timeString);
 8002baa:	f7ff ff49 	bl	8002a40 <intToAscii>
    stringAppend(timeString,"-");
 8002bae:	4620      	mov	r0, r4
 8002bb0:	4932      	ldr	r1, [pc, #200]	; (8002c7c <putTimeToString+0x174>)
 8002bb2:	f7ff ff8b 	bl	8002acc <stringAppend>
    if (month < 10) stringAppend(timeString,"0");
 8002bb6:	f1b8 0f09 	cmp.w	r8, #9
 8002bba:	d803      	bhi.n	8002bc4 <putTimeToString+0xbc>
 8002bbc:	4620      	mov	r0, r4
 8002bbe:	4930      	ldr	r1, [pc, #192]	; (8002c80 <putTimeToString+0x178>)
 8002bc0:	f7ff ff84 	bl	8002acc <stringAppend>
    intToAscii(month, buffer);
 8002bc4:	4640      	mov	r0, r8
 8002bc6:	a903      	add	r1, sp, #12
 8002bc8:	f7ff ff3a 	bl	8002a40 <intToAscii>
    stringAppend(timeString,buffer);
 8002bcc:	4620      	mov	r0, r4
 8002bce:	a903      	add	r1, sp, #12
 8002bd0:	f7ff ff7c 	bl	8002acc <stringAppend>
    stringAppend(timeString,"-");
 8002bd4:	4620      	mov	r0, r4
 8002bd6:	4929      	ldr	r1, [pc, #164]	; (8002c7c <putTimeToString+0x174>)
 8002bd8:	f7ff ff78 	bl	8002acc <stringAppend>
    if (dayOfMonth < 10) stringAppend(timeString,"0");
 8002bdc:	f1bb 0f09 	cmp.w	fp, #9
 8002be0:	d803      	bhi.n	8002bea <putTimeToString+0xe2>
 8002be2:	4620      	mov	r0, r4
 8002be4:	4926      	ldr	r1, [pc, #152]	; (8002c80 <putTimeToString+0x178>)
 8002be6:	f7ff ff71 	bl	8002acc <stringAppend>
    intToAscii(dayOfMonth, buffer);
 8002bea:	4658      	mov	r0, fp
 8002bec:	a903      	add	r1, sp, #12
 8002bee:	f7ff ff27 	bl	8002a40 <intToAscii>
    stringAppend(timeString,buffer);
 8002bf2:	4620      	mov	r0, r4
 8002bf4:	a903      	add	r1, sp, #12
 8002bf6:	f7ff ff69 	bl	8002acc <stringAppend>
    stringAppend(timeString,"T");
 8002bfa:	4620      	mov	r0, r4
 8002bfc:	4921      	ldr	r1, [pc, #132]	; (8002c84 <putTimeToString+0x17c>)
 8002bfe:	f7ff ff65 	bl	8002acc <stringAppend>
    intToAscii(hour, buffer);
 8002c02:	4638      	mov	r0, r7
 8002c04:	a903      	add	r1, sp, #12
 8002c06:	f7ff ff1b 	bl	8002a40 <intToAscii>
    if (hour < 10) stringAppend(timeString,"0");
 8002c0a:	f1ba 0f09 	cmp.w	sl, #9
 8002c0e:	d803      	bhi.n	8002c18 <putTimeToString+0x110>
 8002c10:	4620      	mov	r0, r4
 8002c12:	491b      	ldr	r1, [pc, #108]	; (8002c80 <putTimeToString+0x178>)
 8002c14:	f7ff ff5a 	bl	8002acc <stringAppend>
    stringAppend(timeString,buffer);
 8002c18:	4620      	mov	r0, r4
 8002c1a:	a903      	add	r1, sp, #12
 8002c1c:	f7ff ff56 	bl	8002acc <stringAppend>
    stringAppend(timeString,":");
 8002c20:	4620      	mov	r0, r4
 8002c22:	4919      	ldr	r1, [pc, #100]	; (8002c88 <putTimeToString+0x180>)
 8002c24:	f7ff ff52 	bl	8002acc <stringAppend>
    intToAscii(minute, buffer);
 8002c28:	4630      	mov	r0, r6
 8002c2a:	a903      	add	r1, sp, #12
 8002c2c:	f7ff ff08 	bl	8002a40 <intToAscii>
    if (minute < 10) stringAppend(timeString,"0");
 8002c30:	f1b9 0f09 	cmp.w	r9, #9
 8002c34:	d803      	bhi.n	8002c3e <putTimeToString+0x136>
 8002c36:	4620      	mov	r0, r4
 8002c38:	4911      	ldr	r1, [pc, #68]	; (8002c80 <putTimeToString+0x178>)
 8002c3a:	f7ff ff47 	bl	8002acc <stringAppend>
    stringAppend(timeString,buffer);
 8002c3e:	4620      	mov	r0, r4
 8002c40:	a903      	add	r1, sp, #12
 8002c42:	f7ff ff43 	bl	8002acc <stringAppend>
    stringAppend(timeString,":");
 8002c46:	4620      	mov	r0, r4
 8002c48:	490f      	ldr	r1, [pc, #60]	; (8002c88 <putTimeToString+0x180>)
 8002c4a:	f7ff ff3f 	bl	8002acc <stringAppend>
    intToAscii(second, buffer);
 8002c4e:	4628      	mov	r0, r5
 8002c50:	a903      	add	r1, sp, #12
 8002c52:	f7ff fef5 	bl	8002a40 <intToAscii>
    if (second < 10) stringAppend(timeString,"0");
 8002c56:	9801      	ldr	r0, [sp, #4]
 8002c58:	2809      	cmp	r0, #9
 8002c5a:	d803      	bhi.n	8002c64 <putTimeToString+0x15c>
 8002c5c:	4620      	mov	r0, r4
 8002c5e:	4908      	ldr	r1, [pc, #32]	; (8002c80 <putTimeToString+0x178>)
 8002c60:	f7ff ff34 	bl	8002acc <stringAppend>
    stringAppend(timeString,buffer);
 8002c64:	4620      	mov	r0, r4
 8002c66:	a903      	add	r1, sp, #12
 8002c68:	f7ff ff30 	bl	8002acc <stringAppend>
}
 8002c6c:	b007      	add	sp, #28
 8002c6e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002c72:	bf00      	nop
 8002c74:	00015180 	.word	0x00015180
 8002c78:	08007566 	.word	0x08007566
 8002c7c:	08007560 	.word	0x08007560
 8002c80:	08007562 	.word	0x08007562
 8002c84:	08007526 	.word	0x08007526
 8002c88:	08007564 	.word	0x08007564

08002c8c <setTimeFromString>:

@param[in] isoTime: pointer to string with formatted date.
*/

void setTimeFromString(char* timeString)
{
 8002c8c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8002c90:	2300      	movs	r3, #0
 8002c92:	4604      	mov	r4, r0
    char buffer[5];
	uint8_t i;
	uint32_t days = 0;

    for (i=0; i<4; i++) buffer[i] = timeString[i];
 8002c94:	5ce2      	ldrb	r2, [r4, r3]
 8002c96:	f80d 2003 	strb.w	r2, [sp, r3]
 8002c9a:	3301      	adds	r3, #1
 8002c9c:	2b04      	cmp	r3, #4
 8002c9e:	d1f9      	bne.n	8002c94 <setTimeFromString+0x8>
    buffer[4] = 0;
 8002ca0:	2500      	movs	r5, #0
    uint16_t year = asciiToInt(buffer);
 8002ca2:	4668      	mov	r0, sp
    char buffer[5];
	uint8_t i;
	uint32_t days = 0;

    for (i=0; i<4; i++) buffer[i] = timeString[i];
    buffer[4] = 0;
 8002ca4:	f88d 5004 	strb.w	r5, [sp, #4]
    uint16_t year = asciiToInt(buffer);
 8002ca8:	f7ff febc 	bl	8002a24 <asciiToInt>
 8002cac:	fa1f fa80 	uxth.w	sl, r0
    for (i=0; i<2; i++) buffer[i] = timeString[i+5];
 8002cb0:	7960      	ldrb	r0, [r4, #5]
 8002cb2:	79a1      	ldrb	r1, [r4, #6]
 8002cb4:	f88d 0000 	strb.w	r0, [sp]
    buffer[2] = 0;
    uint16_t month = asciiToInt(buffer);
 8002cb8:	4668      	mov	r0, sp
	uint32_t days = 0;

    for (i=0; i<4; i++) buffer[i] = timeString[i];
    buffer[4] = 0;
    uint16_t year = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+5];
 8002cba:	f88d 1001 	strb.w	r1, [sp, #1]
    buffer[2] = 0;
 8002cbe:	f88d 5002 	strb.w	r5, [sp, #2]
    uint16_t month = asciiToInt(buffer);
 8002cc2:	f7ff feaf 	bl	8002a24 <asciiToInt>
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
 8002cc6:	7a62      	ldrb	r2, [r4, #9]
 8002cc8:	7a27      	ldrb	r7, [r4, #8]
    for (i=0; i<4; i++) buffer[i] = timeString[i];
    buffer[4] = 0;
    uint16_t year = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+5];
    buffer[2] = 0;
    uint16_t month = asciiToInt(buffer);
 8002cca:	4606      	mov	r6, r0
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
    uint16_t dayOfMonth = asciiToInt(buffer);
 8002ccc:	4668      	mov	r0, sp
    buffer[4] = 0;
    uint16_t year = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+5];
    buffer[2] = 0;
    uint16_t month = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
 8002cce:	f88d 2001 	strb.w	r2, [sp, #1]
 8002cd2:	f88d 7000 	strb.w	r7, [sp]
    uint16_t dayOfMonth = asciiToInt(buffer);
 8002cd6:	f7ff fea5 	bl	8002a24 <asciiToInt>
 8002cda:	4607      	mov	r7, r0
    for (i=0; i<2; i++) buffer[i] = timeString[i+11];
 8002cdc:	7b20      	ldrb	r0, [r4, #12]
 8002cde:	7ae3      	ldrb	r3, [r4, #11]
 8002ce0:	f88d 0001 	strb.w	r0, [sp, #1]
    uint16_t hour = asciiToInt(buffer);
 8002ce4:	4668      	mov	r0, sp
    for (i=0; i<2; i++) buffer[i] = timeString[i+5];
    buffer[2] = 0;
    uint16_t month = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
    uint16_t dayOfMonth = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+11];
 8002ce6:	f88d 3000 	strb.w	r3, [sp]
    uint16_t hour = asciiToInt(buffer);
 8002cea:	f7ff fe9b 	bl	8002a24 <asciiToInt>
    for (i=0; i<2; i++) buffer[i] = timeString[i+14];
 8002cee:	7ba1      	ldrb	r1, [r4, #14]
 8002cf0:	7be2      	ldrb	r2, [r4, #15]
    buffer[2] = 0;
    uint16_t month = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
    uint16_t dayOfMonth = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+11];
    uint16_t hour = asciiToInt(buffer);
 8002cf2:	4681      	mov	r9, r0
    for (i=0; i<2; i++) buffer[i] = timeString[i+14];
    uint16_t minute = asciiToInt(buffer);
 8002cf4:	4668      	mov	r0, sp
    uint16_t month = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
    uint16_t dayOfMonth = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+11];
    uint16_t hour = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+14];
 8002cf6:	f88d 1000 	strb.w	r1, [sp]
 8002cfa:	f88d 2001 	strb.w	r2, [sp, #1]
    uint16_t minute = asciiToInt(buffer);
 8002cfe:	f7ff fe91 	bl	8002a24 <asciiToInt>
    for (i=0; i<2; i++) buffer[i] = timeString[i+17];
 8002d02:	7c63      	ldrb	r3, [r4, #17]
 8002d04:	7ca4      	ldrb	r4, [r4, #18]
    for (i=0; i<2; i++) buffer[i] = timeString[i+8];
    uint16_t dayOfMonth = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+11];
    uint16_t hour = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+14];
    uint16_t minute = asciiToInt(buffer);
 8002d06:	4680      	mov	r8, r0
    for (i=0; i<2; i++) buffer[i] = timeString[i+17];
    uint16_t second = asciiToInt(buffer);
 8002d08:	4668      	mov	r0, sp
    uint16_t dayOfMonth = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+11];
    uint16_t hour = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+14];
    uint16_t minute = asciiToInt(buffer);
    for (i=0; i<2; i++) buffer[i] = timeString[i+17];
 8002d0a:	f88d 3000 	strb.w	r3, [sp]
 8002d0e:	f88d 4001 	strb.w	r4, [sp, #1]
    uint16_t second = asciiToInt(buffer);
 8002d12:	f7ff fe87 	bl	8002a24 <asciiToInt>

	/* Calculate days of years after 2000 */
    year -= 2000;
 8002d16:	f5aa 61fa 	sub.w	r1, sl, #2000	; 0x7d0
 8002d1a:	b289      	uxth	r1, r1
	days = (uint32_t)year * 365;
    days += (year+3)/4;
 8002d1c:	1cca      	adds	r2, r1, #3
 8002d1e:	1093      	asrs	r3, r2, #2
 8002d20:	f240 146d 	movw	r4, #365	; 0x16d
 8002d24:	fb04 3301 	mla	r3, r4, r1, r3

	/* Loop thru each month, adding the days */
	for (i = 0; i < month - 1; i++) days += DaysInMonth[i];
 8002d28:	462a      	mov	r2, r5
 8002d2a:	b2b4      	uxth	r4, r6
 8002d2c:	3c01      	subs	r4, #1
 8002d2e:	42a2      	cmp	r2, r4
 8002d30:	da05      	bge.n	8002d3e <setTimeFromString+0xb2>
 8002d32:	4c12      	ldr	r4, [pc, #72]	; (8002d7c <setTimeFromString+0xf0>)
 8002d34:	5ca4      	ldrb	r4, [r4, r2]
 8002d36:	3201      	adds	r2, #1
 8002d38:	191b      	adds	r3, r3, r4
 8002d3a:	b2d2      	uxtb	r2, r2
 8002d3c:	e7f5      	b.n	8002d2a <setTimeFromString+0x9e>

	/* Leap year? adjust February */
	if (((year & 0x03) == 0) && (month > 2)) days++;
 8002d3e:	0789      	lsls	r1, r1, #30
 8002d40:	d103      	bne.n	8002d4a <setTimeFromString+0xbe>
 8002d42:	b2b6      	uxth	r6, r6
 8002d44:	2e02      	cmp	r6, #2
 8002d46:	bf88      	it	hi
 8002d48:	3301      	addhi	r3, #1
	/* Convert to seconds, add all the other stuff */
	uint32_t seconds = (days-1) * 86400L + (uint32_t)hour * 3600 +
		(uint32_t)minute * 60 + second;

	setTimeCounter(seconds);
}
 8002d4a:	b280      	uxth	r0, r0

	/* Add remaining days */
	days += dayOfMonth;

	/* Convert to seconds, add all the other stuff */
	uint32_t seconds = (days-1) * 86400L + (uint32_t)hour * 3600 +
 8002d4c:	f5a0 31a8 	sub.w	r1, r0, #86016	; 0x15000
 8002d50:	f5a1 72c0 	sub.w	r2, r1, #384	; 0x180
 8002d54:	f44f 6061 	mov.w	r0, #3600	; 0xe10
		(uint32_t)minute * 60 + second;

	setTimeCounter(seconds);
}
 8002d58:	fa1f f989 	uxth.w	r9, r9

	/* Add remaining days */
	days += dayOfMonth;

	/* Convert to seconds, add all the other stuff */
	uint32_t seconds = (days-1) * 86400L + (uint32_t)hour * 3600 +
 8002d5c:	fb00 2909 	mla	r9, r0, r9, r2
		(uint32_t)minute * 60 + second;
 8002d60:	213c      	movs	r1, #60	; 0x3c

	setTimeCounter(seconds);
}
 8002d62:	fa1f f888 	uxth.w	r8, r8
	/* Add remaining days */
	days += dayOfMonth;

	/* Convert to seconds, add all the other stuff */
	uint32_t seconds = (days-1) * 86400L + (uint32_t)hour * 3600 +
		(uint32_t)minute * 60 + second;
 8002d66:	fb01 9808 	mla	r8, r1, r8, r9

	setTimeCounter(seconds);
}
 8002d6a:	b2bf      	uxth	r7, r7

	/* Convert to seconds, add all the other stuff */
	uint32_t seconds = (days-1) * 86400L + (uint32_t)hour * 3600 +
		(uint32_t)minute * 60 + second;

	setTimeCounter(seconds);
 8002d6c:	4a04      	ldr	r2, [pc, #16]	; (8002d80 <setTimeFromString+0xf4>)

	/* Leap year? adjust February */
	if (((year & 0x03) == 0) && (month > 2)) days++;

	/* Add remaining days */
	days += dayOfMonth;
 8002d6e:	19db      	adds	r3, r3, r7

	/* Convert to seconds, add all the other stuff */
	uint32_t seconds = (days-1) * 86400L + (uint32_t)hour * 3600 +
		(uint32_t)minute * 60 + second;

	setTimeCounter(seconds);
 8002d70:	fb02 8003 	mla	r0, r2, r3, r8
 8002d74:	f7ff fe0c 	bl	8002990 <setTimeCounter>
}
 8002d78:	e8bd 87fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
 8002d7c:	08007566 	.word	0x08007566
 8002d80:	00015180 	.word	0x00015180

08002d84 <writeConfigBlock>:
@returns result code. 0 success, 1 fail.
*/

uint32_t writeConfigBlock(void)
{
    configData.config.validBlock = VALID_BLOCK;
 8002d84:	4903      	ldr	r1, [pc, #12]	; (8002d94 <writeConfigBlock+0x10>)
    return flashWriteData((uint32_t*)configDataBlock.data,
 8002d86:	4804      	ldr	r0, [pc, #16]	; (8002d98 <writeConfigBlock+0x14>)
@returns result code. 0 success, 1 fail.
*/

uint32_t writeConfigBlock(void)
{
    configData.config.validBlock = VALID_BLOCK;
 8002d88:	23d5      	movs	r3, #213	; 0xd5
    return flashWriteData((uint32_t*)configDataBlock.data,
 8002d8a:	2250      	movs	r2, #80	; 0x50
@returns result code. 0 success, 1 fail.
*/

uint32_t writeConfigBlock(void)
{
    configData.config.validBlock = VALID_BLOCK;
 8002d8c:	700b      	strb	r3, [r1, #0]
    return flashWriteData((uint32_t*)configDataBlock.data,
 8002d8e:	f7ff bdc5 	b.w	800291c <flashWriteData>
 8002d92:	bf00      	nop
 8002d94:	200008c8 	.word	0x200008c8
 8002d98:	08007800 	.word	0x08007800

08002d9c <setBatteryChargeParameters>:
@param[in] battery: 0..NUM_BATS-1
*/

void setBatteryChargeParameters(int battery)
{
    if (configData.config.batteryType[battery] == wetT)
 8002d9c:	4b1a      	ldr	r3, [pc, #104]	; (8002e08 <setBatteryChargeParameters+0x6c>)
 8002d9e:	181a      	adds	r2, r3, r0
 8002da0:	7a11      	ldrb	r1, [r2, #8]
 8002da2:	b941      	cbnz	r1, 8002db6 <setBatteryChargeParameters+0x1a>
    {
        configData.config.absorptionVoltage[battery] = 3712;        /* 14.5V */
 8002da4:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8002da8:	f44f 6268 	mov.w	r2, #3712	; 0xe80
 8002dac:	819a      	strh	r2, [r3, #12]
        configData.config.floatVoltage[battery] = 3379;             /* 13.2V */
 8002dae:	4619      	mov	r1, r3
 8002db0:	f640 5333 	movw	r3, #3379	; 0xd33
 8002db4:	e014      	b.n	8002de0 <setBatteryChargeParameters+0x44>
    }
    else if (configData.config.batteryType[battery] == agmT)
 8002db6:	2902      	cmp	r1, #2
 8002db8:	d108      	bne.n	8002dcc <setBatteryChargeParameters+0x30>
    {
        configData.config.absorptionVoltage[battery] = 3738;        /* 14.6V */
 8002dba:	eb03 0240 	add.w	r2, r3, r0, lsl #1
 8002dbe:	f640 619a 	movw	r1, #3738	; 0xe9a
 8002dc2:	8191      	strh	r1, [r2, #12]
        configData.config.floatVoltage[battery] = 3482;             /* 13.6V */
 8002dc4:	f640 539a 	movw	r3, #3482	; 0xd9a
 8002dc8:	4611      	mov	r1, r2
 8002dca:	e009      	b.n	8002de0 <setBatteryChargeParameters+0x44>
    }
    else if (configData.config.batteryType[battery] == gelT)
 8002dcc:	2901      	cmp	r1, #1
 8002dce:	d108      	bne.n	8002de2 <setBatteryChargeParameters+0x46>
    {
        configData.config.absorptionVoltage[battery] = 3610;        /* 14.1V */
 8002dd0:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8002dd4:	f640 621a 	movw	r2, #3610	; 0xe1a
 8002dd8:	819a      	strh	r2, [r3, #12]
        configData.config.floatVoltage[battery] = 3532;             /* 13.8V */
 8002dda:	4619      	mov	r1, r3
 8002ddc:	f640 53cc 	movw	r3, #3532	; 0xdcc
 8002de0:	824b      	strh	r3, [r1, #18]
    }
    configData.config.floatStageCurrentScale[battery] =
 8002de2:	4b09      	ldr	r3, [pc, #36]	; (8002e08 <setBatteryChargeParameters+0x6c>)
 8002de4:	f100 010c 	add.w	r1, r0, #12
                configData.config.batteryCapacity[battery]*256/50;
 8002de8:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 8002dec:	8842      	ldrh	r2, [r0, #2]
 8002dee:	2032      	movs	r0, #50	; 0x32
 8002df0:	0212      	lsls	r2, r2, #8
 8002df2:	fb92 f0f0 	sdiv	r0, r2, r0
    else if (configData.config.batteryType[battery] == gelT)
    {
        configData.config.absorptionVoltage[battery] = 3610;        /* 14.1V */
        configData.config.floatVoltage[battery] = 3532;             /* 13.8V */
    }
    configData.config.floatStageCurrentScale[battery] =
 8002df6:	f823 0011 	strh.w	r0, [r3, r1, lsl #1]
                configData.config.batteryCapacity[battery]*256/50;
    configData.config.bulkCurrentLimitScale[battery] =
 8002dfa:	eb03 0341 	add.w	r3, r3, r1, lsl #1
        configData.config.batteryCapacity[battery]*256/5;
 8002dfe:	2105      	movs	r1, #5
 8002e00:	fb92 f2f1 	sdiv	r2, r2, r1
        configData.config.absorptionVoltage[battery] = 3610;        /* 14.1V */
        configData.config.floatVoltage[battery] = 3532;             /* 13.8V */
    }
    configData.config.floatStageCurrentScale[battery] =
                configData.config.batteryCapacity[battery]*256/50;
    configData.config.bulkCurrentLimitScale[battery] =
 8002e04:	80da      	strh	r2, [r3, #6]
 8002e06:	4770      	bx	lr
 8002e08:	200008c8 	.word	0x200008c8

08002e0c <setGlobalDefaults>:
determine if the block is a valid configuration block. This allows the program
to determine whether to use the block stored in FLASH or to use defaults.
*/

void setGlobalDefaults(void)
{
 8002e0c:	b570      	push	{r4, r5, r6, lr}
    flashReadData((uint32_t*)configDataBlock.data,
                   configData.data,sizeof(configData.config));
 8002e0e:	4c21      	ldr	r4, [pc, #132]	; (8002e94 <setGlobalDefaults+0x88>)
to determine whether to use the block stored in FLASH or to use defaults.
*/

void setGlobalDefaults(void)
{
    flashReadData((uint32_t*)configDataBlock.data,
 8002e10:	2250      	movs	r2, #80	; 0x50
 8002e12:	4821      	ldr	r0, [pc, #132]	; (8002e98 <setGlobalDefaults+0x8c>)
 8002e14:	4621      	mov	r1, r4
 8002e16:	f7ff fd77 	bl	8002908 <flashReadData>
                   configData.data,sizeof(configData.config));
    if (configData.config.validBlock == VALID_BLOCK) return;
 8002e1a:	7823      	ldrb	r3, [r4, #0]
 8002e1c:	2bd5      	cmp	r3, #213	; 0xd5
 8002e1e:	d037      	beq.n	8002e90 <setGlobalDefaults+0x84>
    configData.config.watchdogDelay = WATCHDOG_DELAY;
 8002e20:	2033      	movs	r0, #51	; 0x33
    configData.config.chargerDelay = CHARGER_DELAY;
    configData.config.measurementDelay = MEASUREMENT_DELAY;
    configData.config.monitorDelay = MONITOR_DELAY;
    configData.config.calibrationDelay = CALIBRATION_DELAY;
    configData.config.alphaR = 100;           /* about 0.4 */
 8002e22:	2564      	movs	r5, #100	; 0x64
void setGlobalDefaults(void)
{
    flashReadData((uint32_t*)configDataBlock.data,
                   configData.data,sizeof(configData.config));
    if (configData.config.validBlock == VALID_BLOCK) return;
    configData.config.watchdogDelay = WATCHDOG_DELAY;
 8002e24:	6320      	str	r0, [r4, #48]	; 0x30
    configData.config.chargerDelay = CHARGER_DELAY;
 8002e26:	6360      	str	r0, [r4, #52]	; 0x34
    configData.config.measurementDelay = MEASUREMENT_DELAY;
 8002e28:	63a0      	str	r0, [r4, #56]	; 0x38
    configData.config.monitorDelay = MONITOR_DELAY;
 8002e2a:	2166      	movs	r1, #102	; 0x66
    configData.config.calibrationDelay = CALIBRATION_DELAY;
    configData.config.alphaR = 100;           /* about 0.4 */
    configData.config.alphaV = 256;           /* No Filter */
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
/* Set default battery parameters */
    configData.config.batteryCapacity[0] = 54;
 8002e2c:	2036      	movs	r0, #54	; 0x36
    if (configData.config.validBlock == VALID_BLOCK) return;
    configData.config.watchdogDelay = WATCHDOG_DELAY;
    configData.config.chargerDelay = CHARGER_DELAY;
    configData.config.measurementDelay = MEASUREMENT_DELAY;
    configData.config.monitorDelay = MONITOR_DELAY;
    configData.config.calibrationDelay = CALIBRATION_DELAY;
 8002e2e:	f240 1299 	movw	r2, #409	; 0x199
    configData.config.alphaR = 100;           /* about 0.4 */
 8002e32:	84a5      	strh	r5, [r4, #36]	; 0x24
    configData.config.alphaV = 256;           /* No Filter */
 8002e34:	f44f 7680 	mov.w	r6, #256	; 0x100
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
/* Set default battery parameters */
    configData.config.batteryCapacity[0] = 54;
    configData.config.batteryCapacity[1] = 80;
    configData.config.batteryCapacity[2] = 54;
    configData.config.batteryType[0] = wetT;
 8002e38:	2500      	movs	r5, #0
    configData.config.measurementDelay = MEASUREMENT_DELAY;
    configData.config.monitorDelay = MONITOR_DELAY;
    configData.config.calibrationDelay = CALIBRATION_DELAY;
    configData.config.alphaR = 100;           /* about 0.4 */
    configData.config.alphaV = 256;           /* No Filter */
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
 8002e3a:	23b4      	movs	r3, #180	; 0xb4
                   configData.data,sizeof(configData.config));
    if (configData.config.validBlock == VALID_BLOCK) return;
    configData.config.watchdogDelay = WATCHDOG_DELAY;
    configData.config.chargerDelay = CHARGER_DELAY;
    configData.config.measurementDelay = MEASUREMENT_DELAY;
    configData.config.monitorDelay = MONITOR_DELAY;
 8002e3c:	63e1      	str	r1, [r4, #60]	; 0x3c
    configData.config.calibrationDelay = CALIBRATION_DELAY;
 8002e3e:	6422      	str	r2, [r4, #64]	; 0x40
    configData.config.alphaR = 100;           /* about 0.4 */
    configData.config.alphaV = 256;           /* No Filter */
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
/* Set default battery parameters */
    configData.config.batteryCapacity[0] = 54;
    configData.config.batteryCapacity[1] = 80;
 8002e40:	2150      	movs	r1, #80	; 0x50
    configData.config.batteryCapacity[2] = 54;
    configData.config.batteryType[0] = wetT;
    configData.config.batteryType[1] = gelT;
    configData.config.batteryType[2] = wetT;
    configData.config.monitorStrategy = 0xFF;
 8002e42:	22ff      	movs	r2, #255	; 0xff
    configData.config.chargerDelay = CHARGER_DELAY;
    configData.config.measurementDelay = MEASUREMENT_DELAY;
    configData.config.monitorDelay = MONITOR_DELAY;
    configData.config.calibrationDelay = CALIBRATION_DELAY;
    configData.config.alphaR = 100;           /* about 0.4 */
    configData.config.alphaV = 256;           /* No Filter */
 8002e44:	84e6      	strh	r6, [r4, #38]	; 0x26
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
/* Set default battery parameters */
    configData.config.batteryCapacity[0] = 54;
 8002e46:	8060      	strh	r0, [r4, #2]
    configData.config.batteryCapacity[1] = 80;
    configData.config.batteryCapacity[2] = 54;
 8002e48:	80e0      	strh	r0, [r4, #6]
    configData.config.batteryType[0] = wetT;
    configData.config.batteryType[1] = gelT;
 8002e4a:	2601      	movs	r6, #1
    configData.config.batteryType[2] = wetT;
    configData.config.monitorStrategy = 0xFF;
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++) setBatteryChargeParameters(i);
 8002e4c:	4628      	mov	r0, r5
    configData.config.measurementDelay = MEASUREMENT_DELAY;
    configData.config.monitorDelay = MONITOR_DELAY;
    configData.config.calibrationDelay = CALIBRATION_DELAY;
    configData.config.alphaR = 100;           /* about 0.4 */
    configData.config.alphaV = 256;           /* No Filter */
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
 8002e4e:	8523      	strh	r3, [r4, #40]	; 0x28
/* Set default battery parameters */
    configData.config.batteryCapacity[0] = 54;
    configData.config.batteryCapacity[1] = 80;
 8002e50:	80a1      	strh	r1, [r4, #4]
    configData.config.batteryCapacity[2] = 54;
    configData.config.batteryType[0] = wetT;
    configData.config.batteryType[1] = gelT;
    configData.config.batteryType[2] = wetT;
    configData.config.monitorStrategy = 0xFF;
 8002e52:	f884 202f 	strb.w	r2, [r4, #47]	; 0x2f
    configData.config.alphaC = 180;           /* about 0.7, only for detecting float state. */
/* Set default battery parameters */
    configData.config.batteryCapacity[0] = 54;
    configData.config.batteryCapacity[1] = 80;
    configData.config.batteryCapacity[2] = 54;
    configData.config.batteryType[0] = wetT;
 8002e56:	7225      	strb	r5, [r4, #8]
    configData.config.batteryType[1] = gelT;
 8002e58:	7266      	strb	r6, [r4, #9]
    configData.config.batteryType[2] = wetT;
 8002e5a:	72a5      	strb	r5, [r4, #10]
    configData.config.monitorStrategy = 0xFF;
    uint8_t i=0;
    for (i=0; i<NUM_BATS; i++) setBatteryChargeParameters(i);
 8002e5c:	f7ff ff9e 	bl	8002d9c <setBatteryChargeParameters>
 8002e60:	4630      	mov	r0, r6
 8002e62:	f7ff ff9b 	bl	8002d9c <setBatteryChargeParameters>
 8002e66:	2002      	movs	r0, #2
 8002e68:	f7ff ff98 	bl	8002d9c <setBatteryChargeParameters>
/* Zero the offsets. */
    for (i=0; i<NUM_IFS; i++) configData.config.currentOffsets.data[i] = 0;
 8002e6c:	f8a4 5044 	strh.w	r5, [r4, #68]	; 0x44
 8002e70:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
 8002e74:	f8a4 5048 	strh.w	r5, [r4, #72]	; 0x48
 8002e78:	f8a4 504a 	strh.w	r5, [r4, #74]	; 0x4a
 8002e7c:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
 8002e80:	f8a4 504e 	strh.w	r5, [r4, #78]	; 0x4e
/* Don't track unless instructed externally */
    configData.config.autoTrack = false;
 8002e84:	f884 502d 	strb.w	r5, [r4, #45]	; 0x2d
    configData.config.debugMessageSend = false;
 8002e88:	f884 502b 	strb.w	r5, [r4, #43]	; 0x2b
    configData.config.switchAvoidance = false;
 8002e8c:	f884 502e 	strb.w	r5, [r4, #46]	; 0x2e
 8002e90:	bd70      	pop	{r4, r5, r6, pc}
 8002e92:	bf00      	nop
 8002e94:	200008c8 	.word	0x200008c8
 8002e98:	08007800 	.word	0x08007800

08002e9c <getBatteryType>:
@param[in] battery: 0..NUM_BATS-1
*/

battery_Type getBatteryType(int battery)
{
    return configData.config.batteryType[battery];
 8002e9c:	4b01      	ldr	r3, [pc, #4]	; (8002ea4 <getBatteryType+0x8>)
 8002e9e:	1818      	adds	r0, r3, r0
}
 8002ea0:	7a00      	ldrb	r0, [r0, #8]
 8002ea2:	4770      	bx	lr
 8002ea4:	200008c8 	.word	0x200008c8

08002ea8 <getBatteryCapacity>:
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getBatteryCapacity(int battery)
{
    return configData.config.batteryCapacity[battery];
 8002ea8:	4b02      	ldr	r3, [pc, #8]	; (8002eb4 <getBatteryCapacity+0xc>)
 8002eaa:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 8002eae:	f9b0 0002 	ldrsh.w	r0, [r0, #2]
 8002eb2:	4770      	bx	lr
 8002eb4:	200008c8 	.word	0x200008c8

08002eb8 <getBulkCurrentLimit>:
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getBulkCurrentLimit(int battery)
{
    return configData.config.batteryCapacity[battery]*256/
 8002eb8:	4b06      	ldr	r3, [pc, #24]	; (8002ed4 <getBulkCurrentLimit+0x1c>)
 8002eba:	eb03 0240 	add.w	r2, r3, r0, lsl #1
 8002ebe:	8851      	ldrh	r1, [r2, #2]
            configData.config.bulkCurrentLimitScale[battery];
 8002ec0:	eb03 0040 	add.w	r0, r3, r0, lsl #1
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getBulkCurrentLimit(int battery)
{
    return configData.config.batteryCapacity[battery]*256/
 8002ec4:	f9b0 301e 	ldrsh.w	r3, [r0, #30]
 8002ec8:	020a      	lsls	r2, r1, #8
 8002eca:	fb92 f1f3 	sdiv	r1, r2, r3
            configData.config.bulkCurrentLimitScale[battery];
}
 8002ece:	b208      	sxth	r0, r1
 8002ed0:	4770      	bx	lr
 8002ed2:	bf00      	nop
 8002ed4:	200008c8 	.word	0x200008c8

08002ed8 <getFloatStageCurrent>:
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getFloatStageCurrent(int battery)
{
    return configData.config.batteryCapacity[battery]*256/
 8002ed8:	4b05      	ldr	r3, [pc, #20]	; (8002ef0 <getFloatStageCurrent+0x18>)
 8002eda:	eb03 0240 	add.w	r2, r3, r0, lsl #1
 8002ede:	8851      	ldrh	r1, [r2, #2]
            configData.config.floatStageCurrentScale[battery];
 8002ee0:	300c      	adds	r0, #12
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getFloatStageCurrent(int battery)
{
    return configData.config.batteryCapacity[battery]*256/
 8002ee2:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
 8002ee6:	020a      	lsls	r2, r1, #8
 8002ee8:	fb92 f3f0 	sdiv	r3, r2, r0
            configData.config.floatStageCurrentScale[battery];
}
 8002eec:	b218      	sxth	r0, r3
 8002eee:	4770      	bx	lr
 8002ef0:	200008c8 	.word	0x200008c8

08002ef4 <getAbsorptionVoltage>:
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getAbsorptionVoltage(int battery)
{
    return configData.config.absorptionVoltage[battery];
 8002ef4:	4b02      	ldr	r3, [pc, #8]	; (8002f00 <getAbsorptionVoltage+0xc>)
 8002ef6:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 8002efa:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 8002efe:	4770      	bx	lr
 8002f00:	200008c8 	.word	0x200008c8

08002f04 <getFloatVoltage>:
@param[in] battery: 0..NUM_BATS-1
*/

int16_t getFloatVoltage(int battery)
{
    return configData.config.floatVoltage[battery];
 8002f04:	4b02      	ldr	r3, [pc, #8]	; (8002f10 <getFloatVoltage+0xc>)
 8002f06:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 8002f0a:	f9b0 0012 	ldrsh.w	r0, [r0, #18]
 8002f0e:	4770      	bx	lr
 8002f10:	200008c8 	.word	0x200008c8

08002f14 <getAlphaV>:
*/

int16_t getAlphaV(void)
{
    return configData.config.alphaV;
}
 8002f14:	4b01      	ldr	r3, [pc, #4]	; (8002f1c <getAlphaV+0x8>)
 8002f16:	f9b3 0026 	ldrsh.w	r0, [r3, #38]	; 0x26
 8002f1a:	4770      	bx	lr
 8002f1c:	200008c8 	.word	0x200008c8

08002f20 <getAlphaC>:
*/

int16_t getAlphaC(void)
{
    return configData.config.alphaC;
}
 8002f20:	4b01      	ldr	r3, [pc, #4]	; (8002f28 <getAlphaC+0x8>)
 8002f22:	f9b3 0028 	ldrsh.w	r0, [r3, #40]	; 0x28
 8002f26:	4770      	bx	lr
 8002f28:	200008c8 	.word	0x200008c8

08002f2c <getAlphaR>:
*/

int16_t getAlphaR(void)
{
    return configData.config.alphaR;
}
 8002f2c:	4b01      	ldr	r3, [pc, #4]	; (8002f34 <getAlphaR+0x8>)
 8002f2e:	f9b3 0024 	ldrsh.w	r0, [r3, #36]	; 0x24
 8002f32:	4770      	bx	lr
 8002f34:	200008c8 	.word	0x200008c8

08002f38 <getCurrentOffset>:
@parameter uint8_t interface: the interface 0...NUM_IFS.
*/

int16_t getCurrentOffset(uint8_t interface)
{
    return configData.config.currentOffsets.data[interface];
 8002f38:	4b02      	ldr	r3, [pc, #8]	; (8002f44 <getCurrentOffset+0xc>)
 8002f3a:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 8002f3e:	f9b0 0044 	ldrsh.w	r0, [r0, #68]	; 0x44
 8002f42:	4770      	bx	lr
 8002f44:	200008c8 	.word	0x200008c8

08002f48 <setCurrentOffset>:
@parameter uint16_t current offset value
*/

void setCurrentOffset(uint8_t interface, int16_t offset)
{
    configData.config.currentOffsets.data[interface] = offset;
 8002f48:	4b02      	ldr	r3, [pc, #8]	; (8002f54 <setCurrentOffset+0xc>)
 8002f4a:	eb03 0040 	add.w	r0, r3, r0, lsl #1
 8002f4e:	f8a0 1044 	strh.w	r1, [r0, #68]	; 0x44
 8002f52:	4770      	bx	lr
 8002f54:	200008c8 	.word	0x200008c8

08002f58 <getWatchdogDelay>:
*/

portTickType getWatchdogDelay(void)
{
    return configData.config.watchdogDelay;
}
 8002f58:	4b01      	ldr	r3, [pc, #4]	; (8002f60 <getWatchdogDelay+0x8>)
 8002f5a:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8002f5c:	4770      	bx	lr
 8002f5e:	bf00      	nop
 8002f60:	200008c8 	.word	0x200008c8

08002f64 <getChargerDelay>:
*/

portTickType getChargerDelay(void)
{
    return configData.config.chargerDelay;
}
 8002f64:	4b01      	ldr	r3, [pc, #4]	; (8002f6c <getChargerDelay+0x8>)
 8002f66:	6b58      	ldr	r0, [r3, #52]	; 0x34
 8002f68:	4770      	bx	lr
 8002f6a:	bf00      	nop
 8002f6c:	200008c8 	.word	0x200008c8

08002f70 <getMeasurementDelay>:
*/

portTickType getMeasurementDelay(void)
{
    return configData.config.measurementDelay;
}
 8002f70:	4b01      	ldr	r3, [pc, #4]	; (8002f78 <getMeasurementDelay+0x8>)
 8002f72:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8002f74:	4770      	bx	lr
 8002f76:	bf00      	nop
 8002f78:	200008c8 	.word	0x200008c8

08002f7c <getMonitorDelay>:
*/

portTickType getMonitorDelay(void)
{
    return configData.config.monitorDelay;
}
 8002f7c:	4b01      	ldr	r3, [pc, #4]	; (8002f84 <getMonitorDelay+0x8>)
 8002f7e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8002f80:	4770      	bx	lr
 8002f82:	bf00      	nop
 8002f84:	200008c8 	.word	0x200008c8

08002f88 <getCalibrationDelay>:
*/

portTickType getCalibrationDelay(void)
{
    return configData.config.calibrationDelay;
}
 8002f88:	4b01      	ldr	r3, [pc, #4]	; (8002f90 <getCalibrationDelay+0x8>)
 8002f8a:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8002f8c:	4770      	bx	lr
 8002f8e:	bf00      	nop
 8002f90:	200008c8 	.word	0x200008c8

08002f94 <isRecording>:
*/

bool isRecording(void)
{
    return configData.config.recording;
}
 8002f94:	4b01      	ldr	r3, [pc, #4]	; (8002f9c <isRecording+0x8>)
 8002f96:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 8002f9a:	4770      	bx	lr
 8002f9c:	200008c8 	.word	0x200008c8

08002fa0 <isAutoTrack>:
*/

bool isAutoTrack(void)
{
    return configData.config.autoTrack;
}
 8002fa0:	4b01      	ldr	r3, [pc, #4]	; (8002fa8 <isAutoTrack+0x8>)
 8002fa2:	f893 002d 	ldrb.w	r0, [r3, #45]	; 0x2d
 8002fa6:	4770      	bx	lr
 8002fa8:	200008c8 	.word	0x200008c8

08002fac <isSwitchAvoidance>:
*/

bool isSwitchAvoidance(void)
{
    return configData.config.switchAvoidance;
}
 8002fac:	4b01      	ldr	r3, [pc, #4]	; (8002fb4 <isSwitchAvoidance+0x8>)
 8002fae:	f893 002e 	ldrb.w	r0, [r3, #46]	; 0x2e
 8002fb2:	4770      	bx	lr
 8002fb4:	200008c8 	.word	0x200008c8

08002fb8 <getMonitorStrategy>:
*/

uint8_t getMonitorStrategy(void)
{
    return configData.config.monitorStrategy;
}
 8002fb8:	4b01      	ldr	r3, [pc, #4]	; (8002fc0 <getMonitorStrategy+0x8>)
 8002fba:	f893 002f 	ldrb.w	r0, [r3, #47]	; 0x2f
 8002fbe:	4770      	bx	lr
 8002fc0:	200008c8 	.word	0x200008c8

08002fc4 <getControls>:
@returns uint16_t status of controls
*/
uint16_t getControls(void)
{
    uint8_t controls = 0;
    if (configData.config.autoTrack) controls |= 1<<0;
 8002fc4:	4b0c      	ldr	r3, [pc, #48]	; (8002ff8 <getControls+0x34>)
    if (configData.config.recording) controls |= 1<<1;
 8002fc6:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c

@returns uint16_t status of controls
*/
uint16_t getControls(void)
{
    uint8_t controls = 0;
 8002fca:	f893 002d 	ldrb.w	r0, [r3, #45]	; 0x2d
    if (configData.config.autoTrack) controls |= 1<<0;
    if (configData.config.recording) controls |= 1<<1;
 8002fce:	b10a      	cbz	r2, 8002fd4 <getControls+0x10>
 8002fd0:	f040 0002 	orr.w	r0, r0, #2
    if (configData.config.switchAvoidance) controls |= 1<<2;
 8002fd4:	f893 102e 	ldrb.w	r1, [r3, #46]	; 0x2e
 8002fd8:	b109      	cbz	r1, 8002fde <getControls+0x1a>
 8002fda:	f040 0004 	orr.w	r0, r0, #4
    if (configData.config.measurementSend) controls |= 1<<3;
 8002fde:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8002fe2:	b10b      	cbz	r3, 8002fe8 <getControls+0x24>
 8002fe4:	f040 0008 	orr.w	r0, r0, #8
    if (configData.config.debugMessageSend) controls |= 1<<4;
 8002fe8:	4a03      	ldr	r2, [pc, #12]	; (8002ff8 <getControls+0x34>)
 8002fea:	f892 102b 	ldrb.w	r1, [r2, #43]	; 0x2b
 8002fee:	b109      	cbz	r1, 8002ff4 <getControls+0x30>
 8002ff0:	f040 0010 	orr.w	r0, r0, #16
    return controls;
}
 8002ff4:	4770      	bx	lr
 8002ff6:	bf00      	nop
 8002ff8:	200008c8 	.word	0x200008c8

08002ffc <prvMeasurementTask>:

A/D measurements are performed in a single conversion and stored via DMA.
*/

void prvMeasurementTask(void *pvParameters)
{
 8002ffc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
static void initGlobals(void)
{
    uint8_t i = 0;
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
 8003000:	488c      	ldr	r0, [pc, #560]	; (8003234 <prvMeasurementTask+0x238>)
 8003002:	2400      	movs	r4, #0
        lastBatteryCurrent[i] = 0;
 8003004:	498c      	ldr	r1, [pc, #560]	; (8003238 <prvMeasurementTask+0x23c>)
        batteryResistanceAv[i] = 0;
 8003006:	4a8d      	ldr	r2, [pc, #564]	; (800323c <prvMeasurementTask+0x240>)

A/D measurements are performed in a single conversion and stored via DMA.
*/

void prvMeasurementTask(void *pvParameters)
{
 8003008:	b093      	sub	sp, #76	; 0x4c
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
        lastBatteryCurrent[i] = 0;
        batteryResistanceAv[i] = 0;
        accumulatedBatteryCharge[i] = 0;
 800300a:	4b8d      	ldr	r3, [pc, #564]	; (8003240 <prvMeasurementTask+0x244>)
static void initGlobals(void)
{
    uint8_t i = 0;
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
 800300c:	8004      	strh	r4, [r0, #0]
 800300e:	8044      	strh	r4, [r0, #2]
 8003010:	8084      	strh	r4, [r0, #4]

/* Setup the array of selected channels for conversion */
	channel_array[0] = ADC_CHANNEL_BATTERY1_CURRENT;    /* Battery 1 */
	channel_array[1] = ADC_CHANNEL_BATTERY1_VOLTAGE;
	channel_array[2] = ADC_CHANNEL_BATTERY2_CURRENT;    /* Battery 2 */
	channel_array[3] = ADC_CHANNEL_BATTERY2_VOLTAGE;
 8003012:	2003      	movs	r0, #3
	uint8_t channel_array[N_CONV];
    initGlobals();

/* Setup the array of selected channels for conversion */
	channel_array[0] = ADC_CHANNEL_BATTERY1_CURRENT;    /* Battery 1 */
	channel_array[1] = ADC_CHANNEL_BATTERY1_VOLTAGE;
 8003014:	2601      	movs	r6, #1
	channel_array[2] = ADC_CHANNEL_BATTERY2_CURRENT;    /* Battery 2 */
 8003016:	2702      	movs	r7, #2
	channel_array[3] = ADC_CHANNEL_BATTERY2_VOLTAGE;
	channel_array[4] = ADC_CHANNEL_BATTERY3_CURRENT;    /* Battery 3 */
 8003018:	2504      	movs	r5, #4
{
    uint8_t i = 0;
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
        lastBatteryCurrent[i] = 0;
 800301a:	800c      	strh	r4, [r1, #0]
        batteryResistanceAv[i] = 0;
 800301c:	8014      	strh	r4, [r2, #0]
{
    uint8_t i = 0;
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
        lastBatteryCurrent[i] = 0;
 800301e:	804c      	strh	r4, [r1, #2]
        batteryResistanceAv[i] = 0;
 8003020:	8054      	strh	r4, [r2, #2]
{
    uint8_t i = 0;
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
        lastBatteryCurrent[i] = 0;
 8003022:	808c      	strh	r4, [r1, #4]
        batteryResistanceAv[i] = 0;
 8003024:	8094      	strh	r4, [r2, #4]
	channel_array[0] = ADC_CHANNEL_BATTERY1_CURRENT;    /* Battery 1 */
	channel_array[1] = ADC_CHANNEL_BATTERY1_VOLTAGE;
	channel_array[2] = ADC_CHANNEL_BATTERY2_CURRENT;    /* Battery 2 */
	channel_array[3] = ADC_CHANNEL_BATTERY2_VOLTAGE;
	channel_array[4] = ADC_CHANNEL_BATTERY3_CURRENT;    /* Battery 3 */
	channel_array[5] = ADC_CHANNEL_BATTERY3_VOLTAGE;
 8003026:	2105      	movs	r1, #5
	channel_array[6] = ADC_CHANNEL_LOAD1_CURRENT;       /* Load 1 */
 8003028:	220a      	movs	r2, #10

/* Setup the array of selected channels for conversion */
	channel_array[0] = ADC_CHANNEL_BATTERY1_CURRENT;    /* Battery 1 */
	channel_array[1] = ADC_CHANNEL_BATTERY1_VOLTAGE;
	channel_array[2] = ADC_CHANNEL_BATTERY2_CURRENT;    /* Battery 2 */
	channel_array[3] = ADC_CHANNEL_BATTERY2_VOLTAGE;
 800302a:	f88d 0007 	strb.w	r0, [sp, #7]
	channel_array[6] = ADC_CHANNEL_LOAD1_CURRENT;       /* Load 1 */
	channel_array[7] = ADC_CHANNEL_LOAD1_VOLTAGE;
	channel_array[8] = ADC_CHANNEL_LOAD2_CURRENT;       /* Load 2 */
	channel_array[9] = ADC_CHANNEL_LOAD2_VOLTAGE;
	channel_array[10] = ADC_CHANNEL_PANEL_CURRENT;      /* Panel */
	channel_array[11] = ADC_CHANNEL_PANEL_VOLTAGE;
 800302e:	2007      	movs	r0, #7
    for (i=0; i<NUM_BATS; i++)
    {
        lastBatteryVoltage[i] = 0;
        lastBatteryCurrent[i] = 0;
        batteryResistanceAv[i] = 0;
        accumulatedBatteryCharge[i] = 0;
 8003030:	601c      	str	r4, [r3, #0]
 8003032:	605c      	str	r4, [r3, #4]
 8003034:	609c      	str	r4, [r3, #8]
	uint8_t channel_array[N_CONV];
    initGlobals();

/* Setup the array of selected channels for conversion */
	channel_array[0] = ADC_CHANNEL_BATTERY1_CURRENT;    /* Battery 1 */
	channel_array[1] = ADC_CHANNEL_BATTERY1_VOLTAGE;
 8003036:	f88d 6005 	strb.w	r6, [sp, #5]
	channel_array[2] = ADC_CHANNEL_BATTERY2_CURRENT;    /* Battery 2 */
 800303a:	f88d 7006 	strb.w	r7, [sp, #6]
	channel_array[3] = ADC_CHANNEL_BATTERY2_VOLTAGE;
	channel_array[4] = ADC_CHANNEL_BATTERY3_CURRENT;    /* Battery 3 */
 800303e:	f88d 5008 	strb.w	r5, [sp, #8]
	channel_array[5] = ADC_CHANNEL_BATTERY3_VOLTAGE;
 8003042:	f88d 1009 	strb.w	r1, [sp, #9]
	channel_array[6] = ADC_CHANNEL_LOAD1_CURRENT;       /* Load 1 */
 8003046:	f88d 200a 	strb.w	r2, [sp, #10]
	channel_array[7] = ADC_CHANNEL_LOAD1_VOLTAGE;
 800304a:	230b      	movs	r3, #11
	channel_array[8] = ADC_CHANNEL_LOAD2_CURRENT;       /* Load 2 */
 800304c:	260c      	movs	r6, #12
	channel_array[9] = ADC_CHANNEL_LOAD2_VOLTAGE;
 800304e:	210d      	movs	r1, #13
	channel_array[10] = ADC_CHANNEL_PANEL_CURRENT;      /* Panel */
 8003050:	2706      	movs	r7, #6
	channel_array[11] = ADC_CHANNEL_PANEL_VOLTAGE;
 8003052:	f88d 000f 	strb.w	r0, [sp, #15]
	channel_array[12] = ADC_CHANNEL_TEMPERATURE;        /* Temperature */
 8003056:	250e      	movs	r5, #14
	adc_set_regular_sequence(ADC1, N_CONV, channel_array);
 8003058:	487a      	ldr	r0, [pc, #488]	; (8003244 <prvMeasurementTask+0x248>)
 800305a:	aa01      	add	r2, sp, #4
    int32_t av[N_CONV];
	uint8_t channel_array[N_CONV];
    initGlobals();

/* Setup the array of selected channels for conversion */
	channel_array[0] = ADC_CHANNEL_BATTERY1_CURRENT;    /* Battery 1 */
 800305c:	f88d 4004 	strb.w	r4, [sp, #4]
	channel_array[2] = ADC_CHANNEL_BATTERY2_CURRENT;    /* Battery 2 */
	channel_array[3] = ADC_CHANNEL_BATTERY2_VOLTAGE;
	channel_array[4] = ADC_CHANNEL_BATTERY3_CURRENT;    /* Battery 3 */
	channel_array[5] = ADC_CHANNEL_BATTERY3_VOLTAGE;
	channel_array[6] = ADC_CHANNEL_LOAD1_CURRENT;       /* Load 1 */
	channel_array[7] = ADC_CHANNEL_LOAD1_VOLTAGE;
 8003060:	f88d 300b 	strb.w	r3, [sp, #11]
	channel_array[8] = ADC_CHANNEL_LOAD2_CURRENT;       /* Load 2 */
 8003064:	f88d 600c 	strb.w	r6, [sp, #12]
	channel_array[9] = ADC_CHANNEL_LOAD2_VOLTAGE;
 8003068:	f88d 100d 	strb.w	r1, [sp, #13]
	channel_array[10] = ADC_CHANNEL_PANEL_CURRENT;      /* Panel */
 800306c:	f88d 700e 	strb.w	r7, [sp, #14]
	channel_array[11] = ADC_CHANNEL_PANEL_VOLTAGE;
	channel_array[12] = ADC_CHANNEL_TEMPERATURE;        /* Temperature */
 8003070:	f88d 5010 	strb.w	r5, [sp, #16]
	adc_set_regular_sequence(ADC1, N_CONV, channel_array);
 8003074:	f003 fb3a 	bl	80066ec <adc_set_regular_sequence>

/* Reset averages for first run */
	for (j = 0; j < N_CONV; j++) av[j] = 0;
 8003078:	2100      	movs	r1, #0
 800307a:	aa05      	add	r2, sp, #20
 800307c:	50a1      	str	r1, [r4, r2]
 800307e:	3404      	adds	r4, #4
 8003080:	2c34      	cmp	r4, #52	; 0x34
 8003082:	d1f9      	bne.n	8003078 <prvMeasurementTask+0x7c>

	while (1)
	{
        iwdgReset();
 8003084:	f7ff fc3e 	bl	8002904 <iwdgReset>
/* A/D conversions */
/* Wait until the next tick cycle */
		vTaskDelay(getMeasurementDelay() );
 8003088:	f7ff ff72 	bl	8002f70 <getMeasurementDelay>
 800308c:	f002 fb78 	bl	8005780 <vTaskDelay>
/* Reset watchdog counter */
        measurementWatchdogCount = 0;
 8003090:	4b6d      	ldr	r3, [pc, #436]	; (8003248 <prvMeasurementTask+0x24c>)
 8003092:	2600      	movs	r6, #0
 8003094:	701e      	strb	r6, [r3, #0]
 8003096:	f44f 6680 	mov.w	r6, #1024	; 0x400
/* Fire off a burst of conversions and average the results.
This averages out variations due to PWM provided they are not high frequency. */
        uint16_t burst = 0;
        for (burst=0; burst < N_SAMPLES; burst++)
        {
            adc_start_conversion_regular(ADC1);
 800309a:	486a      	ldr	r0, [pc, #424]	; (8003244 <prvMeasurementTask+0x248>)
 800309c:	f003 fb6a 	bl	8006774 <adc_start_conversion_regular>
/* Check if conversion ended */
            while (adcEOC() == 0) taskYIELD();
 80030a0:	f7ff fa2c 	bl	80024fc <adcEOC>
 80030a4:	b910      	cbnz	r0, 80030ac <prvMeasurementTask+0xb0>
 80030a6:	f003 f8d5 	bl	8006254 <vPortYield>
 80030aa:	e7f9      	b.n	80030a0 <prvMeasurementTask+0xa4>
 80030ac:	2500      	movs	r5, #0
 80030ae:	462c      	mov	r4, r5
/* Sum over the sample set with scaling and offset for the interfaces and
temperature */
        	for (j = 0; j < N_CONV-1; j+=2)
            {
                av[j] += adcValue(j);
 80030b0:	af05      	add	r7, sp, #20
 80030b2:	4620      	mov	r0, r4
 80030b4:	f855 8007 	ldr.w	r8, [r5, r7]
 80030b8:	f7ff fa16 	bl	80024e8 <adcValue>
- Implementation of Coulomb Counting for SoC.

A/D measurements are performed in a single conversion and stored via DMA.
*/

void prvMeasurementTask(void *pvParameters)
 80030bc:	1c61      	adds	r1, r4, #1
            while (adcEOC() == 0) taskYIELD();
/* Sum over the sample set with scaling and offset for the interfaces and
temperature */
        	for (j = 0; j < N_CONV-1; j+=2)
            {
                av[j] += adcValue(j);
 80030be:	4440      	add	r0, r8
 80030c0:	51e8      	str	r0, [r5, r7]
- Implementation of Coulomb Counting for SoC.

A/D measurements are performed in a single conversion and stored via DMA.
*/

void prvMeasurementTask(void *pvParameters)
 80030c2:	197f      	adds	r7, r7, r5
/* Sum over the sample set with scaling and offset for the interfaces and
temperature */
        	for (j = 0; j < N_CONV-1; j+=2)
            {
                av[j] += adcValue(j);
                av[j+1] += adcValue(j+1);
 80030c4:	b2c8      	uxtb	r0, r1
 80030c6:	f8d7 9004 	ldr.w	r9, [r7, #4]
 80030ca:	f7ff fa0d 	bl	80024e8 <adcValue>
            adc_start_conversion_regular(ADC1);
/* Check if conversion ended */
            while (adcEOC() == 0) taskYIELD();
/* Sum over the sample set with scaling and offset for the interfaces and
temperature */
        	for (j = 0; j < N_CONV-1; j+=2)
 80030ce:	3402      	adds	r4, #2
 80030d0:	b2e4      	uxtb	r4, r4
            {
                av[j] += adcValue(j);
                av[j+1] += adcValue(j+1);
 80030d2:	eb09 0200 	add.w	r2, r9, r0
 80030d6:	3508      	adds	r5, #8
            adc_start_conversion_regular(ADC1);
/* Check if conversion ended */
            while (adcEOC() == 0) taskYIELD();
/* Sum over the sample set with scaling and offset for the interfaces and
temperature */
        	for (j = 0; j < N_CONV-1; j+=2)
 80030d8:	2c0c      	cmp	r4, #12
            {
                av[j] += adcValue(j);
                av[j+1] += adcValue(j+1);
 80030da:	607a      	str	r2, [r7, #4]
            adc_start_conversion_regular(ADC1);
/* Check if conversion ended */
            while (adcEOC() == 0) taskYIELD();
/* Sum over the sample set with scaling and offset for the interfaces and
temperature */
        	for (j = 0; j < N_CONV-1; j+=2)
 80030dc:	d1e8      	bne.n	80030b0 <prvMeasurementTask+0xb4>
            {
                av[j] += adcValue(j);
                av[j+1] += adcValue(j+1);
            }
            av[12] += adcValue(12);
 80030de:	4620      	mov	r0, r4
 80030e0:	9d11      	ldr	r5, [sp, #68]	; 0x44
 80030e2:	f7ff fa01 	bl	80024e8 <adcValue>
 80030e6:	3e01      	subs	r6, #1
 80030e8:	1943      	adds	r3, r0, r5
 80030ea:	b2b6      	uxth	r6, r6
 80030ec:	9311      	str	r3, [sp, #68]	; 0x44
/* Reset watchdog counter */
        measurementWatchdogCount = 0;
/* Fire off a burst of conversions and average the results.
This averages out variations due to PWM provided they are not high frequency. */
        uint16_t burst = 0;
        for (burst=0; burst < N_SAMPLES; burst++)
 80030ee:	2e00      	cmp	r6, #0
 80030f0:	d1d3      	bne.n	800309a <prvMeasurementTask+0x9e>
 80030f2:	4632      	mov	r2, r6
 80030f4:	4633      	mov	r3, r6
/* Compute averages from the burst, scale and offset to the real quantities,
and reset the averages for the next cycle. */
        for (i=0; i<NUM_IFS; i++)
        {
            uint8_t k = i+i;
            currents.data[i] = ((av[k]/N_SAMPLES-CURRENT_OFFSET)*CURRENT_SCALE)/4096;
 80030f6:	ad05      	add	r5, sp, #20
 80030f8:	595f      	ldr	r7, [r3, r5]
 80030fa:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80030fe:	fb97 f1f0 	sdiv	r1, r7, r0
 8003102:	f242 04b5 	movw	r4, #8373	; 0x20b5
 8003106:	4361      	muls	r1, r4
 8003108:	4e50      	ldr	r6, [pc, #320]	; (800324c <prvMeasurementTask+0x250>)
 800310a:	198f      	adds	r7, r1, r6
 800310c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8003110:	4e4f      	ldr	r6, [pc, #316]	; (8003250 <prvMeasurementTask+0x254>)
 8003112:	fb97 f4f1 	sdiv	r4, r7, r1
 8003116:	5394      	strh	r4, [r2, r6]
- Implementation of Coulomb Counting for SoC.

A/D measurements are performed in a single conversion and stored via DMA.
*/

void prvMeasurementTask(void *pvParameters)
 8003118:	18ee      	adds	r6, r5, r3
and reset the averages for the next cycle. */
        for (i=0; i<NUM_IFS; i++)
        {
            uint8_t k = i+i;
            currents.data[i] = ((av[k]/N_SAMPLES-CURRENT_OFFSET)*CURRENT_SCALE)/4096;
            voltages.data[i] = (av[k+1]/N_SAMPLES*VOLTAGE_SCALE+VOLTAGE_OFFSET)/4096;
 800311a:	6877      	ldr	r7, [r6, #4]
 800311c:	fb97 f4f0 	sdiv	r4, r7, r0
 8003120:	f44f 67bd 	mov.w	r7, #1512	; 0x5e8
 8003124:	4367      	muls	r7, r4
 8003126:	4c4b      	ldr	r4, [pc, #300]	; (8003254 <prvMeasurementTask+0x258>)
 8003128:	193f      	adds	r7, r7, r4
 800312a:	fb97 f4f1 	sdiv	r4, r7, r1
 800312e:	4f4a      	ldr	r7, [pc, #296]	; (8003258 <prvMeasurementTask+0x25c>)
 8003130:	53d4      	strh	r4, [r2, r7]
            av[k] = 0;
 8003132:	2400      	movs	r4, #0
 8003134:	515c      	str	r4, [r3, r5]
 8003136:	3308      	adds	r3, #8
 8003138:	3202      	adds	r2, #2
        }

/* Process the averaged results */
/* Compute averages from the burst, scale and offset to the real quantities,
and reset the averages for the next cycle. */
        for (i=0; i<NUM_IFS; i++)
 800313a:	2b30      	cmp	r3, #48	; 0x30
        {
            uint8_t k = i+i;
            currents.data[i] = ((av[k]/N_SAMPLES-CURRENT_OFFSET)*CURRENT_SCALE)/4096;
            voltages.data[i] = (av[k+1]/N_SAMPLES*VOLTAGE_SCALE+VOLTAGE_OFFSET)/4096;
            av[k] = 0;
            av[k+1] = 0;
 800313c:	6074      	str	r4, [r6, #4]
        }

/* Process the averaged results */
/* Compute averages from the burst, scale and offset to the real quantities,
and reset the averages for the next cycle. */
        for (i=0; i<NUM_IFS; i++)
 800313e:	d1da      	bne.n	80030f6 <prvMeasurementTask+0xfa>
            currents.data[i] = ((av[k]/N_SAMPLES-CURRENT_OFFSET)*CURRENT_SCALE)/4096;
            voltages.data[i] = (av[k+1]/N_SAMPLES*VOLTAGE_SCALE+VOLTAGE_OFFSET)/4096;
            av[k] = 0;
            av[k+1] = 0;
        }
        temperature = ((av[12]/N_SAMPLES-TEMPERATURE_OFFSET)*TEMPERATURE_SCALE)/4096;
 8003140:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8003142:	4a46      	ldr	r2, [pc, #280]	; (800325c <prvMeasurementTask+0x260>)
 8003144:	fb93 f5f0 	sdiv	r5, r3, r0
 8003148:	f44f 30a4 	mov.w	r0, #83968	; 0x14800
 800314c:	4368      	muls	r0, r5
 800314e:	f100 466f 	add.w	r6, r0, #4009754624	; 0xef000000
 8003152:	f5a6 179d 	sub.w	r7, r6, #1286144	; 0x13a000
 8003156:	fb97 f1f1 	sdiv	r1, r7, r1
 800315a:	8011      	strh	r1, [r2, #0]
        av[12] = 0;
 800315c:	9411      	str	r4, [sp, #68]	; 0x44
 800315e:	4625      	mov	r5, r4
        {
/* Compute the batteries' charge state by integration of current flow over time.
Currents are in amperes (x256). Divide by the measurement interval in seconds so
that charge is in Coulombs (x256). Limit charge to battery's capacity. Sign is
determined by the fact that positive current flows out of the batteries. */
            int32_t batteryCurrent = currents.dataArray.battery[i]-
 8003160:	4b3b      	ldr	r3, [pc, #236]	; (8003250 <prvMeasurementTask+0x254>)
                                        getBatteryCurrentOffset(i);
 8003162:	4628      	mov	r0, r5
        {
/* Compute the batteries' charge state by integration of current flow over time.
Currents are in amperes (x256). Divide by the measurement interval in seconds so
that charge is in Coulombs (x256). Limit charge to battery's capacity. Sign is
determined by the fact that positive current flows out of the batteries. */
            int32_t batteryCurrent = currents.dataArray.battery[i]-
 8003164:	5ee6      	ldrsh	r6, [r4, r3]
                                        getBatteryCurrentOffset(i);
 8003166:	f7fe ff9d 	bl	80020a4 <getBatteryCurrentOffset>
        {
/* Compute the batteries' charge state by integration of current flow over time.
Currents are in amperes (x256). Divide by the measurement interval in seconds so
that charge is in Coulombs (x256). Limit charge to battery's capacity. Sign is
determined by the fact that positive current flows out of the batteries. */
            int32_t batteryCurrent = currents.dataArray.battery[i]-
 800316a:	1a37      	subs	r7, r6, r0
                                        getBatteryCurrentOffset(i);
            accumulatedBatteryCharge[i] -= batteryCurrent*
 800316c:	4e34      	ldr	r6, [pc, #208]	; (8003240 <prvMeasurementTask+0x244>)
 800316e:	f856 a025 	ldr.w	sl, [r6, r5, lsl #2]
                    (int32_t)(1000/(portTICK_RATE_MS*getMeasurementDelay()));
 8003172:	f7ff fefd 	bl	8002f70 <getMeasurementDelay>
 8003176:	210a      	movs	r1, #10
 8003178:	4348      	muls	r0, r1
 800317a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800317e:	fbb2 f0f0 	udiv	r0, r2, r0
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
            int32_t currentStep = abs(batteryCurrent-lastBatteryCurrent[i]);
 8003182:	4a2d      	ldr	r2, [pc, #180]	; (8003238 <prvMeasurementTask+0x23c>)
Currents are in amperes (x256). Divide by the measurement interval in seconds so
that charge is in Coulombs (x256). Limit charge to battery's capacity. Sign is
determined by the fact that positive current flows out of the batteries. */
            int32_t batteryCurrent = currents.dataArray.battery[i]-
                                        getBatteryCurrentOffset(i);
            accumulatedBatteryCharge[i] -= batteryCurrent*
 8003184:	fb00 a317 	mls	r3, r0, r7, sl
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
            int32_t currentStep = abs(batteryCurrent-lastBatteryCurrent[i]);
 8003188:	f934 c002 	ldrsh.w	ip, [r4, r2]
Currents are in amperes (x256). Divide by the measurement interval in seconds so
that charge is in Coulombs (x256). Limit charge to battery's capacity. Sign is
determined by the fact that positive current flows out of the batteries. */
            int32_t batteryCurrent = currents.dataArray.battery[i]-
                                        getBatteryCurrentOffset(i);
            accumulatedBatteryCharge[i] -= batteryCurrent*
 800318c:	f846 3025 	str.w	r3, [r6, r5, lsl #2]
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
            int32_t currentStep = abs(batteryCurrent-lastBatteryCurrent[i]);
 8003190:	ebcc 0807 	rsb	r8, ip, r7
Note that battery resistance is scaled by 65536 due to its low real value.
The algorithm computes the averaged voltage and current steps and divides
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
 8003194:	4e30      	ldr	r6, [pc, #192]	; (8003258 <prvMeasurementTask+0x25c>)
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
 8003196:	4927      	ldr	r1, [pc, #156]	; (8003234 <prvMeasurementTask+0x238>)
            int32_t currentStep = abs(batteryCurrent-lastBatteryCurrent[i]);
 8003198:	f1b8 0f00 	cmp.w	r8, #0
 800319c:	bfb8      	it	lt
 800319e:	f1c8 0800 	rsblt	r8, r8, #0
            if (currentStep > 100)
 80031a2:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
Note that battery resistance is scaled by 65536 due to its low real value.
The algorithm computes the averaged voltage and current steps and divides
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
 80031a6:	f834 9006 	ldrh.w	r9, [r4, r6]
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
 80031aa:	f834 b001 	ldrh.w	fp, [r4, r1]
            int32_t currentStep = abs(batteryCurrent-lastBatteryCurrent[i]);
            if (currentStep > 100)
 80031ae:	dd37      	ble.n	8003220 <prvMeasurementTask+0x224>
            {
/* Apply a weighted IIR filter to estimate the average voltage and current. */
/* The forgetting factor getAlphaR() (<1) is multiplied by 256 to make integer,
therefore the correction factors need to be divided back by 256. */
/* Seed the filter with the most recent measurements (rather than zero) */
                if (voltageStepAv[i] == 0) voltageStepAv[i] = voltageStep;
 80031b0:	4e2b      	ldr	r6, [pc, #172]	; (8003260 <prvMeasurementTask+0x264>)
Note that battery resistance is scaled by 65536 due to its low real value.
The algorithm computes the averaged voltage and current steps and divides
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
 80031b2:	fa0f f089 	sxth.w	r0, r9
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
 80031b6:	fa0f fe8b 	sxth.w	lr, fp
            {
/* Apply a weighted IIR filter to estimate the average voltage and current. */
/* The forgetting factor getAlphaR() (<1) is multiplied by 256 to make integer,
therefore the correction factors need to be divided back by 256. */
/* Seed the filter with the most recent measurements (rather than zero) */
                if (voltageStepAv[i] == 0) voltageStepAv[i] = voltageStep;
 80031ba:	5fa3      	ldrsh	r3, [r4, r6]
The algorithm computes the averaged voltage and current steps and divides
them. This automatically weights the contributions of larger steps to
imcrease their overall effect over the smaller steps. The voltage and current
averaged are linear unbiassed estimators. */
            int32_t batteryVoltage = voltages.dataArray.battery[i];
            int32_t voltageStep = abs(batteryVoltage-lastBatteryVoltage[i]);
 80031bc:	ebce 0a00 	rsb	sl, lr, r0
 80031c0:	f1ba 0f00 	cmp.w	sl, #0
 80031c4:	bfb8      	it	lt
 80031c6:	f1ca 0a00 	rsblt	sl, sl, #0
            {
/* Apply a weighted IIR filter to estimate the average voltage and current. */
/* The forgetting factor getAlphaR() (<1) is multiplied by 256 to make integer,
therefore the correction factors need to be divided back by 256. */
/* Seed the filter with the most recent measurements (rather than zero) */
                if (voltageStepAv[i] == 0) voltageStepAv[i] = voltageStep;
 80031ca:	b90b      	cbnz	r3, 80031d0 <prvMeasurementTask+0x1d4>
 80031cc:	f826 a004 	strh.w	sl, [r6, r4]
                voltageStepAv[i] = voltageStepAv[i] +
 80031d0:	f836 b004 	ldrh.w	fp, [r6, r4]
                         ((getAlphaR()*(voltageStep - voltageStepAv[i])) >> 8);
 80031d4:	f7ff feaa 	bl	8002f2c <getAlphaR>
 80031d8:	5f31      	ldrsh	r1, [r6, r4]
 80031da:	ebc1 020a 	rsb	r2, r1, sl
 80031de:	fb02 f000 	mul.w	r0, r2, r0
/* Apply a weighted IIR filter to estimate the average voltage and current. */
/* The forgetting factor getAlphaR() (<1) is multiplied by 256 to make integer,
therefore the correction factors need to be divided back by 256. */
/* Seed the filter with the most recent measurements (rather than zero) */
                if (voltageStepAv[i] == 0) voltageStepAv[i] = voltageStep;
                voltageStepAv[i] = voltageStepAv[i] +
 80031e2:	eb0b 2320 	add.w	r3, fp, r0, asr #8
 80031e6:	5333      	strh	r3, [r6, r4]
                         ((getAlphaR()*(voltageStep - voltageStepAv[i])) >> 8);
                if (currentStepAv[i] == 0) currentStepAv[i] = currentStep;
 80031e8:	4e1e      	ldr	r6, [pc, #120]	; (8003264 <prvMeasurementTask+0x268>)
 80031ea:	5fa1      	ldrsh	r1, [r4, r6]
 80031ec:	b909      	cbnz	r1, 80031f2 <prvMeasurementTask+0x1f6>
 80031ee:	f826 8004 	strh.w	r8, [r6, r4]
                currentStepAv[i] = currentStepAv[i] +
 80031f2:	f836 a004 	ldrh.w	sl, [r6, r4]
                         ((getAlphaR()*(currentStep - currentStepAv[i])) >> 8);
 80031f6:	f7ff fe99 	bl	8002f2c <getAlphaR>
 80031fa:	5f32      	ldrsh	r2, [r6, r4]
 80031fc:	ebc2 0c08 	rsb	ip, r2, r8
 8003200:	fb0c f000 	mul.w	r0, ip, r0
/* Seed the filter with the most recent measurements (rather than zero) */
                if (voltageStepAv[i] == 0) voltageStepAv[i] = voltageStep;
                voltageStepAv[i] = voltageStepAv[i] +
                         ((getAlphaR()*(voltageStep - voltageStepAv[i])) >> 8);
                if (currentStepAv[i] == 0) currentStepAv[i] = currentStep;
                currentStepAv[i] = currentStepAv[i] +
 8003204:	eb0a 2320 	add.w	r3, sl, r0, asr #8
 8003208:	b299      	uxth	r1, r3
 800320a:	5331      	strh	r1, [r6, r4]
                         ((getAlphaR()*(currentStep - currentStepAv[i])) >> 8);
                if (currentStepAv[i] > 100)
 800320c:	b20e      	sxth	r6, r1
 800320e:	2e64      	cmp	r6, #100	; 0x64
 8003210:	dd06      	ble.n	8003220 <prvMeasurementTask+0x224>
                    batteryResistanceAv[i] = (voltageStepAv[i]<<16)/currentStepAv[i];
 8003212:	4a13      	ldr	r2, [pc, #76]	; (8003260 <prvMeasurementTask+0x264>)
 8003214:	5ea0      	ldrsh	r0, [r4, r2]
 8003216:	0403      	lsls	r3, r0, #16
 8003218:	fb93 f1f6 	sdiv	r1, r3, r6
 800321c:	4e07      	ldr	r6, [pc, #28]	; (800323c <prvMeasurementTask+0x240>)
 800321e:	53a1      	strh	r1, [r4, r6]
            }
            lastBatteryVoltage[i] = batteryVoltage;
 8003220:	4a04      	ldr	r2, [pc, #16]	; (8003234 <prvMeasurementTask+0x238>)
            lastBatteryCurrent[i] = batteryCurrent;
 8003222:	4805      	ldr	r0, [pc, #20]	; (8003238 <prvMeasurementTask+0x23c>)
 8003224:	3501      	adds	r5, #1
                currentStepAv[i] = currentStepAv[i] +
                         ((getAlphaR()*(currentStep - currentStepAv[i])) >> 8);
                if (currentStepAv[i] > 100)
                    batteryResistanceAv[i] = (voltageStepAv[i]<<16)/currentStepAv[i];
            }
            lastBatteryVoltage[i] = batteryVoltage;
 8003226:	f824 9002 	strh.w	r9, [r4, r2]
            lastBatteryCurrent[i] = batteryCurrent;
 800322a:	5227      	strh	r7, [r4, r0]
 800322c:	3402      	adds	r4, #2
            av[k+1] = 0;
        }
        temperature = ((av[12]/N_SAMPLES-TEMPERATURE_OFFSET)*TEMPERATURE_SCALE)/4096;
        av[12] = 0;

        for (i=0; i<NUM_BATS; i++)
 800322e:	2d03      	cmp	r5, #3
 8003230:	d196      	bne.n	8003160 <prvMeasurementTask+0x164>
 8003232:	e727      	b.n	8003084 <prvMeasurementTask+0x88>
 8003234:	200010fe 	.word	0x200010fe
 8003238:	2000110a 	.word	0x2000110a
 800323c:	20001104 	.word	0x20001104
 8003240:	200010d4 	.word	0x200010d4
 8003244:	40012400 	.word	0x40012400
 8003248:	200010d0 	.word	0x200010d0
 800324c:	fef9b477 	.word	0xfef9b477
 8003250:	200010e6 	.word	0x200010e6
 8003254:	00904159 	.word	0x00904159
 8003258:	200010f2 	.word	0x200010f2
 800325c:	200010c8 	.word	0x200010c8
 8003260:	200010e0 	.word	0x200010e0
 8003264:	200010ca 	.word	0x200010ca

08003268 <getBatteryResistanceAv>:
*/

int16_t getBatteryResistanceAv(int battery)
{
    return batteryResistanceAv[battery];
}
 8003268:	4b01      	ldr	r3, [pc, #4]	; (8003270 <getBatteryResistanceAv+0x8>)
 800326a:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
 800326e:	4770      	bx	lr
 8003270:	20001104 	.word	0x20001104

08003274 <getBatteryAccumulatedCharge>:

@param[in] battery: 0..NUM_BATS-1
*/

int16_t getBatteryAccumulatedCharge(int battery)
{
 8003274:	b538      	push	{r3, r4, r5, lr}
 8003276:	4604      	mov	r4, r0
    taskENTER_CRITICAL();
 8003278:	f003 f800 	bl	800627c <vPortEnterCritical>
    int16_t accumulatedCharge = accumulatedBatteryCharge[battery];
 800327c:	4b04      	ldr	r3, [pc, #16]	; (8003290 <getBatteryAccumulatedCharge+0x1c>)
    accumulatedBatteryCharge[battery] = 0;
 800327e:	2200      	movs	r2, #0
*/

int16_t getBatteryAccumulatedCharge(int battery)
{
    taskENTER_CRITICAL();
    int16_t accumulatedCharge = accumulatedBatteryCharge[battery];
 8003280:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
    accumulatedBatteryCharge[battery] = 0;
 8003284:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    taskEXIT_CRITICAL();
 8003288:	f003 f80e 	bl	80062a8 <vPortExitCritical>
    return accumulatedCharge;
}
 800328c:	b228      	sxth	r0, r5
 800328e:	bd38      	pop	{r3, r4, r5, pc}
 8003290:	200010d4 	.word	0x200010d4

08003294 <getBatteryCurrent>:
*/

int16_t getBatteryCurrent(int battery)
{
    return currents.dataArray.battery[battery];
}
 8003294:	4b01      	ldr	r3, [pc, #4]	; (800329c <getBatteryCurrent+0x8>)
 8003296:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
 800329a:	4770      	bx	lr
 800329c:	200010e6 	.word	0x200010e6

080032a0 <getBatteryVoltage>:
*/

int16_t getBatteryVoltage(int battery)
{
    return voltages.dataArray.battery[battery];
}
 80032a0:	4b01      	ldr	r3, [pc, #4]	; (80032a8 <getBatteryVoltage+0x8>)
 80032a2:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
 80032a6:	4770      	bx	lr
 80032a8:	200010f2 	.word	0x200010f2

080032ac <getLoadCurrent>:
@param[in] load: 0..NUM_LOADS-1
*/

int16_t getLoadCurrent(int load)
{
    return currents.dataArray.load[load];
 80032ac:	4b02      	ldr	r3, [pc, #8]	; (80032b8 <getLoadCurrent+0xc>)
 80032ae:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 80032b2:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 80032b6:	4770      	bx	lr
 80032b8:	200010e6 	.word	0x200010e6

080032bc <getLoadVoltage>:
@param[in] load: 0..NUM_LOADS-1
*/

int16_t getLoadVoltage(int load)
{
    return voltages.dataArray.load[load];
 80032bc:	4b02      	ldr	r3, [pc, #8]	; (80032c8 <getLoadVoltage+0xc>)
 80032be:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 80032c2:	f9b0 0006 	ldrsh.w	r0, [r0, #6]
 80032c6:	4770      	bx	lr
 80032c8:	200010f2 	.word	0x200010f2

080032cc <getPanelCurrent>:
@param[in] panel: 0..NUM_PANELS-1
*/

int16_t getPanelCurrent(int panel)
{
    return currents.dataArray.panel[panel];
 80032cc:	4b02      	ldr	r3, [pc, #8]	; (80032d8 <getPanelCurrent+0xc>)
 80032ce:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 80032d2:	f9b0 000a 	ldrsh.w	r0, [r0, #10]
 80032d6:	4770      	bx	lr
 80032d8:	200010e6 	.word	0x200010e6

080032dc <getPanelVoltage>:
@param[in] panel: 0..NUM_PANELS-1
*/

int16_t getPanelVoltage(int panel)
{
    return voltages.dataArray.panel[panel];
 80032dc:	4b02      	ldr	r3, [pc, #8]	; (80032e8 <getPanelVoltage+0xc>)
 80032de:	eb03 0040 	add.w	r0, r3, r0, lsl #1
}
 80032e2:	f9b0 000a 	ldrsh.w	r0, [r0, #10]
 80032e6:	4770      	bx	lr
 80032e8:	200010f2 	.word	0x200010f2

080032ec <getCurrent>:
*/

int16_t getCurrent(int intf)
{
    return currents.data[intf];
}
 80032ec:	4b01      	ldr	r3, [pc, #4]	; (80032f4 <getCurrent+0x8>)
 80032ee:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
 80032f2:	4770      	bx	lr
 80032f4:	200010e6 	.word	0x200010e6

080032f8 <getTemperature>:
*/

int32_t getTemperature(void)
{
    return temperature;
}
 80032f8:	4b01      	ldr	r3, [pc, #4]	; (8003300 <getTemperature+0x8>)
 80032fa:	f9b3 0000 	ldrsh.w	r0, [r3]
 80032fe:	4770      	bx	lr
 8003300:	200010c8 	.word	0x200010c8

08003304 <checkMeasurementWatchdog>:

The watchdog counter is decremented. If it reaches zero then the task is reset.
*/

void checkMeasurementWatchdog(void)
{
 8003304:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    if (measurementWatchdogCount++ > 10*getMeasurementDelay()/getWatchdogDelay())
 8003306:	4d15      	ldr	r5, [pc, #84]	; (800335c <checkMeasurementWatchdog+0x58>)
 8003308:	782c      	ldrb	r4, [r5, #0]
 800330a:	f7ff fe31 	bl	8002f70 <getMeasurementDelay>
 800330e:	4606      	mov	r6, r0
 8003310:	f7ff fe22 	bl	8002f58 <getWatchdogDelay>
 8003314:	210a      	movs	r1, #10
 8003316:	4371      	muls	r1, r6
 8003318:	fbb1 f0f0 	udiv	r0, r1, r0
 800331c:	1c63      	adds	r3, r4, #1
 800331e:	4284      	cmp	r4, r0
 8003320:	702b      	strb	r3, [r5, #0]
 8003322:	d918      	bls.n	8003356 <checkMeasurementWatchdog+0x52>
    {
        vTaskDelete(prvMeasurementTask);
 8003324:	480e      	ldr	r0, [pc, #56]	; (8003360 <checkMeasurementWatchdog+0x5c>)
 8003326:	f002 f8a1 	bl	800546c <vTaskDelete>
    	xTaskCreate(prvMeasurementTask, (signed portCHAR * ) "Measurement", \
 800332a:	2300      	movs	r3, #0
 800332c:	2203      	movs	r2, #3
 800332e:	9200      	str	r2, [sp, #0]
 8003330:	9301      	str	r3, [sp, #4]
 8003332:	9302      	str	r3, [sp, #8]
 8003334:	9303      	str	r3, [sp, #12]
 8003336:	2280      	movs	r2, #128	; 0x80
 8003338:	490a      	ldr	r1, [pc, #40]	; (8003364 <checkMeasurementWatchdog+0x60>)
 800333a:	4809      	ldr	r0, [pc, #36]	; (8003360 <checkMeasurementWatchdog+0x5c>)
 800333c:	f001 ffd0 	bl	80052e0 <xTaskGenericCreate>
                configMINIMAL_STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL);
        sendStringLowPriority("D","Measurement Restarted");
 8003340:	4809      	ldr	r0, [pc, #36]	; (8003368 <checkMeasurementWatchdog+0x64>)
 8003342:	490a      	ldr	r1, [pc, #40]	; (800336c <checkMeasurementWatchdog+0x68>)
 8003344:	f7fc fff0 	bl	8000328 <sendStringLowPriority>
        recordString("D","Measurement Restarted");
 8003348:	4807      	ldr	r0, [pc, #28]	; (8003368 <checkMeasurementWatchdog+0x64>)
 800334a:	4908      	ldr	r1, [pc, #32]	; (800336c <checkMeasurementWatchdog+0x68>)
    }
}
 800334c:	b004      	add	sp, #16
 800334e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    {
        vTaskDelete(prvMeasurementTask);
    	xTaskCreate(prvMeasurementTask, (signed portCHAR * ) "Measurement", \
                configMINIMAL_STACK_SIZE, NULL, MEASUREMENT_TASK_PRIORITY, NULL);
        sendStringLowPriority("D","Measurement Restarted");
        recordString("D","Measurement Restarted");
 8003352:	f7fe b873 	b.w	800143c <recordString>
    }
}
 8003356:	b004      	add	sp, #16
 8003358:	bd70      	pop	{r4, r5, r6, pc}
 800335a:	bf00      	nop
 800335c:	200010d0 	.word	0x200010d0
 8003360:	08002ffd 	.word	0x08002ffd
 8003364:	080074a9 	.word	0x080074a9
 8003368:	080074e2 	.word	0x080074e2
 800336c:	08007572 	.word	0x08007572

08003370 <prvWatchdogTask>:
Each call to the check functions in the task APIs should restart the task if a
timeout has occurred.
*/

void prvWatchdogTask(void *pvParameters)
{
 8003370:	b508      	push	{r3, lr}
	while (1)
	{
/* Reset the hardware independent watchdog timer */
        iwdgReset();
 8003372:	f7ff fac7 	bl	8002904 <iwdgReset>
/* Wait until the next tick cycle */
		vTaskDelay(getWatchdogDelay());
 8003376:	f7ff fdef 	bl	8002f58 <getWatchdogDelay>
 800337a:	f002 fa01 	bl	8005780 <vTaskDelay>
        checkChargerWatchdog();
 800337e:	f7ff f83f 	bl	8002400 <checkChargerWatchdog>
        checkMeasurementWatchdog();
 8003382:	f7ff ffbf 	bl	8003304 <checkMeasurementWatchdog>
        checkMonitorWatchdog();
 8003386:	f7fe fe99 	bl	80020bc <checkMonitorWatchdog>
 800338a:	e7f2      	b.n	8003372 <prvWatchdogTask+0x2>

0800338c <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 800338c:	b510      	push	{r4, lr}
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
 800338e:	2300      	movs	r3, #0
 8003390:	4293      	cmp	r3, r2
 8003392:	d003      	beq.n	800339c <mem_cpy+0x10>
		*d++ = *s++;
 8003394:	5ccc      	ldrb	r4, [r1, r3]
 8003396:	54c4      	strb	r4, [r0, r3]
 8003398:	3301      	adds	r3, #1
 800339a:	e7f9      	b.n	8003390 <mem_cpy+0x4>
}
 800339c:	bd10      	pop	{r4, pc}

0800339e <get_fileinfo>:
	UINT i;
	TCHAR *p, c;


	p = fno->fname;
	if (dp->sect) {		/* Get SFN */
 800339e:	6903      	ldr	r3, [r0, #16]
static
void get_fileinfo (		/* No return code */
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno	 	/* Pointer to the file information to be filled */
)
{
 80033a0:	b530      	push	{r4, r5, lr}
	UINT i;
	TCHAR *p, c;


	p = fno->fname;
 80033a2:	f101 0209 	add.w	r2, r1, #9
	if (dp->sect) {		/* Get SFN */
 80033a6:	b343      	cbz	r3, 80033fa <get_fileinfo+0x5c>
		BYTE *dir = dp->dir;
 80033a8:	6943      	ldr	r3, [r0, #20]

		i = 0;
 80033aa:	2000      	movs	r0, #0
		while (i < 11) {		/* Copy name body and extension */
			c = (TCHAR)dir[i++];
 80033ac:	5c1c      	ldrb	r4, [r3, r0]
 80033ae:	3001      	adds	r0, #1
			if (c == ' ') continue;			/* Skip padding spaces */
 80033b0:	2c20      	cmp	r4, #32
 80033b2:	d009      	beq.n	80033c8 <get_fileinfo+0x2a>
			if (c == NDDE) c = (TCHAR)DDE;	/* Restore replaced DDE character */
 80033b4:	2c05      	cmp	r4, #5
 80033b6:	bf08      	it	eq
 80033b8:	24e5      	moveq	r4, #229	; 0xe5
			if (i == 9) *p++ = '.';			/* Insert a . if extension is exist */
 80033ba:	2809      	cmp	r0, #9
 80033bc:	d102      	bne.n	80033c4 <get_fileinfo+0x26>
 80033be:	252e      	movs	r5, #46	; 0x2e
 80033c0:	f802 5b01 	strb.w	r5, [r2], #1
				c = c << 8 | dir[i++];
			c = ff_convert(c, 1);	/* OEM -> Unicode */
			if (!c) c = '?';
#endif
#endif
			*p++ = c;
 80033c4:	f802 4b01 	strb.w	r4, [r2], #1
	p = fno->fname;
	if (dp->sect) {		/* Get SFN */
		BYTE *dir = dp->dir;

		i = 0;
		while (i < 11) {		/* Copy name body and extension */
 80033c8:	280b      	cmp	r0, #11
 80033ca:	d1ef      	bne.n	80033ac <get_fileinfo+0xe>
			if (!c) c = '?';
#endif
#endif
			*p++ = c;
		}
		fno->fattrib = dir[DIR_Attr];				/* Attribute */
 80033cc:	7adc      	ldrb	r4, [r3, #11]
 80033ce:	720c      	strb	r4, [r1, #8]
		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
 80033d0:	7f98      	ldrb	r0, [r3, #30]
 80033d2:	7fdc      	ldrb	r4, [r3, #31]
 80033d4:	0400      	lsls	r0, r0, #16
 80033d6:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 80033da:	7f1c      	ldrb	r4, [r3, #28]
 80033dc:	4320      	orrs	r0, r4
 80033de:	7f5c      	ldrb	r4, [r3, #29]
 80033e0:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
 80033e4:	6008      	str	r0, [r1, #0]
		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
 80033e6:	7e5c      	ldrb	r4, [r3, #25]
 80033e8:	7e18      	ldrb	r0, [r3, #24]
 80033ea:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
 80033ee:	8088      	strh	r0, [r1, #4]
		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
 80033f0:	7dd8      	ldrb	r0, [r3, #23]
 80033f2:	7d9b      	ldrb	r3, [r3, #22]
 80033f4:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80033f8:	80c8      	strh	r0, [r1, #6]
	}
	*p = 0;		/* Terminate SFN string by a \0 */
 80033fa:	2100      	movs	r1, #0
 80033fc:	7011      	strb	r1, [r2, #0]
 80033fe:	bd30      	pop	{r4, r5, pc}

08003400 <get_ldnumber>:
)
{
	int vol = -1;


	if (*path) {
 8003400:	6803      	ldr	r3, [r0, #0]

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8003402:	4602      	mov	r2, r0
	int vol = -1;


	if (*path) {
 8003404:	b913      	cbnz	r3, 800340c <get_ldnumber+0xc>
static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
	int vol = -1;
 8003406:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800340a:	4770      	bx	lr


	if (*path) {
		vol = (*path)[0] - '0';
 800340c:	7818      	ldrb	r0, [r3, #0]
 800340e:	3830      	subs	r0, #48	; 0x30
		if ((UINT)vol < 9 && (*path)[1] == ':') {	/* There is a drive number */
 8003410:	2808      	cmp	r0, #8
 8003412:	d806      	bhi.n	8003422 <get_ldnumber+0x22>
 8003414:	7859      	ldrb	r1, [r3, #1]
 8003416:	293a      	cmp	r1, #58	; 0x3a
 8003418:	d103      	bne.n	8003422 <get_ldnumber+0x22>
			*path += 2;		/* Get value and strip it */
 800341a:	3302      	adds	r3, #2
 800341c:	6013      	str	r3, [r2, #0]
			if (vol >= _VOLUMES) vol = -1;	/* Check if the drive number is valid */
 800341e:	b108      	cbz	r0, 8003424 <get_ldnumber+0x24>
 8003420:	e7f1      	b.n	8003406 <get_ldnumber+0x6>
		} else {			/* No drive number use default drive */
#if _FS_RPATH && _VOLUMES >= 2
			vol = CurrVol;	/* Current drive */
#else
			vol = 0;		/* Drive 0 */
 8003422:	2000      	movs	r0, #0
#endif
		}
	}

	return vol;
}
 8003424:	4770      	bx	lr

08003426 <validate>:

static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	void* obj		/* Pointer to the object FIL/DIR to check validity */
)
{
 8003426:	b508      	push	{r3, lr}
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
 8003428:	b180      	cbz	r0, 800344c <validate+0x26>
 800342a:	6803      	ldr	r3, [r0, #0]
 800342c:	b173      	cbz	r3, 800344c <validate+0x26>
 800342e:	781a      	ldrb	r2, [r3, #0]
 8003430:	b162      	cbz	r2, 800344c <validate+0x26>
 8003432:	88d9      	ldrh	r1, [r3, #6]
 8003434:	8880      	ldrh	r0, [r0, #4]
 8003436:	4281      	cmp	r1, r0
 8003438:	d108      	bne.n	800344c <validate+0x26>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
 800343a:	7858      	ldrb	r0, [r3, #1]
 800343c:	f001 fc8e 	bl	8004d5c <disk_status>
 8003440:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
 8003444:	bf0c      	ite	eq
 8003446:	2000      	moveq	r0, #0
 8003448:	2003      	movne	r0, #3
 800344a:	bd08      	pop	{r3, pc}
{
	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */


	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
 800344c:	2009      	movs	r0, #9

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
 800344e:	bd08      	pop	{r3, pc}

08003450 <ld_clust.isra.0>:
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8003450:	7eca      	ldrb	r2, [r1, #27]
 8003452:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32)
 8003454:	2803      	cmp	r0, #3
	BYTE* dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
 8003456:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (fs->fs_type == FS_FAT32)
 800345a:	d105      	bne.n	8003468 <ld_clust.isra.0+0x18>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
 800345c:	7d48      	ldrb	r0, [r1, #21]
 800345e:	7d09      	ldrb	r1, [r1, #20]
 8003460:	ea41 2200 	orr.w	r2, r1, r0, lsl #8
 8003464:	ea43 4302 	orr.w	r3, r3, r2, lsl #16

	return cl;
}
 8003468:	4618      	mov	r0, r3
 800346a:	4770      	bx	lr

0800346c <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (
	FATFS* fs		/* File system object */
)
{
 800346c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800346e:	4604      	mov	r4, r0
	DWORD wsect;
	UINT nf;


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 8003470:	7900      	ldrb	r0, [r0, #4]
 8003472:	b1f8      	cbz	r0, 80034b4 <sync_window+0x48>
		wsect = fs->winsect;	/* Current sector number */
 8003474:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1))
 8003476:	f104 0730 	add.w	r7, r4, #48	; 0x30
 800347a:	7860      	ldrb	r0, [r4, #1]
 800347c:	4639      	mov	r1, r7
 800347e:	462a      	mov	r2, r5
 8003480:	2301      	movs	r3, #1
 8003482:	f001 fcb5 	bl	8004df0 <disk_write>
 8003486:	b9a0      	cbnz	r0, 80034b2 <sync_window+0x46>
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8003488:	6a23      	ldr	r3, [r4, #32]

	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
 800348a:	7120      	strb	r0, [r4, #4]
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800348c:	69a0      	ldr	r0, [r4, #24]
 800348e:	1aea      	subs	r2, r5, r3
 8003490:	4282      	cmp	r2, r0
 8003492:	d301      	bcc.n	8003498 <sync_window+0x2c>
				wsect += fs->fsize;
				disk_write(fs->drv, fs->win, wsect, 1);
			}
		}
	}
	return FR_OK;
 8003494:	2000      	movs	r0, #0
 8003496:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8003498:	78e6      	ldrb	r6, [r4, #3]
 800349a:	2e01      	cmp	r6, #1
 800349c:	d9fa      	bls.n	8003494 <sync_window+0x28>
				wsect += fs->fsize;
 800349e:	69a1      	ldr	r1, [r4, #24]
				disk_write(fs->drv, fs->win, wsect, 1);
 80034a0:	7860      	ldrb	r0, [r4, #1]
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
				wsect += fs->fsize;
 80034a2:	186d      	adds	r5, r5, r1
				disk_write(fs->drv, fs->win, wsect, 1);
 80034a4:	462a      	mov	r2, r5
 80034a6:	4639      	mov	r1, r7
 80034a8:	2301      	movs	r3, #1
 80034aa:	f001 fca1 	bl	8004df0 <disk_write>
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
		fs->wflag = 0;
		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 80034ae:	3e01      	subs	r6, #1
 80034b0:	e7f3      	b.n	800349a <sync_window+0x2e>


	if (fs->wflag) {	/* Write back the sector if it is dirty */
		wsect = fs->winsect;	/* Current sector number */
		if (disk_write(fs->drv, fs->win, wsect, 1))
			return FR_DISK_ERR;
 80034b2:	2001      	movs	r0, #1
				disk_write(fs->drv, fs->win, wsect, 1);
			}
		}
	}
	return FR_OK;
}
 80034b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080034b6 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS* fs		/* File system object */
)
{
 80034b6:	b538      	push	{r3, r4, r5, lr}
 80034b8:	4604      	mov	r4, r0
	FRESULT res;


	res = sync_window(fs);
 80034ba:	f7ff ffd7 	bl	800346c <sync_window>
	if (res == FR_OK) {
 80034be:	2800      	cmp	r0, #0
 80034c0:	d151      	bne.n	8003566 <sync_fs+0xb0>
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80034c2:	7823      	ldrb	r3, [r4, #0]
 80034c4:	2b03      	cmp	r3, #3
 80034c6:	d146      	bne.n	8003556 <sync_fs+0xa0>
 80034c8:	7961      	ldrb	r1, [r4, #5]
 80034ca:	2901      	cmp	r1, #1
 80034cc:	d143      	bne.n	8003556 <sync_fs+0xa0>
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
 80034ce:	f104 0130 	add.w	r1, r4, #48	; 0x30
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 80034d2:	2500      	movs	r5, #0
 80034d4:	540d      	strb	r5, [r1, r0]
 80034d6:	3001      	adds	r0, #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 80034d8:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80034dc:	d1f9      	bne.n	80034d2 <sync_fs+0x1c>
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 80034de:	2352      	movs	r3, #82	; 0x52
 80034e0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
 80034e4:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
 80034e8:	2361      	movs	r3, #97	; 0x61
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80034ea:	2055      	movs	r0, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 80034ec:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 80034f0:	f884 3217 	strb.w	r3, [r4, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 80034f4:	6923      	ldr	r3, [r4, #16]
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80034f6:	f884 022e 	strb.w	r0, [r4, #558]	; 0x22e
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 80034fa:	2072      	movs	r0, #114	; 0x72
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 80034fc:	22aa      	movs	r2, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 80034fe:	f884 0214 	strb.w	r0, [r4, #532]	; 0x214
 8003502:	f884 0215 	strb.w	r0, [r4, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 8003506:	0c18      	lsrs	r0, r3, #16
	if (res == FR_OK) {
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
 8003508:	f884 222f 	strb.w	r2, [r4, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 800350c:	f884 021a 	strb.w	r0, [r4, #538]	; 0x21a
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 8003510:	2241      	movs	r2, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8003512:	68e0      	ldr	r0, [r4, #12]
		/* Update FSINFO sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
 8003514:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
 8003518:	f884 2216 	strb.w	r2, [r4, #534]	; 0x216
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 800351c:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8003520:	f884 2219 	strb.w	r2, [r4, #537]	; 0x219
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8003524:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8003528:	f884 221d 	strb.w	r2, [r4, #541]	; 0x21d
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 800352c:	69e2      	ldr	r2, [r4, #28]
			/* Create FSINFO structure */
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
 800352e:	f884 3218 	strb.w	r3, [r4, #536]	; 0x218
 8003532:	0e1b      	lsrs	r3, r3, #24
 8003534:	f884 321b 	strb.w	r3, [r4, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8003538:	f884 021c 	strb.w	r0, [r4, #540]	; 0x21c
 800353c:	0c03      	lsrs	r3, r0, #16
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 800353e:	3201      	adds	r2, #1
			mem_set(fs->win, 0, SS(fs));
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
 8003540:	0e00      	lsrs	r0, r0, #24
 8003542:	f884 321e 	strb.w	r3, [r4, #542]	; 0x21e
 8003546:	f884 021f 	strb.w	r0, [r4, #543]	; 0x21f
			/* Write it into the FSINFO sector */
			fs->winsect = fs->volbase + 1;
 800354a:	62e2      	str	r2, [r4, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 800354c:	7860      	ldrb	r0, [r4, #1]
 800354e:	2301      	movs	r3, #1
 8003550:	f001 fc4e 	bl	8004df0 <disk_write>
			fs->fsi_flag = 0;
 8003554:	7165      	strb	r5, [r4, #5]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
 8003556:	2100      	movs	r1, #0
 8003558:	7860      	ldrb	r0, [r4, #1]
 800355a:	460a      	mov	r2, r1
 800355c:	f001 fcaa 	bl	8004eb4 <disk_ioctl>
 8003560:	3000      	adds	r0, #0
 8003562:	bf18      	it	ne
 8003564:	2001      	movne	r0, #1
			res = FR_DISK_ERR;
	}

	return res;
}
 8003566:	bd38      	pop	{r3, r4, r5, pc}

08003568 <move_window>:
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
 8003568:	b538      	push	{r3, r4, r5, lr}
	if (sector != fs->winsect) {	/* Changed current window */
 800356a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
 800356c:	4604      	mov	r4, r0
	if (sector != fs->winsect) {	/* Changed current window */
 800356e:	4299      	cmp	r1, r3
static
FRESULT move_window (
	FATFS* fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)
{
 8003570:	460d      	mov	r5, r1
	if (sector != fs->winsect) {	/* Changed current window */
 8003572:	d00c      	beq.n	800358e <move_window+0x26>
#if !_FS_READONLY
		if (sync_window(fs) != FR_OK)
 8003574:	f7ff ff7a 	bl	800346c <sync_window>
 8003578:	b958      	cbnz	r0, 8003592 <move_window+0x2a>
			return FR_DISK_ERR;
#endif
		if (disk_read(fs->drv, fs->win, sector, 1))
 800357a:	7860      	ldrb	r0, [r4, #1]
 800357c:	f104 0130 	add.w	r1, r4, #48	; 0x30
 8003580:	462a      	mov	r2, r5
 8003582:	2301      	movs	r3, #1
 8003584:	f001 fbf2 	bl	8004d6c <disk_read>
 8003588:	b918      	cbnz	r0, 8003592 <move_window+0x2a>
			return FR_DISK_ERR;
		fs->winsect = sector;
 800358a:	62e5      	str	r5, [r4, #44]	; 0x2c
 800358c:	bd38      	pop	{r3, r4, r5, pc}
	}

	return FR_OK;
 800358e:	2000      	movs	r0, #0
 8003590:	bd38      	pop	{r3, r4, r5, pc}
)
{
	if (sector != fs->winsect) {	/* Changed current window */
#if !_FS_READONLY
		if (sync_window(fs) != FR_OK)
			return FR_DISK_ERR;
 8003592:	2001      	movs	r0, #1
			return FR_DISK_ERR;
		fs->winsect = sector;
	}

	return FR_OK;
}
 8003594:	bd38      	pop	{r3, r4, r5, pc}
	...

08003598 <check_fs>:
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 8003598:	2300      	movs	r3, #0
 800359a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 800359e:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
 80035a0:	7103      	strb	r3, [r0, #4]
 80035a2:	62c2      	str	r2, [r0, #44]	; 0x2c
static
BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 80035a4:	4604      	mov	r4, r0
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
 80035a6:	f7ff ffdf 	bl	8003568 <move_window>
 80035aa:	bb80      	cbnz	r0, 800360e <check_fs+0x76>
		return 3;

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
 80035ac:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
 80035b0:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 80035b4:	ea43 2201 	orr.w	r2, r3, r1, lsl #8
 80035b8:	4b17      	ldr	r3, [pc, #92]	; (8003618 <check_fs+0x80>)
 80035ba:	b211      	sxth	r1, r2
 80035bc:	4299      	cmp	r1, r3
 80035be:	d128      	bne.n	8003612 <check_fs+0x7a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
 80035c0:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
 80035c4:	f894 1069 	ldrb.w	r1, [r4, #105]	; 0x69
 80035c8:	0413      	lsls	r3, r2, #16
 80035ca:	f894 2066 	ldrb.w	r2, [r4, #102]	; 0x66
 80035ce:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 80035d2:	f894 3067 	ldrb.w	r3, [r4, #103]	; 0x67
 80035d6:	4311      	orrs	r1, r2
 80035d8:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
 80035dc:	4b0f      	ldr	r3, [pc, #60]	; (800361c <check_fs+0x84>)
 80035de:	f021 427f 	bic.w	r2, r1, #4278190080	; 0xff000000
 80035e2:	429a      	cmp	r2, r3
 80035e4:	d016      	beq.n	8003614 <check_fs+0x7c>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 80035e6:	f894 0084 	ldrb.w	r0, [r4, #132]	; 0x84
 80035ea:	f894 1085 	ldrb.w	r1, [r4, #133]	; 0x85
 80035ee:	0402      	lsls	r2, r0, #16
 80035f0:	f894 0082 	ldrb.w	r0, [r4, #130]	; 0x82
 80035f4:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
 80035f8:	f894 2083 	ldrb.w	r2, [r4, #131]	; 0x83
 80035fc:	4301      	orrs	r1, r0
 80035fe:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 8003602:	f021 407f 	bic.w	r0, r1, #4278190080	; 0xff000000
		return 0;
 8003606:	1ac0      	subs	r0, r0, r3
 8003608:	bf18      	it	ne
 800360a:	2001      	movne	r0, #1
 800360c:	bd10      	pop	{r4, pc}
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
		return 3;
 800360e:	2003      	movs	r0, #3
 8003610:	bd10      	pop	{r4, pc}

	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
 8003612:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;

	return 1;
}
 8003614:	bd10      	pop	{r4, pc}
 8003616:	bf00      	nop
 8003618:	ffffaa55 	.word	0xffffaa55
 800361c:	00544146 	.word	0x00544146

08003620 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003620:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	WORD nrsv;
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
 8003624:	2300      	movs	r3, #0
 8003626:	6003      	str	r3, [r0, #0]
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 8003628:	4606      	mov	r6, r0
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 800362a:	4608      	mov	r0, r1
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	BYTE wmode			/* !=0: Check write protection for write access */
)
{
 800362c:	4615      	mov	r5, r2
	FATFS *fs;


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
 800362e:	f7ff fee7 	bl	8003400 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8003632:	1e07      	subs	r7, r0, #0
 8003634:	f2c0 8166 	blt.w	8003904 <find_volume+0x2e4>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8003638:	48b9      	ldr	r0, [pc, #740]	; (8003920 <find_volume+0x300>)
 800363a:	f850 4027 	ldr.w	r4, [r0, r7, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 800363e:	2c00      	cmp	r4, #0
 8003640:	f000 8162 	beq.w	8003908 <find_volume+0x2e8>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 8003644:	6034      	str	r4, [r6, #0]

	if (fs->fs_type) {					/* If the volume has been mounted */
 8003646:	7821      	ldrb	r1, [r4, #0]
 8003648:	b179      	cbz	r1, 800366a <find_volume+0x4a>
		stat = disk_status(fs->drv);
 800364a:	7860      	ldrb	r0, [r4, #1]
 800364c:	f001 fb86 	bl	8004d5c <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8003650:	07c1      	lsls	r1, r0, #31
 8003652:	d40a      	bmi.n	800366a <find_volume+0x4a>
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
 8003654:	2d00      	cmp	r5, #0
 8003656:	f000 8159 	beq.w	800390c <find_volume+0x2ec>
 800365a:	f000 0104 	and.w	r1, r0, #4
 800365e:	b2c8      	uxtb	r0, r1
				return FR_WRITE_PROTECTED;
 8003660:	2800      	cmp	r0, #0
 8003662:	bf14      	ite	ne
 8003664:	200a      	movne	r0, #10
 8003666:	2000      	moveq	r0, #0
 8003668:	e157      	b.n	800391a <find_volume+0x2fa>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 800366a:	2200      	movs	r2, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 800366c:	b2f8      	uxtb	r0, r7
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 800366e:	7022      	strb	r2, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8003670:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8003672:	f001 fac9 	bl	8004c08 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 8003676:	07c2      	lsls	r2, r0, #31
 8003678:	f100 814a 	bmi.w	8003910 <find_volume+0x2f0>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
 800367c:	b12d      	cbz	r5, 800368a <find_volume+0x6a>
 800367e:	f000 0304 	and.w	r3, r0, #4
 8003682:	b2d8      	uxtb	r0, r3
 8003684:	2800      	cmp	r0, #0
 8003686:	f040 8145 	bne.w	8003914 <find_volume+0x2f4>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
 800368a:	2100      	movs	r1, #0
 800368c:	4620      	mov	r0, r4
 800368e:	f7ff ff83 	bl	8003598 <check_fs>
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
 8003692:	2801      	cmp	r0, #1
 8003694:	d127      	bne.n	80036e6 <find_volume+0xc6>
 8003696:	2300      	movs	r3, #0
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
 8003698:	eb04 0583 	add.w	r5, r4, r3, lsl #2
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 800369c:	f895 61f2 	ldrb.w	r6, [r5, #498]	; 0x1f2
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
 80036a0:	f505 72f7 	add.w	r2, r5, #494	; 0x1ee
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
 80036a4:	b156      	cbz	r6, 80036bc <find_volume+0x9c>
 80036a6:	7a95      	ldrb	r5, [r2, #10]
 80036a8:	7ad0      	ldrb	r0, [r2, #11]
 80036aa:	042e      	lsls	r6, r5, #16
 80036ac:	ea46 6100 	orr.w	r1, r6, r0, lsl #24
 80036b0:	7a10      	ldrb	r0, [r2, #8]
 80036b2:	7a52      	ldrb	r2, [r2, #9]
 80036b4:	4301      	orrs	r1, r0
 80036b6:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 80036ba:	e000      	b.n	80036be <find_volume+0x9e>
 80036bc:	4631      	mov	r1, r6
 80036be:	f84d 1003 	str.w	r1, [sp, r3]
 80036c2:	3304      	adds	r3, #4
	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
		UINT i;
		DWORD br[4];

		for (i = 0; i < 4; i++) {			/* Get partition offset */
 80036c4:	2b10      	cmp	r3, #16
 80036c6:	d1e7      	bne.n	8003698 <find_volume+0x78>
 80036c8:	2600      	movs	r6, #0
			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
 80036ca:	f85d 5006 	ldr.w	r5, [sp, r6]
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 80036ce:	b12d      	cbz	r5, 80036dc <find_volume+0xbc>
 80036d0:	4620      	mov	r0, r4
 80036d2:	4629      	mov	r1, r5
 80036d4:	f7ff ff60 	bl	8003598 <check_fs>
		} while (!LD2PT(vol) && fmt && ++i < 4);
 80036d8:	b908      	cbnz	r0, 80036de <find_volume+0xbe>
 80036da:	e00b      	b.n	80036f4 <find_volume+0xd4>
		}
		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
		if (i) i--;
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
 80036dc:	2002      	movs	r0, #2
 80036de:	3604      	adds	r6, #4
		} while (!LD2PT(vol) && fmt && ++i < 4);
 80036e0:	2e10      	cmp	r6, #16
 80036e2:	d1f2      	bne.n	80036ca <find_volume+0xaa>
 80036e4:	e000      	b.n	80036e8 <find_volume+0xc8>
#if _MAX_SS != 512						/* Get sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
	bsect = 0;
 80036e6:	2500      	movs	r5, #0
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 80036e8:	2803      	cmp	r0, #3
 80036ea:	f000 8115 	beq.w	8003918 <find_volume+0x2f8>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 80036ee:	b108      	cbz	r0, 80036f4 <find_volume+0xd4>
 80036f0:	200d      	movs	r0, #13
 80036f2:	e112      	b.n	800391a <find_volume+0x2fa>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 80036f4:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
 80036f8:	f894 003b 	ldrb.w	r0, [r4, #59]	; 0x3b
 80036fc:	ea40 2201 	orr.w	r2, r0, r1, lsl #8
 8003700:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8003704:	d1f4      	bne.n	80036f0 <find_volume+0xd0>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 8003706:	f894 6047 	ldrb.w	r6, [r4, #71]	; 0x47
 800370a:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 800370e:	ea53 2106 	orrs.w	r1, r3, r6, lsl #8
 8003712:	d10d      	bne.n	8003730 <find_volume+0x110>
 8003714:	f894 1056 	ldrb.w	r1, [r4, #86]	; 0x56
 8003718:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
 800371c:	040a      	lsls	r2, r1, #16
 800371e:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
 8003722:	ea42 6600 	orr.w	r6, r2, r0, lsl #24
 8003726:	f894 0055 	ldrb.w	r0, [r4, #85]	; 0x55
 800372a:	431e      	orrs	r6, r3
 800372c:	ea46 2100 	orr.w	r1, r6, r0, lsl #8
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 8003730:	f894 6040 	ldrb.w	r6, [r4, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
 8003734:	61a1      	str	r1, [r4, #24]

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 8003736:	1e72      	subs	r2, r6, #1
 8003738:	2a01      	cmp	r2, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
 800373a:	70e6      	strb	r6, [r4, #3]
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
 800373c:	d8d8      	bhi.n	80036f0 <find_volume+0xd0>
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
 800373e:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
 8003742:	70a2      	strb	r2, [r4, #2]
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
 8003744:	2a00      	cmp	r2, #0
 8003746:	d0d3      	beq.n	80036f0 <find_volume+0xd0>
 8003748:	1e53      	subs	r3, r2, #1
 800374a:	4213      	tst	r3, r2
 800374c:	d1d0      	bne.n	80036f0 <find_volume+0xd0>
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 800374e:	f894 0042 	ldrb.w	r0, [r4, #66]	; 0x42
 8003752:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8003756:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800375a:	b298      	uxth	r0, r3
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
 800375c:	071b      	lsls	r3, r3, #28

	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
		return FR_NO_FILESYSTEM;

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 800375e:	8120      	strh	r0, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
 8003760:	d1c6      	bne.n	80036f0 <find_volume+0xd0>
		return FR_NO_FILESYSTEM;

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 8003762:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
 8003766:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 800376a:	ea53 2307 	orrs.w	r3, r3, r7, lsl #8
 800376e:	d10d      	bne.n	800378c <find_volume+0x16c>
 8003770:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
 8003774:	f894 7053 	ldrb.w	r7, [r4, #83]	; 0x53
 8003778:	041b      	lsls	r3, r3, #16
 800377a:	ea43 6307 	orr.w	r3, r3, r7, lsl #24
 800377e:	f894 7050 	ldrb.w	r7, [r4, #80]	; 0x50
 8003782:	433b      	orrs	r3, r7
 8003784:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
 8003788:	ea43 2307 	orr.w	r3, r3, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 800378c:	f894 803f 	ldrb.w	r8, [r4, #63]	; 0x3f
 8003790:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
 8003794:	ea57 2808 	orrs.w	r8, r7, r8, lsl #8
 8003798:	d0aa      	beq.n	80036f0 <find_volume+0xd0>
	fs->fsize = fasize;

	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
		return FR_NO_FILESYSTEM;
	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
 800379a:	fb06 fc01 	mul.w	ip, r6, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 800379e:	eb08 1710 	add.w	r7, r8, r0, lsr #4
 80037a2:	4467      	add	r7, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 80037a4:	42bb      	cmp	r3, r7
 80037a6:	d3a3      	bcc.n	80036f0 <find_volume+0xd0>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 80037a8:	1bdb      	subs	r3, r3, r7
 80037aa:	fbb3 f3f2 	udiv	r3, r3, r2
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 80037ae:	2b00      	cmp	r3, #0
 80037b0:	d09e      	beq.n	80036f0 <find_volume+0xd0>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 80037b2:	f640 76f5 	movw	r6, #4085	; 0xff5
 80037b6:	42b3      	cmp	r3, r6
 80037b8:	d906      	bls.n	80037c8 <find_volume+0x1a8>
 80037ba:	f64f 72f5 	movw	r2, #65525	; 0xfff5
 80037be:	4293      	cmp	r3, r2
 80037c0:	bf8c      	ite	hi
 80037c2:	2603      	movhi	r6, #3
 80037c4:	2602      	movls	r6, #2
 80037c6:	e000      	b.n	80037ca <find_volume+0x1aa>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
 80037c8:	2601      	movs	r6, #1
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80037ca:	3302      	adds	r3, #2
	fs->volbase = bsect;								/* Volume start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80037cc:	eb05 0208 	add.w	r2, r5, r8
	fs->database = bsect + sysect;						/* Data start sector */
 80037d0:	197f      	adds	r7, r7, r5
	if (fmt == FS_FAT32) {
 80037d2:	2e03      	cmp	r6, #3
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 80037d4:	6163      	str	r3, [r4, #20]
	fs->volbase = bsect;								/* Volume start sector */
 80037d6:	61e5      	str	r5, [r4, #28]
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 80037d8:	6222      	str	r2, [r4, #32]
	fs->database = bsect + sysect;						/* Data start sector */
 80037da:	62a7      	str	r7, [r4, #40]	; 0x28
	if (fmt == FS_FAT32) {
 80037dc:	d112      	bne.n	8003804 <find_volume+0x1e4>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 80037de:	2800      	cmp	r0, #0
 80037e0:	d186      	bne.n	80036f0 <find_volume+0xd0>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 80037e2:	f894 205e 	ldrb.w	r2, [r4, #94]	; 0x5e
 80037e6:	f894 005f 	ldrb.w	r0, [r4, #95]	; 0x5f
 80037ea:	0412      	lsls	r2, r2, #16
 80037ec:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
 80037f0:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
 80037f4:	4302      	orrs	r2, r0
 80037f6:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
 80037fa:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 80037fe:	6262      	str	r2, [r4, #36]	; 0x24
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 8003800:	0098      	lsls	r0, r3, #2
 8003802:	e00f      	b.n	8003824 <find_volume+0x204>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 8003804:	2800      	cmp	r0, #0
 8003806:	f43f af73 	beq.w	80036f0 <find_volume+0xd0>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 800380a:	eb0c 0002 	add.w	r0, ip, r2
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 800380e:	2e02      	cmp	r6, #2
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 8003810:	6260      	str	r0, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8003812:	d101      	bne.n	8003818 <find_volume+0x1f8>
 8003814:	0058      	lsls	r0, r3, #1
 8003816:	e005      	b.n	8003824 <find_volume+0x204>
 8003818:	2203      	movs	r2, #3
 800381a:	435a      	muls	r2, r3
 800381c:	f003 0301 	and.w	r3, r3, #1
 8003820:	eb03 0052 	add.w	r0, r3, r2, lsr #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 8003824:	f200 13ff 	addw	r3, r0, #511	; 0x1ff
 8003828:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
 800382c:	f4ff af60 	bcc.w	80036f0 <find_volume+0xd0>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8003830:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 8003834:	2080      	movs	r0, #128	; 0x80
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 8003836:	2e03      	cmp	r6, #3
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
 8003838:	6121      	str	r1, [r4, #16]
 800383a:	60e1      	str	r1, [r4, #12]

	/* Get fsinfo if available */
	fs->fsi_flag = 0x80;
 800383c:	7160      	strb	r0, [r4, #5]
	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
 800383e:	d158      	bne.n	80038f2 <find_volume+0x2d2>
		&& LD_WORD(fs->win+BPB_FSInfo) == 1
 8003840:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
 8003844:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 8003848:	ea43 2102 	orr.w	r1, r3, r2, lsl #8
 800384c:	2901      	cmp	r1, #1
 800384e:	d150      	bne.n	80038f2 <find_volume+0x2d2>
		&& move_window(fs, bsect + 1) == FR_OK)
 8003850:	4620      	mov	r0, r4
 8003852:	1c69      	adds	r1, r5, #1
 8003854:	f7ff fe88 	bl	8003568 <move_window>
 8003858:	2800      	cmp	r0, #0
 800385a:	d14a      	bne.n	80038f2 <find_volume+0x2d2>
	{
		fs->fsi_flag = 0;
 800385c:	7160      	strb	r0, [r4, #5]
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 800385e:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e
 8003862:	f894 022f 	ldrb.w	r0, [r4, #559]	; 0x22f
 8003866:	ea42 2300 	orr.w	r3, r2, r0, lsl #8
 800386a:	482e      	ldr	r0, [pc, #184]	; (8003924 <find_volume+0x304>)
 800386c:	b219      	sxth	r1, r3
 800386e:	4281      	cmp	r1, r0
 8003870:	d13f      	bne.n	80038f2 <find_volume+0x2d2>
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
 8003872:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
 8003876:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
 800387a:	0411      	lsls	r1, r2, #16
 800387c:	ea41 6003 	orr.w	r0, r1, r3, lsl #24
 8003880:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8003884:	f894 2031 	ldrb.w	r2, [r4, #49]	; 0x31
 8003888:	4318      	orrs	r0, r3
 800388a:	ea40 2102 	orr.w	r1, r0, r2, lsl #8
 800388e:	4826      	ldr	r0, [pc, #152]	; (8003928 <find_volume+0x308>)
 8003890:	4281      	cmp	r1, r0
 8003892:	d12e      	bne.n	80038f2 <find_volume+0x2d2>
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
 8003894:	f894 2216 	ldrb.w	r2, [r4, #534]	; 0x216
 8003898:	f894 3217 	ldrb.w	r3, [r4, #535]	; 0x217
 800389c:	0411      	lsls	r1, r2, #16
 800389e:	ea41 6003 	orr.w	r0, r1, r3, lsl #24
 80038a2:	f894 3214 	ldrb.w	r3, [r4, #532]	; 0x214
 80038a6:	f894 2215 	ldrb.w	r2, [r4, #533]	; 0x215
 80038aa:	4318      	orrs	r0, r3
 80038ac:	ea40 2102 	orr.w	r1, r0, r2, lsl #8
 80038b0:	481e      	ldr	r0, [pc, #120]	; (800392c <find_volume+0x30c>)
 80038b2:	4281      	cmp	r1, r0
 80038b4:	d11d      	bne.n	80038f2 <find_volume+0x2d2>
		{
#if !_FS_NOFSINFO
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80038b6:	f894 321a 	ldrb.w	r3, [r4, #538]	; 0x21a
 80038ba:	f894 221b 	ldrb.w	r2, [r4, #539]	; 0x21b
 80038be:	0419      	lsls	r1, r3, #16
 80038c0:	ea41 6002 	orr.w	r0, r1, r2, lsl #24
 80038c4:	f894 2218 	ldrb.w	r2, [r4, #536]	; 0x218
 80038c8:	f894 3219 	ldrb.w	r3, [r4, #537]	; 0x219
 80038cc:	4310      	orrs	r0, r2
#endif
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80038ce:	f894 221e 	ldrb.w	r2, [r4, #542]	; 0x21e
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if !_FS_NOFSINFO
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80038d2:	ea40 2103 	orr.w	r1, r0, r3, lsl #8
#endif
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80038d6:	f894 021f 	ldrb.w	r0, [r4, #543]	; 0x21f
 80038da:	0413      	lsls	r3, r2, #16
		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
		{
#if !_FS_NOFSINFO
			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
 80038dc:	6121      	str	r1, [r4, #16]
#endif
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
 80038de:	ea43 6100 	orr.w	r1, r3, r0, lsl #24
 80038e2:	f894 021c 	ldrb.w	r0, [r4, #540]	; 0x21c
 80038e6:	f894 221d 	ldrb.w	r2, [r4, #541]	; 0x21d
 80038ea:	4301      	orrs	r1, r0
 80038ec:	ea41 2302 	orr.w	r3, r1, r2, lsl #8
 80038f0:	60e3      	str	r3, [r4, #12]
		}
	}
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
	fs->id = ++Fsid;	/* File system mount ID */
 80038f2:	490f      	ldr	r1, [pc, #60]	; (8003930 <find_volume+0x310>)
#endif
			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
		}
	}
#endif
	fs->fs_type = fmt;	/* FAT sub-type */
 80038f4:	7026      	strb	r6, [r4, #0]
	fs->id = ++Fsid;	/* File system mount ID */
 80038f6:	8808      	ldrh	r0, [r1, #0]
 80038f8:	1c42      	adds	r2, r0, #1
 80038fa:	b293      	uxth	r3, r2
 80038fc:	800b      	strh	r3, [r1, #0]
 80038fe:	80e3      	strh	r3, [r4, #6]
#endif
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
 8003900:	2000      	movs	r0, #0
 8003902:	e00a      	b.n	800391a <find_volume+0x2fa>


	/* Get logical drive number from the path name */
	*rfs = 0;
	vol = get_ldnumber(path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8003904:	200b      	movs	r0, #11
 8003906:	e008      	b.n	800391a <find_volume+0x2fa>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8003908:	200c      	movs	r0, #12
 800390a:	e006      	b.n	800391a <find_volume+0x2fa>
	if (fs->fs_type) {					/* If the volume has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
 800390c:	4628      	mov	r0, r5
 800390e:	e004      	b.n	800391a <find_volume+0x2fa>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8003910:	2003      	movs	r0, #3
 8003912:	e002      	b.n	800391a <find_volume+0x2fa>
	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
		return FR_WRITE_PROTECTED;
 8003914:	200a      	movs	r0, #10
 8003916:	e000      	b.n	800391a <find_volume+0x2fa>
		do {								/* Find an FAT volume */
			bsect = br[i];
			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
		} while (!LD2PT(vol) && fmt && ++i < 4);
	}
	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8003918:	2001      	movs	r0, #1
#if _FS_LOCK			/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
}
 800391a:	b004      	add	sp, #16
 800391c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003920:	20001114 	.word	0x20001114
 8003924:	ffffaa55 	.word	0xffffaa55
 8003928:	41615252 	.word	0x41615252
 800392c:	61417272 	.word	0x61417272
 8003930:	20001110 	.word	0x20001110

08003934 <clust2sect>:
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003934:	6943      	ldr	r3, [r0, #20]
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
 8003936:	3902      	subs	r1, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003938:	1e9a      	subs	r2, r3, #2
 800393a:	4291      	cmp	r1, r2
 800393c:	d204      	bcs.n	8003948 <clust2sect+0x14>
	return clst * fs->csize + fs->database;
 800393e:	7882      	ldrb	r2, [r0, #2]
 8003940:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8003942:	fb02 0001 	mla	r0, r2, r1, r0
 8003946:	4770      	bx	lr
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 8003948:	2000      	movs	r0, #0
	return clst * fs->csize + fs->database;
}
 800394a:	4770      	bx	lr

0800394c <get_fat>:
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 800394c:	2901      	cmp	r1, #1

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS* fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
 800394e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003950:	4604      	mov	r4, r0
 8003952:	460d      	mov	r5, r1
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
 8003954:	d95c      	bls.n	8003a10 <get_fat+0xc4>
 8003956:	6943      	ldr	r3, [r0, #20]
 8003958:	4299      	cmp	r1, r3
 800395a:	d259      	bcs.n	8003a10 <get_fat+0xc4>
		return 1;

	switch (fs->fs_type) {
 800395c:	7801      	ldrb	r1, [r0, #0]
 800395e:	2902      	cmp	r1, #2
 8003960:	d028      	beq.n	80039b4 <get_fat+0x68>
 8003962:	2903      	cmp	r1, #3
 8003964:	d037      	beq.n	80039d6 <get_fat+0x8a>
 8003966:	2901      	cmp	r1, #1
 8003968:	d14f      	bne.n	8003a0a <get_fat+0xbe>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800396a:	6a02      	ldr	r2, [r0, #32]
	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
 800396c:	eb05 0655 	add.w	r6, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003970:	eb02 2156 	add.w	r1, r2, r6, lsr #9
 8003974:	f7ff fdf8 	bl	8003568 <move_window>
 8003978:	2800      	cmp	r0, #0
 800397a:	d146      	bne.n	8003a0a <get_fat+0xbe>
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 800397c:	6a23      	ldr	r3, [r4, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 800397e:	05f0      	lsls	r0, r6, #23
 8003980:	3601      	adds	r6, #1
 8003982:	eb04 57d0 	add.w	r7, r4, r0, lsr #23
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003986:	eb03 2156 	add.w	r1, r3, r6, lsr #9
 800398a:	4620      	mov	r0, r4

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 800398c:	f897 7030 	ldrb.w	r7, [r7, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 8003990:	f7ff fdea 	bl	8003568 <move_window>
 8003994:	2800      	cmp	r0, #0
 8003996:	d138      	bne.n	8003a0a <get_fat+0xbe>
		wc |= fs->win[bc % SS(fs)] << 8;
 8003998:	05f6      	lsls	r6, r6, #23
 800399a:	eb04 54d6 	add.w	r4, r4, r6, lsr #23
 800399e:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
 80039a2:	07eb      	lsls	r3, r5, #31
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
 80039a4:	ea47 2201 	orr.w	r2, r7, r1, lsl #8
		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
 80039a8:	d501      	bpl.n	80039ae <get_fat+0x62>
 80039aa:	0910      	lsrs	r0, r2, #4
 80039ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80039ae:	0510      	lsls	r0, r2, #20
 80039b0:	0d00      	lsrs	r0, r0, #20
 80039b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 80039b4:	6a02      	ldr	r2, [r0, #32]
 80039b6:	eb02 2115 	add.w	r1, r2, r5, lsr #8
 80039ba:	f7ff fdd5 	bl	8003568 <move_window>
 80039be:	bb20      	cbnz	r0, 8003a0a <get_fat+0xbe>
		p = &fs->win[clst * 2 % SS(fs)];
 80039c0:	062d      	lsls	r5, r5, #24
 80039c2:	0ded      	lsrs	r5, r5, #23
		return LD_WORD(p);
 80039c4:	1963      	adds	r3, r4, r5
 80039c6:	1964      	adds	r4, r4, r5
 80039c8:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 80039cc:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
 80039d0:	ea41 2000 	orr.w	r0, r1, r0, lsl #8
 80039d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 80039d6:	6a03      	ldr	r3, [r0, #32]
 80039d8:	eb03 11d5 	add.w	r1, r3, r5, lsr #7
 80039dc:	f7ff fdc4 	bl	8003568 <move_window>
 80039e0:	b998      	cbnz	r0, 8003a0a <get_fat+0xbe>
		p = &fs->win[clst * 4 % SS(fs)];
 80039e2:	066d      	lsls	r5, r5, #25
 80039e4:	0ded      	lsrs	r5, r5, #23
 80039e6:	f105 0130 	add.w	r1, r5, #48	; 0x30
 80039ea:	1863      	adds	r3, r4, r1
		return LD_DWORD(p) & 0x0FFFFFFF;
 80039ec:	78d8      	ldrb	r0, [r3, #3]
 80039ee:	789a      	ldrb	r2, [r3, #2]
 80039f0:	0601      	lsls	r1, r0, #24
 80039f2:	785b      	ldrb	r3, [r3, #1]
 80039f4:	1964      	adds	r4, r4, r5
 80039f6:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 80039fa:	f894 1030 	ldrb.w	r1, [r4, #48]	; 0x30
 80039fe:	ea42 2003 	orr.w	r0, r2, r3, lsl #8
 8003a02:	4308      	orrs	r0, r1
 8003a04:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8003a08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
 8003a0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003a0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
 8003a10:	2001      	movs	r0, #1
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
 8003a12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003a14 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR* dp,		/* Pointer to directory object */
	WORD idx		/* Index of directory table */
)
{
 8003a14:	b570      	push	{r4, r5, r6, lr}
 8003a16:	4604      	mov	r4, r0
 8003a18:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dp->index = idx;
 8003a1a:	80e1      	strh	r1, [r4, #6]
	clst = dp->sclust;
 8003a1c:	6881      	ldr	r1, [r0, #8]
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8003a1e:	2901      	cmp	r1, #1
 8003a20:	d101      	bne.n	8003a26 <dir_sdi+0x12>
		return FR_INT_ERR;
 8003a22:	2002      	movs	r0, #2
 8003a24:	bd70      	pop	{r4, r5, r6, pc}
	WORD ic;


	dp->index = idx;
	clst = dp->sclust;
	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
 8003a26:	6803      	ldr	r3, [r0, #0]
 8003a28:	695a      	ldr	r2, [r3, #20]
 8003a2a:	4291      	cmp	r1, r2
 8003a2c:	d2f9      	bcs.n	8003a22 <dir_sdi+0xe>
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 8003a2e:	b971      	cbnz	r1, 8003a4e <dir_sdi+0x3a>
 8003a30:	7818      	ldrb	r0, [r3, #0]
 8003a32:	2803      	cmp	r0, #3
 8003a34:	d101      	bne.n	8003a3a <dir_sdi+0x26>
		clst = dp->fs->dirbase;
 8003a36:	6a59      	ldr	r1, [r3, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8003a38:	b949      	cbnz	r1, 8003a4e <dir_sdi+0x3a>
		dp->clust = clst;
		if (idx >= dp->fs->n_rootdir)		/* Index is out of range */
 8003a3a:	8919      	ldrh	r1, [r3, #8]
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dp->fs->dirbase;

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		dp->clust = clst;
 8003a3c:	2000      	movs	r0, #0
		if (idx >= dp->fs->n_rootdir)		/* Index is out of range */
 8003a3e:	42a9      	cmp	r1, r5
		return FR_INT_ERR;
	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dp->fs->dirbase;

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
		dp->clust = clst;
 8003a40:	60e0      	str	r0, [r4, #12]
		if (idx >= dp->fs->n_rootdir)		/* Index is out of range */
 8003a42:	d9ee      	bls.n	8003a22 <dir_sdi+0xe>
			return FR_INT_ERR;
		dp->sect = dp->fs->dirbase + idx / (SS(dp->fs) / SZ_DIR);	/* Sector# */
 8003a44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003a46:	eb03 1215 	add.w	r2, r3, r5, lsr #4
 8003a4a:	6122      	str	r2, [r4, #16]
 8003a4c:	e019      	b.n	8003a82 <dir_sdi+0x6e>
	}
	else {				/* Dynamic table (sub-dirs or root-directory in FAT32) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
 8003a4e:	789e      	ldrb	r6, [r3, #2]
 8003a50:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
 8003a52:	42b5      	cmp	r5, r6
 8003a54:	d30e      	bcc.n	8003a74 <dir_sdi+0x60>
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8003a56:	6820      	ldr	r0, [r4, #0]
 8003a58:	f7ff ff78 	bl	800394c <get_fat>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003a5c:	1c42      	adds	r2, r0, #1
		dp->sect = dp->fs->dirbase + idx / (SS(dp->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-directory in FAT32) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
 8003a5e:	4601      	mov	r1, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003a60:	d018      	beq.n	8003a94 <dir_sdi+0x80>
			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or int error */
 8003a62:	2801      	cmp	r0, #1
 8003a64:	d9dd      	bls.n	8003a22 <dir_sdi+0xe>
 8003a66:	6823      	ldr	r3, [r4, #0]
 8003a68:	695a      	ldr	r2, [r3, #20]
 8003a6a:	4290      	cmp	r0, r2
 8003a6c:	d2d9      	bcs.n	8003a22 <dir_sdi+0xe>
				return FR_INT_ERR;
			idx -= ic;
 8003a6e:	1bad      	subs	r5, r5, r6
 8003a70:	b2ad      	uxth	r5, r5
 8003a72:	e7ee      	b.n	8003a52 <dir_sdi+0x3e>
		}
		dp->clust = clst;
 8003a74:	60e1      	str	r1, [r4, #12]
		dp->sect = clust2sect(dp->fs, clst) + idx / (SS(dp->fs) / SZ_DIR);	/* Sector# */
 8003a76:	6820      	ldr	r0, [r4, #0]
 8003a78:	f7ff ff5c 	bl	8003934 <clust2sect>
 8003a7c:	eb00 1115 	add.w	r1, r0, r5, lsr #4
 8003a80:	6121      	str	r1, [r4, #16]
	}

	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 8003a82:	f005 050f 	and.w	r5, r5, #15
 8003a86:	6820      	ldr	r0, [r4, #0]
 8003a88:	016d      	lsls	r5, r5, #5
 8003a8a:	3530      	adds	r5, #48	; 0x30
 8003a8c:	1941      	adds	r1, r0, r5
 8003a8e:	6161      	str	r1, [r4, #20]

	return FR_OK;	/* Seek succeeded */
 8003a90:	2000      	movs	r0, #0
 8003a92:	bd70      	pop	{r4, r5, r6, pc}
	}
	else {				/* Dynamic table (sub-dirs or root-directory in FAT32) */
		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dp->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8003a94:	2001      	movs	r0, #1
	}

	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
 8003a96:	bd70      	pop	{r4, r5, r6, pc}

08003a98 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR* dp				/* Directory object pointing the entry to be removed */
)
{
 8003a98:	b510      	push	{r4, lr}
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dp, dp->index);
 8003a9a:	88c1      	ldrh	r1, [r0, #6]
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
	DIR* dp				/* Directory object pointing the entry to be removed */
)
{
 8003a9c:	4604      	mov	r4, r0
		} while (res == FR_OK);
		if (res == FR_NO_FILE) res = FR_INT_ERR;
	}

#else			/* Non LFN configuration */
	res = dir_sdi(dp, dp->index);
 8003a9e:	f7ff ffb9 	bl	8003a14 <dir_sdi>
	if (res == FR_OK) {
 8003aa2:	b950      	cbnz	r0, 8003aba <dir_remove+0x22>
		res = move_window(dp->fs, dp->sect);
 8003aa4:	6820      	ldr	r0, [r4, #0]
 8003aa6:	6921      	ldr	r1, [r4, #16]
 8003aa8:	f7ff fd5e 	bl	8003568 <move_window>
		if (res == FR_OK) {
 8003aac:	b928      	cbnz	r0, 8003aba <dir_remove+0x22>
			*dp->dir = DDE;			/* Mark the entry "deleted" */
 8003aae:	6963      	ldr	r3, [r4, #20]
 8003ab0:	22e5      	movs	r2, #229	; 0xe5
 8003ab2:	701a      	strb	r2, [r3, #0]
			dp->fs->wflag = 1;
 8003ab4:	6821      	ldr	r1, [r4, #0]
 8003ab6:	2301      	movs	r3, #1
 8003ab8:	710b      	strb	r3, [r1, #4]
		}
	}
#endif

	return res;
}
 8003aba:	bd10      	pop	{r4, pc}

08003abc <put_fat>:
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003abc:	2901      	cmp	r1, #1
FRESULT put_fat (
	FATFS* fs,	/* File system object */
	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
	DWORD val	/* New value to mark the cluster */
)
{
 8003abe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ac0:	4604      	mov	r4, r0
 8003ac2:	460d      	mov	r5, r1
 8003ac4:	4616      	mov	r6, r2
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003ac6:	d970      	bls.n	8003baa <put_fat+0xee>
 8003ac8:	6943      	ldr	r3, [r0, #20]
 8003aca:	4299      	cmp	r1, r3
 8003acc:	d26d      	bcs.n	8003baa <put_fat+0xee>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
 8003ace:	7801      	ldrb	r1, [r0, #0]
 8003ad0:	2902      	cmp	r1, #2
 8003ad2:	d03a      	beq.n	8003b4a <put_fat+0x8e>
 8003ad4:	2903      	cmp	r1, #3
 8003ad6:	d049      	beq.n	8003b6c <put_fat+0xb0>
 8003ad8:	2901      	cmp	r1, #1
 8003ada:	d162      	bne.n	8003ba2 <put_fat+0xe6>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003adc:	6a02      	ldr	r2, [r0, #32]
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8003ade:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003ae2:	eb02 2157 	add.w	r1, r2, r7, lsr #9
 8003ae6:	f7ff fd3f 	bl	8003568 <move_window>
			if (res != FR_OK) break;
 8003aea:	2800      	cmp	r0, #0
 8003aec:	d15a      	bne.n	8003ba4 <put_fat+0xe8>
			p = &fs->win[bc % SS(fs)];
 8003aee:	05f8      	lsls	r0, r7, #23
 8003af0:	0dc2      	lsrs	r2, r0, #23
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8003af2:	f015 0501 	ands.w	r5, r5, #1
 8003af6:	b2f3      	uxtb	r3, r6
 8003af8:	d007      	beq.n	8003b0a <put_fat+0x4e>
 8003afa:	18a1      	adds	r1, r4, r2
 8003afc:	f891 0030 	ldrb.w	r0, [r1, #48]	; 0x30
 8003b00:	f000 010f 	and.w	r1, r0, #15
 8003b04:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
 8003b08:	b2db      	uxtb	r3, r3
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003b0a:	6a21      	ldr	r1, [r4, #32]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
 8003b0c:	2001      	movs	r0, #1
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8003b0e:	18a2      	adds	r2, r4, r2
			bc++;
 8003b10:	3701      	adds	r7, #1
			fs->wflag = 1;
 8003b12:	7120      	strb	r0, [r4, #4]
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8003b14:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8003b18:	4620      	mov	r0, r4
 8003b1a:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8003b1e:	f7ff fd23 	bl	8003568 <move_window>
			if (res != FR_OK) break;
 8003b22:	2800      	cmp	r0, #0
 8003b24:	d13e      	bne.n	8003ba4 <put_fat+0xe8>
			p = &fs->win[bc % SS(fs)];
 8003b26:	05ff      	lsls	r7, r7, #23
 8003b28:	0dfa      	lsrs	r2, r7, #23
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8003b2a:	b115      	cbz	r5, 8003b32 <put_fat+0x76>
 8003b2c:	f3c6 1607 	ubfx	r6, r6, #4, #8
 8003b30:	e007      	b.n	8003b42 <put_fat+0x86>
 8003b32:	18a3      	adds	r3, r4, r2
 8003b34:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 8003b38:	f3c6 2603 	ubfx	r6, r6, #8, #4
 8003b3c:	f021 070f 	bic.w	r7, r1, #15
 8003b40:	433e      	orrs	r6, r7
 8003b42:	18a7      	adds	r7, r4, r2
 8003b44:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
 8003b48:	e02c      	b.n	8003ba4 <put_fat+0xe8>
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8003b4a:	6a03      	ldr	r3, [r0, #32]
 8003b4c:	eb03 2115 	add.w	r1, r3, r5, lsr #8
 8003b50:	f7ff fd0a 	bl	8003568 <move_window>
			if (res != FR_OK) break;
 8003b54:	bb30      	cbnz	r0, 8003ba4 <put_fat+0xe8>
			p = &fs->win[clst * 2 % SS(fs)];
 8003b56:	062d      	lsls	r5, r5, #24
 8003b58:	0dea      	lsrs	r2, r5, #23
			ST_WORD(p, (WORD)val);
 8003b5a:	18a1      	adds	r1, r4, r2
 8003b5c:	f881 6030 	strb.w	r6, [r1, #48]	; 0x30
 8003b60:	f3c6 2607 	ubfx	r6, r6, #8, #8
 8003b64:	460d      	mov	r5, r1
 8003b66:	f881 6031 	strb.w	r6, [r1, #49]	; 0x31
 8003b6a:	e01b      	b.n	8003ba4 <put_fat+0xe8>
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8003b6c:	6a02      	ldr	r2, [r0, #32]
 8003b6e:	eb02 11d5 	add.w	r1, r2, r5, lsr #7
 8003b72:	f7ff fcf9 	bl	8003568 <move_window>
			if (res != FR_OK) break;
 8003b76:	b9a8      	cbnz	r0, 8003ba4 <put_fat+0xe8>
			p = &fs->win[clst * 4 % SS(fs)];
 8003b78:	066d      	lsls	r5, r5, #25
 8003b7a:	0de9      	lsrs	r1, r5, #23
 8003b7c:	f101 0330 	add.w	r3, r1, #48	; 0x30
 8003b80:	18e3      	adds	r3, r4, r3
			val |= LD_DWORD(p) & 0xF0000000;
 8003b82:	78da      	ldrb	r2, [r3, #3]
 8003b84:	1865      	adds	r5, r4, r1
 8003b86:	0612      	lsls	r2, r2, #24
 8003b88:	f002 4170 	and.w	r1, r2, #4026531840	; 0xf0000000
 8003b8c:	430e      	orrs	r6, r1
			ST_DWORD(p, val);
 8003b8e:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
 8003b92:	f3c6 2207 	ubfx	r2, r6, #8, #8
 8003b96:	0c31      	lsrs	r1, r6, #16
 8003b98:	0e36      	lsrs	r6, r6, #24
 8003b9a:	705a      	strb	r2, [r3, #1]
 8003b9c:	7099      	strb	r1, [r3, #2]
 8003b9e:	70de      	strb	r6, [r3, #3]
 8003ba0:	e000      	b.n	8003ba4 <put_fat+0xe8>
			break;

		default :
			res = FR_INT_ERR;
 8003ba2:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
 8003ba4:	2301      	movs	r3, #1
 8003ba6:	7123      	strb	r3, [r4, #4]
 8003ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
 8003baa:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
	}

	return res;
}
 8003bac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003bae <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
 8003bae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003bb0:	4604      	mov	r4, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
 8003bb2:	460f      	mov	r7, r1
 8003bb4:	b931      	cbnz	r1, 8003bc4 <create_chain+0x16>
		scl = fs->last_clust;			/* Get suggested start point */
 8003bb6:	68c6      	ldr	r6, [r0, #12]
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8003bb8:	b16e      	cbz	r6, 8003bd6 <create_chain+0x28>
 8003bba:	6940      	ldr	r0, [r0, #20]
 8003bbc:	4286      	cmp	r6, r0
 8003bbe:	bf28      	it	cs
 8003bc0:	2601      	movcs	r6, #1
 8003bc2:	e009      	b.n	8003bd8 <create_chain+0x2a>
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
 8003bc4:	f7ff fec2 	bl	800394c <get_fat>
		if (cs < 2) return 1;			/* It is an invalid cluster */
 8003bc8:	2801      	cmp	r0, #1
 8003bca:	d93d      	bls.n	8003c48 <create_chain+0x9a>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8003bcc:	6963      	ldr	r3, [r4, #20]
 8003bce:	4298      	cmp	r0, r3
 8003bd0:	d33b      	bcc.n	8003c4a <create_chain+0x9c>
 8003bd2:	463e      	mov	r6, r7
 8003bd4:	e000      	b.n	8003bd8 <create_chain+0x2a>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
 8003bd6:	2601      	movs	r6, #1
 8003bd8:	4635      	mov	r5, r6
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
 8003bda:	6961      	ldr	r1, [r4, #20]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
 8003bdc:	3501      	adds	r5, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
 8003bde:	428d      	cmp	r5, r1
 8003be0:	d304      	bcc.n	8003bec <create_chain+0x3e>
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
 8003be2:	2e01      	cmp	r6, #1
 8003be4:	d801      	bhi.n	8003bea <create_chain+0x3c>
 8003be6:	2000      	movs	r0, #0
 8003be8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
 8003bea:	2502      	movs	r5, #2
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
 8003bec:	4620      	mov	r0, r4
 8003bee:	4629      	mov	r1, r5
 8003bf0:	f7ff feac 	bl	800394c <get_fat>
		if (cs == 0) break;				/* Found a free cluster */
 8003bf4:	b148      	cbz	r0, 8003c0a <create_chain+0x5c>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8003bf6:	1c43      	adds	r3, r0, #1
 8003bf8:	d102      	bne.n	8003c00 <create_chain+0x52>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8003bfa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003bfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
 8003c00:	2801      	cmp	r0, #1
 8003c02:	d021      	beq.n	8003c48 <create_chain+0x9a>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
 8003c04:	42b5      	cmp	r5, r6
 8003c06:	d1e8      	bne.n	8003bda <create_chain+0x2c>
 8003c08:	e7ed      	b.n	8003be6 <create_chain+0x38>
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
 8003c0a:	4620      	mov	r0, r4
 8003c0c:	4629      	mov	r1, r5
 8003c0e:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8003c12:	f7ff ff53 	bl	8003abc <put_fat>
	if (res == FR_OK && clst != 0) {
 8003c16:	b9a8      	cbnz	r0, 8003c44 <create_chain+0x96>
 8003c18:	b957      	cbnz	r7, 8003c30 <create_chain+0x82>
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
 8003c1a:	6922      	ldr	r2, [r4, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
 8003c1c:	60e5      	str	r5, [r4, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
 8003c1e:	1c51      	adds	r1, r2, #1
 8003c20:	d00e      	beq.n	8003c40 <create_chain+0x92>
			fs->free_clust--;
			fs->fsi_flag |= 1;
 8003c22:	7960      	ldrb	r0, [r4, #5]
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
 8003c24:	1e53      	subs	r3, r2, #1
			fs->fsi_flag |= 1;
 8003c26:	f040 0101 	orr.w	r1, r0, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
 8003c2a:	6123      	str	r3, [r4, #16]
			fs->fsi_flag |= 1;
 8003c2c:	7161      	strb	r1, [r4, #5]
 8003c2e:	e007      	b.n	8003c40 <create_chain+0x92>
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
 8003c30:	4620      	mov	r0, r4
 8003c32:	4639      	mov	r1, r7
 8003c34:	462a      	mov	r2, r5
 8003c36:	f7ff ff41 	bl	8003abc <put_fat>
	}
	if (res == FR_OK) {
 8003c3a:	2800      	cmp	r0, #0
 8003c3c:	d0ed      	beq.n	8003c1a <create_chain+0x6c>
 8003c3e:	e001      	b.n	8003c44 <create_chain+0x96>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag |= 1;
 8003c40:	4628      	mov	r0, r5
 8003c42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 8003c44:	2801      	cmp	r0, #1
 8003c46:	d0d8      	beq.n	8003bfa <create_chain+0x4c>
 8003c48:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
 8003c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08003c4c <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8003c4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD clst;
	WORD i;


	i = dp->index + 1;
 8003c50:	88c6      	ldrh	r6, [r0, #6]
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8003c52:	4604      	mov	r4, r0
	DWORD clst;
	WORD i;


	i = dp->index + 1;
 8003c54:	1c70      	adds	r0, r6, #1
 8003c56:	b286      	uxth	r6, r0
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8003c58:	460f      	mov	r7, r1
	DWORD clst;
	WORD i;


	i = dp->index + 1;
	if (!i || !dp->sect)	/* Report EOT when index has reached 65535 */
 8003c5a:	b916      	cbnz	r6, 8003c62 <dir_next+0x16>
		return FR_NO_FILE;
 8003c5c:	2004      	movs	r0, #4
 8003c5e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	DWORD clst;
	WORD i;


	i = dp->index + 1;
	if (!i || !dp->sect)	/* Report EOT when index has reached 65535 */
 8003c62:	6923      	ldr	r3, [r4, #16]
 8003c64:	2b00      	cmp	r3, #0
 8003c66:	d0f9      	beq.n	8003c5c <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
 8003c68:	f016 080f 	ands.w	r8, r6, #15
 8003c6c:	d15a      	bne.n	8003d24 <dir_next+0xd8>
		dp->sect++;					/* Next sector */
 8003c6e:	1c59      	adds	r1, r3, #1
 8003c70:	6121      	str	r1, [r4, #16]

		if (!dp->clust) {		/* Static table */
 8003c72:	68e1      	ldr	r1, [r4, #12]
 8003c74:	6820      	ldr	r0, [r4, #0]
 8003c76:	b919      	cbnz	r1, 8003c80 <dir_next+0x34>
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
 8003c78:	8902      	ldrh	r2, [r0, #8]
 8003c7a:	42b2      	cmp	r2, r6
 8003c7c:	d9ee      	bls.n	8003c5c <dir_next+0x10>
 8003c7e:	e051      	b.n	8003d24 <dir_next+0xd8>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
 8003c80:	7882      	ldrb	r2, [r0, #2]
 8003c82:	1e53      	subs	r3, r2, #1
 8003c84:	ea13 1216 	ands.w	r2, r3, r6, lsr #4
 8003c88:	d14c      	bne.n	8003d24 <dir_next+0xd8>
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 8003c8a:	f7ff fe5f 	bl	800394c <get_fat>
				if (clst <= 1) return FR_INT_ERR;
 8003c8e:	2801      	cmp	r0, #1
			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
 8003c90:	4605      	mov	r5, r0
				if (clst <= 1) return FR_INT_ERR;
 8003c92:	d802      	bhi.n	8003c9a <dir_next+0x4e>
 8003c94:	2002      	movs	r0, #2
 8003c96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8003c9a:	1c41      	adds	r1, r0, #1
 8003c9c:	d102      	bne.n	8003ca4 <dir_next+0x58>
 8003c9e:	2001      	movs	r0, #1
 8003ca0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
 8003ca4:	6820      	ldr	r0, [r4, #0]
 8003ca6:	6941      	ldr	r1, [r0, #20]
 8003ca8:	428d      	cmp	r5, r1
 8003caa:	d335      	bcc.n	8003d18 <dir_next+0xcc>
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
 8003cac:	2f00      	cmp	r7, #0
 8003cae:	d0d5      	beq.n	8003c5c <dir_next+0x10>
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
 8003cb0:	68e1      	ldr	r1, [r4, #12]
 8003cb2:	f7ff ff7c 	bl	8003bae <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8003cb6:	4605      	mov	r5, r0
 8003cb8:	2800      	cmp	r0, #0
 8003cba:	d03f      	beq.n	8003d3c <dir_next+0xf0>
					if (clst == 1) return FR_INT_ERR;
 8003cbc:	2801      	cmp	r0, #1
 8003cbe:	d0e9      	beq.n	8003c94 <dir_next+0x48>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 8003cc0:	1c42      	adds	r2, r0, #1
 8003cc2:	d0ec      	beq.n	8003c9e <dir_next+0x52>
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
 8003cc4:	6820      	ldr	r0, [r4, #0]
 8003cc6:	f7ff fbd1 	bl	800346c <sync_window>
 8003cca:	2800      	cmp	r0, #0
 8003ccc:	d1e7      	bne.n	8003c9e <dir_next+0x52>
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
 8003cce:	6822      	ldr	r2, [r4, #0]
 8003cd0:	3230      	adds	r2, #48	; 0x30
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8003cd2:	2700      	movs	r7, #0
 8003cd4:	5417      	strb	r7, [r2, r0]
 8003cd6:	3001      	adds	r0, #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003cd8:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8003cdc:	d1f9      	bne.n	8003cd2 <dir_next+0x86>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
 8003cde:	f8d4 9000 	ldr.w	r9, [r4]
 8003ce2:	4629      	mov	r1, r5
 8003ce4:	4648      	mov	r0, r9
 8003ce6:	f7ff fe25 	bl	8003934 <clust2sect>
 8003cea:	f8c9 002c 	str.w	r0, [r9, #44]	; 0x2c
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8003cee:	6820      	ldr	r0, [r4, #0]
 8003cf0:	7883      	ldrb	r3, [r0, #2]
 8003cf2:	42bb      	cmp	r3, r7
 8003cf4:	d90d      	bls.n	8003d12 <dir_next+0xc6>
						dp->fs->wflag = 1;
 8003cf6:	2201      	movs	r2, #1
 8003cf8:	7102      	strb	r2, [r0, #4]
						if (sync_window(dp->fs)) return FR_DISK_ERR;
 8003cfa:	6820      	ldr	r0, [r4, #0]
 8003cfc:	f7ff fbb6 	bl	800346c <sync_window>
 8003d00:	2800      	cmp	r0, #0
 8003d02:	d1cc      	bne.n	8003c9e <dir_next+0x52>
						dp->fs->winsect++;
 8003d04:	6820      	ldr	r0, [r4, #0]
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8003d06:	3701      	adds	r7, #1
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
 8003d08:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
 8003d0a:	b2ff      	uxtb	r7, r7
						dp->fs->wflag = 1;
						if (sync_window(dp->fs)) return FR_DISK_ERR;
						dp->fs->winsect++;
 8003d0c:	1c59      	adds	r1, r3, #1
 8003d0e:	62c1      	str	r1, [r0, #44]	; 0x2c
 8003d10:	e7ed      	b.n	8003cee <dir_next+0xa2>
					}
					dp->fs->winsect -= c;						/* Rewind window offset */
 8003d12:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8003d14:	1bcf      	subs	r7, r1, r7
 8003d16:	62c7      	str	r7, [r0, #44]	; 0x2c
#else
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					return FR_NO_FILE;							/* Report EOT */
#endif
				}
				dp->clust = clst;				/* Initialize data for new cluster */
 8003d18:	60e5      	str	r5, [r4, #12]
				dp->sect = clust2sect(dp->fs, clst);
 8003d1a:	6820      	ldr	r0, [r4, #0]
 8003d1c:	4629      	mov	r1, r5
 8003d1e:	f7ff fe09 	bl	8003934 <clust2sect>
 8003d22:	6120      	str	r0, [r4, #16]
			}
		}
	}

	dp->index = i;	/* Current index */
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
 8003d24:	6820      	ldr	r0, [r4, #0]
 8003d26:	ea4f 1848 	mov.w	r8, r8, lsl #5
 8003d2a:	f108 0830 	add.w	r8, r8, #48	; 0x30
 8003d2e:	eb00 0308 	add.w	r3, r0, r8
				dp->sect = clust2sect(dp->fs, clst);
			}
		}
	}

	dp->index = i;	/* Current index */
 8003d32:	80e6      	strh	r6, [r4, #6]
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
 8003d34:	6163      	str	r3, [r4, #20]

	return FR_OK;
 8003d36:	2000      	movs	r0, #0
 8003d38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 8003d3c:	2007      	movs	r0, #7

	dp->index = i;	/* Current index */
	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */

	return FR_OK;
}
 8003d3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08003d44 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8003d44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 8003d48:	780b      	ldrb	r3, [r1, #0]
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8003d4a:	4604      	mov	r4, r0
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 8003d4c:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8003d4e:	460e      	mov	r6, r1
		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
	} else {								/* No heading separator */
		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
	}
#else
	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
 8003d50:	d001      	beq.n	8003d56 <follow_path+0x12>
 8003d52:	2b5c      	cmp	r3, #92	; 0x5c
 8003d54:	d100      	bne.n	8003d58 <follow_path+0x14>
		path++;
 8003d56:	3601      	adds	r6, #1
	dp->sclust = 0;							/* Always start from the root directory */
 8003d58:	2500      	movs	r5, #0
 8003d5a:	60a5      	str	r5, [r4, #8]
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8003d5c:	7830      	ldrb	r0, [r6, #0]
 8003d5e:	281f      	cmp	r0, #31
 8003d60:	d853      	bhi.n	8003e0a <follow_path+0xc6>
		res = dir_sdi(dp, 0);
 8003d62:	4620      	mov	r0, r4
 8003d64:	4629      	mov	r1, r5
 8003d66:	f7ff fe55 	bl	8003a14 <dir_sdi>
		dp->dir = 0;
 8003d6a:	6165      	str	r5, [r4, #20]
 8003d6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8003d70:	295c      	cmp	r1, #92	; 0x5c
 8003d72:	d04a      	beq.n	8003e0a <follow_path+0xc6>
	sfn = dp->fn;
 8003d74:	69a5      	ldr	r5, [r4, #24]
 8003d76:	2600      	movs	r6, #0
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8003d78:	2220      	movs	r2, #32
 8003d7a:	55aa      	strb	r2, [r5, r6]
 8003d7c:	3601      	adds	r6, #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003d7e:	2e0b      	cmp	r6, #11
 8003d80:	d1fa      	bne.n	8003d78 <follow_path+0x34>
 8003d82:	2200      	movs	r2, #0
 8003d84:	4694      	mov	ip, r2
 8003d86:	2108      	movs	r1, #8
 8003d88:	4610      	mov	r0, r2
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 8003d8a:	f817 300c 	ldrb.w	r3, [r7, ip]
 8003d8e:	f10c 0601 	add.w	r6, ip, #1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8003d92:	2b20      	cmp	r3, #32
 8003d94:	d83f      	bhi.n	8003e16 <follow_path+0xd2>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8003d96:	19be      	adds	r6, r7, r6
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
 8003d98:	2b20      	cmp	r3, #32
 8003d9a:	bf94      	ite	ls
 8003d9c:	2304      	movls	r3, #4
 8003d9e:	2300      	movhi	r3, #0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 8003da0:	2a00      	cmp	r2, #0
 8003da2:	f000 80a3 	beq.w	8003eec <follow_path+0x1a8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */
 8003da6:	782a      	ldrb	r2, [r5, #0]
 8003da8:	2ae5      	cmp	r2, #229	; 0xe5
 8003daa:	d101      	bne.n	8003db0 <follow_path+0x6c>
 8003dac:	2205      	movs	r2, #5
 8003dae:	702a      	strb	r2, [r5, #0]

	if (ni == 8) b <<= 2;
 8003db0:	2908      	cmp	r1, #8
 8003db2:	d101      	bne.n	8003db8 <follow_path+0x74>
 8003db4:	0081      	lsls	r1, r0, #2
 8003db6:	b2c8      	uxtb	r0, r1
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 8003db8:	f000 0203 	and.w	r2, r0, #3
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 8003dbc:	f000 010c 	and.w	r1, r0, #12

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 8003dc0:	2a01      	cmp	r2, #1
 8003dc2:	bf08      	it	eq
 8003dc4:	f043 0310 	orreq.w	r3, r3, #16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 8003dc8:	2904      	cmp	r1, #4
 8003dca:	bf08      	it	eq
 8003dcc:	f043 0308 	orreq.w	r3, r3, #8

	sfn[NS] = c;		/* Store NT flag, File name is created */
 8003dd0:	72eb      	strb	r3, [r5, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8003dd2:	4620      	mov	r0, r4
 8003dd4:	2100      	movs	r1, #0
 8003dd6:	f7ff fe1d 	bl	8003a14 <dir_sdi>
	if (res != FR_OK) return res;
 8003dda:	2800      	cmp	r0, #0
 8003ddc:	d059      	beq.n	8003e92 <follow_path+0x14e>
	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NS];
 8003dde:	69a1      	ldr	r1, [r4, #24]
 8003de0:	7acb      	ldrb	r3, [r1, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 8003de2:	2800      	cmp	r0, #0
 8003de4:	d174      	bne.n	8003ed0 <follow_path+0x18c>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
					}
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8003de6:	f003 0204 	and.w	r2, r3, #4
 8003dea:	b2d1      	uxtb	r1, r2
 8003dec:	2900      	cmp	r1, #0
 8003dee:	f040 809b 	bne.w	8003f28 <follow_path+0x1e4>
			dir = dp->dir;						/* Follow the sub-directory */
 8003df2:	6961      	ldr	r1, [r4, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
 8003df4:	7ac8      	ldrb	r0, [r1, #11]
 8003df6:	f000 0310 	and.w	r3, r0, #16
 8003dfa:	b2da      	uxtb	r2, r3
 8003dfc:	2a00      	cmp	r2, #0
 8003dfe:	d072      	beq.n	8003ee6 <follow_path+0x1a2>
		}
		FREE_BUF();
	}

	LEAVE_FF(djo.fs, res);
}
 8003e00:	6825      	ldr	r5, [r4, #0]
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
			}
			dp->sclust = ld_clust(dp->fs, dir);
 8003e02:	7828      	ldrb	r0, [r5, #0]
 8003e04:	f7ff fb24 	bl	8003450 <ld_clust.isra.0>
 8003e08:	60a0      	str	r0, [r4, #8]
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 8003e0a:	7831      	ldrb	r1, [r6, #0]
 8003e0c:	4637      	mov	r7, r6
 8003e0e:	3601      	adds	r6, #1
 8003e10:	292f      	cmp	r1, #47	; 0x2f
 8003e12:	d1ad      	bne.n	8003d70 <follow_path+0x2c>
 8003e14:	e7f9      	b.n	8003e0a <follow_path+0xc6>
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 8003e16:	2b2f      	cmp	r3, #47	; 0x2f
 8003e18:	d0bd      	beq.n	8003d96 <follow_path+0x52>
 8003e1a:	2b5c      	cmp	r3, #92	; 0x5c
 8003e1c:	d0bb      	beq.n	8003d96 <follow_path+0x52>
		if (c == '.' || i >= ni) {
 8003e1e:	2b2e      	cmp	r3, #46	; 0x2e
 8003e20:	d07b      	beq.n	8003f1a <follow_path+0x1d6>
 8003e22:	428a      	cmp	r2, r1
 8003e24:	d262      	bcs.n	8003eec <follow_path+0x1a8>
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 8003e26:	f103 087f 	add.w	r8, r3, #127	; 0x7f
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended character? */
 8003e2a:	f013 0f80 	tst.w	r3, #128	; 0x80
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 8003e2e:	fa5f f888 	uxtb.w	r8, r8
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended character? */
			b |= 3;						/* Eliminate NT flag */
 8003e32:	bf18      	it	ne
 8003e34:	f040 0003 	orrne.w	r0, r0, #3
#if !_DF1S
			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 8003e38:	f1b8 0f1e 	cmp.w	r8, #30
 8003e3c:	d906      	bls.n	8003e4c <follow_path+0x108>
 8003e3e:	f103 0820 	add.w	r8, r3, #32
 8003e42:	fa5f f888 	uxtb.w	r8, r8
 8003e46:	f1b8 0f1c 	cmp.w	r8, #28
 8003e4a:	d818      	bhi.n	8003e7e <follow_path+0x13a>
			d = (BYTE)p[si++];			/* Get 2nd byte */
 8003e4c:	f817 8006 	ldrb.w	r8, [r7, r6]
 8003e50:	f10c 0602 	add.w	r6, ip, #2
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 8003e54:	f1a8 0c40 	sub.w	ip, r8, #64	; 0x40
 8003e58:	f1bc 0f3e 	cmp.w	ip, #62	; 0x3e
 8003e5c:	d904      	bls.n	8003e68 <follow_path+0x124>
 8003e5e:	f088 0c80 	eor.w	ip, r8, #128	; 0x80
 8003e62:	f1bc 0f7c 	cmp.w	ip, #124	; 0x7c
 8003e66:	d841      	bhi.n	8003eec <follow_path+0x1a8>
 8003e68:	f101 3cff 	add.w	ip, r1, #4294967295	; 0xffffffff
 8003e6c:	4562      	cmp	r2, ip
 8003e6e:	d23d      	bcs.n	8003eec <follow_path+0x1a8>
				return FR_INVALID_NAME;
			sfn[i++] = c;
 8003e70:	54ab      	strb	r3, [r5, r2]
			sfn[i++] = d;
 8003e72:	18ab      	adds	r3, r5, r2
 8003e74:	f883 8001 	strb.w	r8, [r3, #1]
 8003e78:	3202      	adds	r2, #2
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003e7a:	46b4      	mov	ip, r6
 8003e7c:	e785      	b.n	8003d8a <follow_path+0x46>
 8003e7e:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 8003f2c <follow_path+0x1e8>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 8003e82:	f818 cf01 	ldrb.w	ip, [r8, #1]!
 8003e86:	f1bc 0f00 	cmp.w	ip, #0
 8003e8a:	d032      	beq.n	8003ef2 <follow_path+0x1ae>
 8003e8c:	459c      	cmp	ip, r3
 8003e8e:	d1f8      	bne.n	8003e82 <follow_path+0x13e>
 8003e90:	e02c      	b.n	8003eec <follow_path+0x1a8>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dp->fs, dp->sect);
 8003e92:	6820      	ldr	r0, [r4, #0]
 8003e94:	6921      	ldr	r1, [r4, #16]
 8003e96:	f7ff fb67 	bl	8003568 <move_window>
		if (res != FR_OK) break;
 8003e9a:	2800      	cmp	r0, #0
 8003e9c:	d19f      	bne.n	8003dde <follow_path+0x9a>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8003e9e:	6962      	ldr	r2, [r4, #20]
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003ea0:	7813      	ldrb	r3, [r2, #0]
 8003ea2:	b19b      	cbz	r3, 8003ecc <follow_path+0x188>
				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dp->fn[NS] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
 8003ea4:	7ad1      	ldrb	r1, [r2, #11]
 8003ea6:	f001 0308 	and.w	r3, r1, #8
 8003eaa:	b2d9      	uxtb	r1, r3
 8003eac:	b949      	cbnz	r1, 8003ec2 <follow_path+0x17e>
 8003eae:	69a7      	ldr	r7, [r4, #24]
 8003eb0:	4603      	mov	r3, r0
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 8003eb2:	5cd5      	ldrb	r5, [r2, r3]
 8003eb4:	5cf9      	ldrb	r1, [r7, r3]
 8003eb6:	3301      	adds	r3, #1
 8003eb8:	428d      	cmp	r5, r1
 8003eba:	d102      	bne.n	8003ec2 <follow_path+0x17e>
 8003ebc:	2b0b      	cmp	r3, #11
 8003ebe:	d1f8      	bne.n	8003eb2 <follow_path+0x16e>
 8003ec0:	e78d      	b.n	8003dde <follow_path+0x9a>
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dp, 0);		/* Next entry */
 8003ec2:	4620      	mov	r0, r4
 8003ec4:	2100      	movs	r1, #0
 8003ec6:	f7ff fec1 	bl	8003c4c <dir_next>
 8003eca:	e786      	b.n	8003dda <follow_path+0x96>
	do {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003ecc:	2004      	movs	r0, #4
 8003ece:	e786      	b.n	8003dde <follow_path+0x9a>
			res = create_name(dp, &path);	/* Get a segment name of the path */
			if (res != FR_OK) break;
			res = dir_find(dp);				/* Find an object with the sagment name */
			ns = dp->fn[NS];
			if (res != FR_OK) {				/* Failed to find the object */
				if (res == FR_NO_FILE) {	/* Object is not found */
 8003ed0:	2804      	cmp	r0, #4
 8003ed2:	d129      	bne.n	8003f28 <follow_path+0x1e4>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						res = FR_OK;					/* Ended at the root directroy. Function completed. */
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8003ed4:	f003 0104 	and.w	r1, r3, #4
 8003ed8:	b2c8      	uxtb	r0, r1
 8003eda:	2800      	cmp	r0, #0
 8003edc:	bf14      	ite	ne
 8003ede:	2004      	movne	r0, #4
 8003ee0:	2005      	moveq	r0, #5
 8003ee2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
			dir = dp->dir;						/* Follow the sub-directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
				res = FR_NO_PATH; break;
 8003ee6:	2005      	movs	r0, #5
 8003ee8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 8003eec:	2006      	movs	r0, #6
 8003eee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
 8003ef2:	f1a3 0c41 	sub.w	ip, r3, #65	; 0x41
 8003ef6:	f1bc 0f19 	cmp.w	ip, #25
 8003efa:	d802      	bhi.n	8003f02 <follow_path+0x1be>
				b |= 2;
 8003efc:	f040 0002 	orr.w	r0, r0, #2
 8003f00:	e008      	b.n	8003f14 <follow_path+0x1d0>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
 8003f02:	f1a3 0c61 	sub.w	ip, r3, #97	; 0x61
 8003f06:	f1bc 0f19 	cmp.w	ip, #25
 8003f0a:	d803      	bhi.n	8003f14 <follow_path+0x1d0>
					b |= 1; c -= 0x20;
 8003f0c:	3b20      	subs	r3, #32
 8003f0e:	f040 0001 	orr.w	r0, r0, #1
 8003f12:	b2db      	uxtb	r3, r3
				}
			}
			sfn[i++] = c;
 8003f14:	54ab      	strb	r3, [r5, r2]
 8003f16:	3201      	adds	r2, #1
 8003f18:	e7af      	b.n	8003e7a <follow_path+0x136>
#endif
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 8003f1a:	2908      	cmp	r1, #8
 8003f1c:	d1e6      	bne.n	8003eec <follow_path+0x1a8>
			i = 8; ni = 11;
			b <<= 2; continue;
 8003f1e:	0080      	lsls	r0, r0, #2
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
 8003f20:	460a      	mov	r2, r1
			b <<= 2; continue;
 8003f22:	b2c0      	uxtb	r0, r0
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
 8003f24:	210b      	movs	r1, #11
 8003f26:	e7a8      	b.n	8003e7a <follow_path+0x136>
			dp->sclust = ld_clust(dp->fs, dir);
		}
	}

	return res;
}
 8003f28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003f2c:	08007587 	.word	0x08007587

08003f30 <dir_read.constprop.9>:
/*-----------------------------------------------------------------------*/
/* Read an object from the directory                                     */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
static
FRESULT dir_read (
 8003f30:	b510      	push	{r4, lr}
 8003f32:	4604      	mov	r4, r0
	BYTE a, c, *dir;
#if _USE_LFN
	BYTE ord = 0xFF, sum = 0xFF;
#endif

	res = FR_NO_FILE;
 8003f34:	2004      	movs	r0, #4
	while (dp->sect) {
 8003f36:	6921      	ldr	r1, [r4, #16]
 8003f38:	b1c1      	cbz	r1, 8003f6c <dir_read.constprop.9+0x3c>
		res = move_window(dp->fs, dp->sect);
 8003f3a:	6820      	ldr	r0, [r4, #0]
 8003f3c:	f7ff fb14 	bl	8003568 <move_window>
		if (res != FR_OK) break;
 8003f40:	b9a8      	cbnz	r0, 8003f6e <dir_read.constprop.9+0x3e>
		dir = dp->dir;					/* Ptr to the directory entry of current index */
 8003f42:	6962      	ldr	r2, [r4, #20]
		c = dir[DIR_Name];
 8003f44:	7813      	ldrb	r3, [r2, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003f46:	b1ab      	cbz	r3, 8003f74 <dir_read.constprop.9+0x44>
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)(a == AM_VOL) == vol)	/* Is it a valid entry? */
 8003f48:	2be5      	cmp	r3, #229	; 0xe5
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
 8003f4a:	7ad1      	ldrb	r1, [r2, #11]
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)(a == AM_VOL) == vol)	/* Is it a valid entry? */
 8003f4c:	d007      	beq.n	8003f5e <dir_read.constprop.9+0x2e>
 8003f4e:	2b2e      	cmp	r3, #46	; 0x2e
 8003f50:	d005      	beq.n	8003f5e <dir_read.constprop.9+0x2e>
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
		a = dir[DIR_Attr] & AM_MASK;
 8003f52:	f001 023f 	and.w	r2, r1, #63	; 0x3f
					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
				break;
			}
		}
#else		/* Non LFN configuration */
		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)(a == AM_VOL) == vol)	/* Is it a valid entry? */
 8003f56:	2a0f      	cmp	r2, #15
 8003f58:	d001      	beq.n	8003f5e <dir_read.constprop.9+0x2e>
 8003f5a:	2a08      	cmp	r2, #8
 8003f5c:	d10c      	bne.n	8003f78 <dir_read.constprop.9+0x48>
			break;
#endif
		res = dir_next(dp, 0);				/* Next entry */
 8003f5e:	4620      	mov	r0, r4
 8003f60:	2100      	movs	r1, #0
 8003f62:	f7ff fe73 	bl	8003c4c <dir_next>
		if (res != FR_OK) break;
 8003f66:	2800      	cmp	r0, #0
 8003f68:	d0e5      	beq.n	8003f36 <dir_read.constprop.9+0x6>
 8003f6a:	e000      	b.n	8003f6e <dir_read.constprop.9+0x3e>
	}

	if (res != FR_OK) dp->sect = 0;
 8003f6c:	b120      	cbz	r0, 8003f78 <dir_read.constprop.9+0x48>
 8003f6e:	2300      	movs	r3, #0
 8003f70:	6123      	str	r3, [r4, #16]
 8003f72:	bd10      	pop	{r4, pc}
	while (dp->sect) {
		res = move_window(dp->fs, dp->sect);
		if (res != FR_OK) break;
		dir = dp->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8003f74:	2004      	movs	r0, #4
 8003f76:	e7fa      	b.n	8003f6e <dir_read.constprop.9+0x3e>
	}

	if (res != FR_OK) dp->sect = 0;

	return res;
}
 8003f78:	bd10      	pop	{r4, pc}

08003f7a <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8003f7a:	b538      	push	{r3, r4, r5, lr}
{
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8003f7c:	2100      	movs	r1, #0
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8003f7e:	4604      	mov	r4, r0
{
	FRESULT res;
	UINT n;


	res = dir_sdi(dp, 0);
 8003f80:	f7ff fd48 	bl	8003a14 <dir_sdi>
	if (res == FR_OK) {
 8003f84:	b970      	cbnz	r0, 8003fa4 <dir_register+0x2a>
		n = 0;
		do {
			res = move_window(dp->fs, dp->sect);
 8003f86:	6820      	ldr	r0, [r4, #0]
 8003f88:	6921      	ldr	r1, [r4, #16]
 8003f8a:	f7ff faed 	bl	8003568 <move_window>
			if (res != FR_OK) break;
 8003f8e:	b948      	cbnz	r0, 8003fa4 <dir_register+0x2a>
			if (dp->dir[0] == DDE || dp->dir[0] == 0) {	/* Is it a blank entry? */
 8003f90:	6963      	ldr	r3, [r4, #20]
 8003f92:	7818      	ldrb	r0, [r3, #0]
 8003f94:	28e5      	cmp	r0, #229	; 0xe5
 8003f96:	d00a      	beq.n	8003fae <dir_register+0x34>
 8003f98:	b148      	cbz	r0, 8003fae <dir_register+0x34>
				if (++n == nent) break;	/* A block of contiguous entries is found */
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
			}
			res = dir_next(dp, 1);		/* Next entry with table stretch enabled */
 8003f9a:	4620      	mov	r0, r4
 8003f9c:	2101      	movs	r1, #1
 8003f9e:	f7ff fe55 	bl	8003c4c <dir_next>
 8003fa2:	e7ef      	b.n	8003f84 <dir_register+0xa>
		} while (res == FR_OK);
	}
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 8003fa4:	2804      	cmp	r0, #4
 8003fa6:	bf14      	ite	ne
 8003fa8:	4605      	movne	r5, r0
 8003faa:	2507      	moveq	r5, #7
 8003fac:	e014      	b.n	8003fd8 <dir_register+0x5e>
#else	/* Non LFN configuration */
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
#endif

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
 8003fae:	6820      	ldr	r0, [r4, #0]
 8003fb0:	6921      	ldr	r1, [r4, #16]
 8003fb2:	f7ff fad9 	bl	8003568 <move_window>
		if (res == FR_OK) {
 8003fb6:	4605      	mov	r5, r0
 8003fb8:	b970      	cbnz	r0, 8003fd8 <dir_register+0x5e>
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
 8003fba:	6962      	ldr	r2, [r4, #20]
 8003fbc:	462b      	mov	r3, r5
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
 8003fbe:	2100      	movs	r1, #0
 8003fc0:	54d1      	strb	r1, [r2, r3]
 8003fc2:	3301      	adds	r3, #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 8003fc4:	2b20      	cmp	r3, #32
 8003fc6:	d1fa      	bne.n	8003fbe <dir_register+0x44>

	if (res == FR_OK) {				/* Set SFN entry */
		res = move_window(dp->fs, dp->sect);
		if (res == FR_OK) {
			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
 8003fc8:	6960      	ldr	r0, [r4, #20]
 8003fca:	220b      	movs	r2, #11
 8003fcc:	69a1      	ldr	r1, [r4, #24]
 8003fce:	f7ff f9dd 	bl	800338c <mem_cpy>
#if _USE_LFN
			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
#endif
			dp->fs->wflag = 1;
 8003fd2:	6820      	ldr	r0, [r4, #0]
 8003fd4:	2201      	movs	r2, #1
 8003fd6:	7102      	strb	r2, [r0, #4]
		}
	}

	return res;
}
 8003fd8:	4628      	mov	r0, r5
 8003fda:	bd38      	pop	{r3, r4, r5, pc}

08003fdc <remove_chain>:
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003fdc:	2901      	cmp	r1, #1
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8003fde:	b570      	push	{r4, r5, r6, lr}
 8003fe0:	4604      	mov	r4, r0
 8003fe2:	460d      	mov	r5, r1
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
 8003fe4:	d924      	bls.n	8004030 <remove_chain+0x54>
 8003fe6:	6943      	ldr	r3, [r0, #20]
 8003fe8:	4299      	cmp	r1, r3
 8003fea:	d221      	bcs.n	8004030 <remove_chain+0x54>
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
 8003fec:	6960      	ldr	r0, [r4, #20]
 8003fee:	4285      	cmp	r5, r0
 8003ff0:	d205      	bcs.n	8003ffe <remove_chain+0x22>
			nxt = get_fat(fs, clst);			/* Get cluster status */
 8003ff2:	4620      	mov	r0, r4
 8003ff4:	4629      	mov	r1, r5
 8003ff6:	f7ff fca9 	bl	800394c <get_fat>
			if (nxt == 0) break;				/* Empty cluster? */
 8003ffa:	4606      	mov	r6, r0
 8003ffc:	b908      	cbnz	r0, 8004002 <remove_chain+0x26>
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8003ffe:	2000      	movs	r0, #0
 8004000:	bd70      	pop	{r4, r5, r6, pc}
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
 8004002:	2801      	cmp	r0, #1
 8004004:	d014      	beq.n	8004030 <remove_chain+0x54>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 8004006:	1c41      	adds	r1, r0, #1
 8004008:	d010      	beq.n	800402c <remove_chain+0x50>
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
 800400a:	4620      	mov	r0, r4
 800400c:	4629      	mov	r1, r5
 800400e:	2200      	movs	r2, #0
 8004010:	f7ff fd54 	bl	8003abc <put_fat>
			if (res != FR_OK) break;
 8004014:	b968      	cbnz	r0, 8004032 <remove_chain+0x56>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
 8004016:	6921      	ldr	r1, [r4, #16]
 8004018:	1c4a      	adds	r2, r1, #1
 800401a:	d005      	beq.n	8004028 <remove_chain+0x4c>
				fs->free_clust++;
				fs->fsi_flag |= 1;
 800401c:	7965      	ldrb	r5, [r4, #5]
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
				fs->free_clust++;
 800401e:	1c4a      	adds	r2, r1, #1
				fs->fsi_flag |= 1;
 8004020:	f045 0301 	orr.w	r3, r5, #1
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
				fs->free_clust++;
 8004024:	6122      	str	r2, [r4, #16]
				fs->fsi_flag |= 1;
 8004026:	7163      	strb	r3, [r4, #5]
static
FRESULT remove_chain (
	FATFS* fs,			/* File system object */
	DWORD clst			/* Cluster# to remove a chain from */
)
{
 8004028:	4635      	mov	r5, r6
 800402a:	e7df      	b.n	8003fec <remove_chain+0x10>
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
 800402c:	2001      	movs	r0, #1
 800402e:	bd70      	pop	{r4, r5, r6, pc}
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;
 8004030:	2002      	movs	r0, #2
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
 8004032:	bd70      	pop	{r4, r5, r6, pc}

08004034 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8004034:	b513      	push	{r0, r1, r4, lr}
 8004036:	9001      	str	r0, [sp, #4]
 8004038:	a802      	add	r0, sp, #8
 800403a:	f840 1d08 	str.w	r1, [r0, #-8]!
	FATFS *cfs;
	int vol;
	FRESULT res;


	vol = get_ldnumber(&path);
 800403e:	4668      	mov	r0, sp
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8004040:	4614      	mov	r4, r2
	FATFS *cfs;
	int vol;
	FRESULT res;


	vol = get_ldnumber(&path);
 8004042:	f7ff f9dd 	bl	8003400 <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8004046:	1e03      	subs	r3, r0, #0
 8004048:	db14      	blt.n	8004074 <f_mount+0x40>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800404a:	4a0c      	ldr	r2, [pc, #48]	; (800407c <f_mount+0x48>)
 800404c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]

	if (cfs) {
 8004050:	b109      	cbz	r1, 8004056 <f_mount+0x22>
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 8004052:	2000      	movs	r0, #0
 8004054:	7008      	strb	r0, [r1, #0]
	}

	if (fs) {
 8004056:	9801      	ldr	r0, [sp, #4]
 8004058:	b108      	cbz	r0, 800405e <f_mount+0x2a>
		fs->fs_type = 0;				/* Clear new fs object */
 800405a:	2100      	movs	r1, #0
 800405c:	7001      	strb	r1, [r0, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 800405e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8004062:	b150      	cbz	r0, 800407a <f_mount+0x46>
 8004064:	2c01      	cmp	r4, #1
 8004066:	d107      	bne.n	8004078 <f_mount+0x44>

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
 8004068:	a801      	add	r0, sp, #4
 800406a:	4669      	mov	r1, sp
 800406c:	2200      	movs	r2, #0
 800406e:	f7ff fad7 	bl	8003620 <find_volume>
	LEAVE_FF(fs, res);
 8004072:	e002      	b.n	800407a <f_mount+0x46>
	int vol;
	FRESULT res;


	vol = get_ldnumber(&path);
	if (vol < 0) return FR_INVALID_DRIVE;
 8004074:	200b      	movs	r0, #11
 8004076:	e000      	b.n	800407a <f_mount+0x46>
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8004078:	2000      	movs	r0, #0

	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
	LEAVE_FF(fs, res);
}
 800407a:	bd1c      	pop	{r2, r3, r4, pc}
 800407c:	20001114 	.word	0x20001114

08004080 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8004080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004084:	b08c      	sub	sp, #48	; 0x30
 8004086:	9101      	str	r1, [sp, #4]
 8004088:	4616      	mov	r6, r2
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
 800408a:	4605      	mov	r5, r0
 800408c:	2800      	cmp	r0, #0
 800408e:	f000 8097 	beq.w	80041c0 <f_open+0x140>
	fp->fs = 0;			/* Clear file object */
 8004092:	2300      	movs	r3, #0
 8004094:	6003      	str	r3, [r0, #0]

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
 8004096:	a901      	add	r1, sp, #4
 8004098:	a805      	add	r0, sp, #20
 800409a:	f002 021e 	and.w	r2, r2, #30
 800409e:	f7ff fabf 	bl	8003620 <find_volume>
#else
	mode &= FA_READ;
	res = find_volume(&dj.fs, &path, 0);
#endif
	if (res == FR_OK) {
 80040a2:	4680      	mov	r8, r0
 80040a4:	2800      	cmp	r0, #0
 80040a6:	f040 8094 	bne.w	80041d2 <f_open+0x152>
		INIT_BUF(dj);
 80040aa:	a802      	add	r0, sp, #8
 80040ac:	900b      	str	r0, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
 80040ae:	9901      	ldr	r1, [sp, #4]
 80040b0:	a805      	add	r0, sp, #20
 80040b2:	f7ff fe47 	bl	8003d44 <follow_path>
		dir = dj.dir;
 80040b6:	9c0a      	ldr	r4, [sp, #40]	; 0x28
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 80040b8:	b918      	cbnz	r0, 80040c2 <f_open+0x42>
			if (!dir)	/* Default directory itself */
				res = FR_INVALID_NAME;
 80040ba:	2c00      	cmp	r4, #0
 80040bc:	bf0c      	ite	eq
 80040be:	2006      	moveq	r0, #6
 80040c0:	2000      	movne	r0, #0
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80040c2:	f016 0f1c 	tst.w	r6, #28
	if (!fp) return FR_INVALID_OBJECT;
	fp->fs = 0;			/* Clear file object */

	/* Get logical drive number */
#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
 80040c6:	f006 071f 	and.w	r7, r6, #31
			else
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80040ca:	d048      	beq.n	800415e <f_open+0xde>
			DWORD dw, cl;

			if (res != FR_OK) {					/* No file, create new */
 80040cc:	b148      	cbz	r0, 80040e2 <f_open+0x62>
				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
 80040ce:	2804      	cmp	r0, #4
 80040d0:	d102      	bne.n	80040d8 <f_open+0x58>
#if _FS_LOCK
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
					res = dir_register(&dj);
 80040d2:	a805      	add	r0, sp, #20
 80040d4:	f7ff ff51 	bl	8003f7a <dir_register>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80040d8:	f047 0708 	orr.w	r7, r7, #8
				dir = dj.dir;					/* New entry */
 80040dc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80040de:	b148      	cbz	r0, 80040f4 <f_open+0x74>
 80040e0:	e076      	b.n	80041d0 <f_open+0x150>
#endif
				mode |= FA_CREATE_ALWAYS;		/* File is created */
				dir = dj.dir;					/* New entry */
			}
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 80040e2:	7ae0      	ldrb	r0, [r4, #11]
 80040e4:	f010 0f11 	tst.w	r0, #17
 80040e8:	d171      	bne.n	80041ce <f_open+0x14e>
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
 80040ea:	f006 0104 	and.w	r1, r6, #4
 80040ee:	b2ce      	uxtb	r6, r1
 80040f0:	2e00      	cmp	r6, #0
 80040f2:	d168      	bne.n	80041c6 <f_open+0x146>
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80040f4:	f007 0208 	and.w	r2, r7, #8
 80040f8:	b2d3      	uxtb	r3, r2
 80040fa:	2b00      	cmp	r3, #0
 80040fc:	d03d      	beq.n	800417a <f_open+0xfa>
				dw = get_fattime();				/* Created time */
 80040fe:	f001 f803 	bl	8005108 <get_fattime>
				ST_DWORD(dir+DIR_CrtTime, dw);
 8004102:	f3c0 2607 	ubfx	r6, r0, #8, #8
 8004106:	73a0      	strb	r0, [r4, #14]
 8004108:	73e6      	strb	r6, [r4, #15]
 800410a:	0c01      	lsrs	r1, r0, #16
				dir[DIR_Attr] = 0;				/* Reset attribute */
 800410c:	2600      	movs	r6, #0
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = get_fattime();				/* Created time */
				ST_DWORD(dir+DIR_CrtTime, dw);
 800410e:	0e00      	lsrs	r0, r0, #24
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
 8004110:	f8dd 9014 	ldr.w	r9, [sp, #20]
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = get_fattime();				/* Created time */
				ST_DWORD(dir+DIR_CrtTime, dw);
 8004114:	7421      	strb	r1, [r4, #16]
				dir[DIR_Attr] = 0;				/* Reset attribute */
 8004116:	72e6      	strb	r6, [r4, #11]
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
 8004118:	7726      	strb	r6, [r4, #28]
 800411a:	7766      	strb	r6, [r4, #29]
 800411c:	77a6      	strb	r6, [r4, #30]
 800411e:	77e6      	strb	r6, [r4, #31]
						res = FR_EXIST;
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
				dw = get_fattime();				/* Created time */
				ST_DWORD(dir+DIR_CrtTime, dw);
 8004120:	7460      	strb	r0, [r4, #17]
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
 8004122:	f899 0000 	ldrb.w	r0, [r9]
 8004126:	4621      	mov	r1, r4
 8004128:	f7ff f992 	bl	8003450 <ld_clust.isra.0>
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 800412c:	2201      	movs	r2, #1
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 800412e:	76a6      	strb	r6, [r4, #26]
 8004130:	76e6      	strb	r6, [r4, #27]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8004132:	7526      	strb	r6, [r4, #20]
 8004134:	7566      	strb	r6, [r4, #21]
				ST_DWORD(dir+DIR_CrtTime, dw);
				dir[DIR_Attr] = 0;				/* Reset attribute */
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
 8004136:	f889 2004 	strb.w	r2, [r9, #4]
				if (cl) {						/* Remove the cluster chain if exist */
 800413a:	4606      	mov	r6, r0
 800413c:	b1e8      	cbz	r0, 800417a <f_open+0xfa>
					dw = dj.fs->winsect;
					res = remove_chain(dj.fs, cl);
 800413e:	4648      	mov	r0, r9
 8004140:	4631      	mov	r1, r6
				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
				st_clust(dir, 0);				/* cluster = 0 */
				dj.fs->wflag = 1;
				if (cl) {						/* Remove the cluster chain if exist */
					dw = dj.fs->winsect;
 8004142:	f8d9 a02c 	ldr.w	sl, [r9, #44]	; 0x2c
					res = remove_chain(dj.fs, cl);
 8004146:	f7ff ff49 	bl	8003fdc <remove_chain>
					if (res == FR_OK) {
 800414a:	2800      	cmp	r0, #0
 800414c:	d140      	bne.n	80041d0 <f_open+0x150>
						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
 800414e:	9805      	ldr	r0, [sp, #20]
 8004150:	3e01      	subs	r6, #1
 8004152:	60c6      	str	r6, [r0, #12]
						res = move_window(dj.fs, dw);
 8004154:	4651      	mov	r1, sl
 8004156:	f7ff fa07 	bl	8003568 <move_window>
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
 800415a:	b170      	cbz	r0, 800417a <f_open+0xfa>
 800415c:	e038      	b.n	80041d0 <f_open+0x150>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
 800415e:	2800      	cmp	r0, #0
 8004160:	d136      	bne.n	80041d0 <f_open+0x150>
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
 8004162:	7ae1      	ldrb	r1, [r4, #11]
 8004164:	f001 0210 	and.w	r2, r1, #16
 8004168:	b2d3      	uxtb	r3, r2
 800416a:	2b00      	cmp	r3, #0
 800416c:	d12d      	bne.n	80041ca <f_open+0x14a>
					res = FR_NO_FILE;
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
 800416e:	f006 0602 	and.w	r6, r6, #2
 8004172:	b2f6      	uxtb	r6, r6
 8004174:	b10e      	cbz	r6, 800417a <f_open+0xfa>
 8004176:	07c8      	lsls	r0, r1, #31
 8004178:	d429      	bmi.n	80041ce <f_open+0x14e>
						res = FR_DENIED;
				}
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 800417a:	f007 0308 	and.w	r3, r7, #8
 800417e:	b2d9      	uxtb	r1, r3
 8004180:	b109      	cbz	r1, 8004186 <f_open+0x106>
				mode |= FA__WRITTEN;
 8004182:	f047 0720 	orr.w	r7, r7, #32
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8004186:	9e05      	ldr	r6, [sp, #20]
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004188:	4621      	mov	r1, r4
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 800418a:	6af0      	ldr	r0, [r6, #44]	; 0x2c
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
 800418c:	71af      	strb	r7, [r5, #6]
			fp->err = 0;						/* Clear error flag */
 800418e:	2700      	movs	r7, #0
			}
		}
		if (res == FR_OK) {
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
				mode |= FA__WRITTEN;
			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
 8004190:	61e8      	str	r0, [r5, #28]
			fp->dir_ptr = dir;
 8004192:	622c      	str	r4, [r5, #32]
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
 8004194:	71ef      	strb	r7, [r5, #7]
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
 8004196:	7830      	ldrb	r0, [r6, #0]
 8004198:	f7ff f95a 	bl	8003450 <ld_clust.isra.0>
 800419c:	6128      	str	r0, [r5, #16]
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 800419e:	7fa3      	ldrb	r3, [r4, #30]
 80041a0:	7fe2      	ldrb	r2, [r4, #31]
 80041a2:	0419      	lsls	r1, r3, #16
 80041a4:	ea41 6002 	orr.w	r0, r1, r2, lsl #24
 80041a8:	7f22      	ldrb	r2, [r4, #28]
 80041aa:	7f63      	ldrb	r3, [r4, #29]
 80041ac:	4310      	orrs	r0, r2
 80041ae:	ea40 2103 	orr.w	r1, r0, r3, lsl #8
			fp->dsect = 0;
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
			fp->id = fp->fs->id;
 80041b2:	88f0      	ldrh	r0, [r6, #6]

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
			fp->err = 0;						/* Clear error flag */
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 80041b4:	60e9      	str	r1, [r5, #12]
			fp->fptr = 0;						/* File pointer */
 80041b6:	60af      	str	r7, [r5, #8]
			fp->dsect = 0;
 80041b8:	61af      	str	r7, [r5, #24]
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs;	 					/* Validate file object */
 80041ba:	602e      	str	r6, [r5, #0]
			fp->id = fp->fs->id;
 80041bc:	80a8      	strh	r0, [r5, #4]
 80041be:	e008      	b.n	80041d2 <f_open+0x152>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
 80041c0:	f04f 0809 	mov.w	r8, #9
 80041c4:	e005      	b.n	80041d2 <f_open+0x152>
			else {								/* Any object is already existing */
				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
						res = FR_EXIST;
 80041c6:	2008      	movs	r0, #8
 80041c8:	e002      	b.n	80041d0 <f_open+0x150>
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Follow succeeded */
				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
					res = FR_NO_FILE;
 80041ca:	2004      	movs	r0, #4
 80041cc:	e000      	b.n	80041d0 <f_open+0x150>
				} else {
					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
						res = FR_DENIED;
 80041ce:	2007      	movs	r0, #7
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
 80041d0:	4680      	mov	r8, r0
			fp->id = fp->fs->id;
		}
	}

	LEAVE_FF(dj.fs, res);
}
 80041d2:	4640      	mov	r0, r8
 80041d4:	b00c      	add	sp, #48	; 0x30
 80041d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080041da <f_read>:
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
 80041da:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80041de:	469a      	mov	sl, r3
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 80041e0:	2300      	movs	r3, #0
 80041e2:	f8ca 3000 	str.w	r3, [sl]
	FIL* fp, 		/* Pointer to the file object */
	void* buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT* br		/* Pointer to number of bytes read */
)
{
 80041e6:	4604      	mov	r4, r0
 80041e8:	4688      	mov	r8, r1
 80041ea:	4617      	mov	r7, r2
	BYTE csect, *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
 80041ec:	f7ff f91b 	bl	8003426 <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 80041f0:	4605      	mov	r5, r0
 80041f2:	2800      	cmp	r0, #0
 80041f4:	f040 809a 	bne.w	800432c <f_read+0x152>
	if (fp->err)								/* Check error */
 80041f8:	79e0      	ldrb	r0, [r4, #7]
 80041fa:	2800      	cmp	r0, #0
 80041fc:	f040 8093 	bne.w	8004326 <f_read+0x14c>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 8004200:	79a1      	ldrb	r1, [r4, #6]
 8004202:	07c9      	lsls	r1, r1, #31
 8004204:	f140 8091 	bpl.w	800432a <f_read+0x150>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
 8004208:	68e2      	ldr	r2, [r4, #12]
 800420a:	68a6      	ldr	r6, [r4, #8]
 800420c:	1b96      	subs	r6, r2, r6
 800420e:	42b7      	cmp	r7, r6
 8004210:	bf38      	it	cc
 8004212:	463e      	movcc	r6, r7
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
 8004214:	2e00      	cmp	r6, #0
 8004216:	f000 8089 	beq.w	800432c <f_read+0x152>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 800421a:	68a1      	ldr	r1, [r4, #8]
 800421c:	05cb      	lsls	r3, r1, #23
 800421e:	d169      	bne.n	80042f4 <f_read+0x11a>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8004220:	6820      	ldr	r0, [r4, #0]
 8004222:	7883      	ldrb	r3, [r0, #2]
 8004224:	1e5a      	subs	r2, r3, #1
 8004226:	ea02 2351 	and.w	r3, r2, r1, lsr #9
			if (!csect) {						/* On the cluster boundary? */
 800422a:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
 800422e:	d10c      	bne.n	800424a <f_read+0x70>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8004230:	b909      	cbnz	r1, 8004236 <f_read+0x5c>
					clst = fp->sclust;			/* Follow from the origin */
 8004232:	6920      	ldr	r0, [r4, #16]
 8004234:	e004      	b.n	8004240 <f_read+0x66>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 8004236:	6961      	ldr	r1, [r4, #20]
 8004238:	9301      	str	r3, [sp, #4]
 800423a:	f7ff fb87 	bl	800394c <get_fat>
 800423e:	9b01      	ldr	r3, [sp, #4]
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 8004240:	2801      	cmp	r0, #1
 8004242:	d90b      	bls.n	800425c <f_read+0x82>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 8004244:	1c42      	adds	r2, r0, #1
 8004246:	d051      	beq.n	80042ec <f_read+0x112>
				fp->clust = clst;				/* Update current cluster */
 8004248:	6160      	str	r0, [r4, #20]
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 800424a:	f8d4 b000 	ldr.w	fp, [r4]
 800424e:	6961      	ldr	r1, [r4, #20]
 8004250:	4658      	mov	r0, fp
 8004252:	9301      	str	r3, [sp, #4]
 8004254:	f7ff fb6e 	bl	8003934 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 8004258:	9b01      	ldr	r3, [sp, #4]
 800425a:	b908      	cbnz	r0, 8004260 <f_read+0x86>
 800425c:	2502      	movs	r5, #2
 800425e:	e046      	b.n	80042ee <f_read+0x114>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
 8004260:	ea5f 2956 	movs.w	r9, r6, lsr #9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
 8004264:	eb00 0703 	add.w	r7, r0, r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
 8004268:	d023      	beq.n	80042b2 <f_read+0xd8>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 800426a:	f89b 0002 	ldrb.w	r0, [fp, #2]
 800426e:	eb09 0103 	add.w	r1, r9, r3
 8004272:	4281      	cmp	r1, r0
					cc = fp->fs->csize - csect;
 8004274:	bf88      	it	hi
 8004276:	ebc3 0900 	rsbhi	r9, r3, r0
				if (disk_read(fp->fs->drv, rbuff, sect, cc))
 800427a:	4641      	mov	r1, r8
 800427c:	f89b 0001 	ldrb.w	r0, [fp, #1]
 8004280:	463a      	mov	r2, r7
 8004282:	464b      	mov	r3, r9
 8004284:	f000 fd72 	bl	8004d6c <disk_read>
 8004288:	bb80      	cbnz	r0, 80042ec <f_read+0x112>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
 800428a:	79a3      	ldrb	r3, [r4, #6]
 800428c:	f003 0240 	and.w	r2, r3, #64	; 0x40
 8004290:	b2d0      	uxtb	r0, r2
 8004292:	b158      	cbz	r0, 80042ac <f_read+0xd2>
 8004294:	69a1      	ldr	r1, [r4, #24]
 8004296:	1bcf      	subs	r7, r1, r7
 8004298:	454f      	cmp	r7, r9
 800429a:	d207      	bcs.n	80042ac <f_read+0xd2>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
 800429c:	eb08 2047 	add.w	r0, r8, r7, lsl #9
 80042a0:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80042a4:	f44f 7200 	mov.w	r2, #512	; 0x200
 80042a8:	f7ff f870 	bl	800338c <mem_cpy>
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 80042ac:	ea4f 2749 	mov.w	r7, r9, lsl #9
				continue;
 80042b0:	e02e      	b.n	8004310 <f_read+0x136>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
 80042b2:	69a2      	ldr	r2, [r4, #24]
 80042b4:	42ba      	cmp	r2, r7
 80042b6:	d01c      	beq.n	80042f2 <f_read+0x118>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
 80042b8:	79a0      	ldrb	r0, [r4, #6]
 80042ba:	f000 0140 	and.w	r1, r0, #64	; 0x40
 80042be:	b2cb      	uxtb	r3, r1
 80042c0:	b15b      	cbz	r3, 80042da <f_read+0x100>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 80042c2:	f89b 0001 	ldrb.w	r0, [fp, #1]
 80042c6:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80042ca:	2301      	movs	r3, #1
 80042cc:	f000 fd90 	bl	8004df0 <disk_write>
 80042d0:	b960      	cbnz	r0, 80042ec <f_read+0x112>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
 80042d2:	79a2      	ldrb	r2, [r4, #6]
 80042d4:	f022 0040 	bic.w	r0, r2, #64	; 0x40
 80042d8:	71a0      	strb	r0, [r4, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1))	/* Fill sector cache */
 80042da:	4621      	mov	r1, r4
 80042dc:	f851 3b24 	ldr.w	r3, [r1], #36
 80042e0:	463a      	mov	r2, r7
 80042e2:	7858      	ldrb	r0, [r3, #1]
 80042e4:	2301      	movs	r3, #1
 80042e6:	f000 fd41 	bl	8004d6c <disk_read>
 80042ea:	b110      	cbz	r0, 80042f2 <f_read+0x118>
					ABORT(fp->fs, FR_DISK_ERR);
 80042ec:	2501      	movs	r5, #1
 80042ee:	71e5      	strb	r5, [r4, #7]
 80042f0:	e01c      	b.n	800432c <f_read+0x152>
			}
#endif
			fp->dsect = sect;
 80042f2:	61a7      	str	r7, [r4, #24]
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 80042f4:	68a7      	ldr	r7, [r4, #8]
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 80042f6:	4640      	mov	r0, r8
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 80042f8:	05f9      	lsls	r1, r7, #23
 80042fa:	0dca      	lsrs	r2, r1, #23
 80042fc:	f5c2 7700 	rsb	r7, r2, #512	; 0x200
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
 8004300:	18a1      	adds	r1, r4, r2
 8004302:	42be      	cmp	r6, r7
 8004304:	bf38      	it	cc
 8004306:	4637      	movcc	r7, r6
 8004308:	3124      	adds	r1, #36	; 0x24
 800430a:	463a      	mov	r2, r7
 800430c:	f7ff f83e 	bl	800338c <mem_cpy>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8004310:	68a3      	ldr	r3, [r4, #8]
 8004312:	f8da 0000 	ldr.w	r0, [sl]
 8004316:	19da      	adds	r2, r3, r7
 8004318:	19c1      	adds	r1, r0, r7
 800431a:	60a2      	str	r2, [r4, #8]
 800431c:	44b8      	add	r8, r7
 800431e:	f8ca 1000 	str.w	r1, [sl]
 8004322:	1bf6      	subs	r6, r6, r7
 8004324:	e776      	b.n	8004214 <f_read+0x3a>

	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)								/* Check error */
 8004326:	4605      	mov	r5, r0
 8004328:	e000      	b.n	800432c <f_read+0x152>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 800432a:	2507      	movs	r5, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
 800432c:	4628      	mov	r0, r5
 800432e:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08004332 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 8004332:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004336:	4699      	mov	r9, r3
	UINT wcnt, cc;
	const BYTE *wbuff = (const BYTE*)buff;
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */
 8004338:	2300      	movs	r3, #0
 800433a:	f8c9 3000 	str.w	r3, [r9]
	FIL* fp,			/* Pointer to the file object */
	const void *buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 800433e:	4604      	mov	r4, r0
 8004340:	4688      	mov	r8, r1
 8004342:	4617      	mov	r7, r2
	BYTE csect;


	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
 8004344:	f7ff f86f 	bl	8003426 <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 8004348:	4605      	mov	r5, r0
 800434a:	2800      	cmp	r0, #0
 800434c:	f040 80b0 	bne.w	80044b0 <f_write+0x17e>
	if (fp->err)							/* Check error */
 8004350:	79e0      	ldrb	r0, [r4, #7]
 8004352:	2800      	cmp	r0, #0
 8004354:	f040 80a9 	bne.w	80044aa <f_write+0x178>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
 8004358:	79a1      	ldrb	r1, [r4, #6]
 800435a:	f001 0202 	and.w	r2, r1, #2
 800435e:	b2d3      	uxtb	r3, r2
 8004360:	2b00      	cmp	r3, #0
 8004362:	f000 80a4 	beq.w	80044ae <f_write+0x17c>
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
 8004366:	68a0      	ldr	r0, [r4, #8]
 8004368:	42c7      	cmn	r7, r0
 800436a:	bf28      	it	cs
 800436c:	2700      	movcs	r7, #0

	for ( ;  btw;							/* Repeat until all data written */
 800436e:	b1cf      	cbz	r7, 80043a4 <f_write+0x72>
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
 8004370:	68a1      	ldr	r1, [r4, #8]
 8004372:	05ca      	lsls	r2, r1, #23
 8004374:	d177      	bne.n	8004466 <f_write+0x134>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 8004376:	6820      	ldr	r0, [r4, #0]
 8004378:	f890 a002 	ldrb.w	sl, [r0, #2]
 800437c:	f10a 32ff 	add.w	r2, sl, #4294967295	; 0xffffffff
 8004380:	ea02 2351 	and.w	r3, r2, r1, lsr #9
			if (!csect) {					/* On the cluster boundary? */
 8004384:	f013 0aff 	ands.w	sl, r3, #255	; 0xff
 8004388:	d117      	bne.n	80043ba <f_write+0x88>
				if (fp->fptr == 0) {		/* On the top of the file? */
 800438a:	b931      	cbnz	r1, 800439a <f_write+0x68>
					clst = fp->sclust;		/* Follow from the origin */
 800438c:	6921      	ldr	r1, [r4, #16]
					if (clst == 0)			/* When no cluster is allocated, */
 800438e:	b979      	cbnz	r1, 80043b0 <f_write+0x7e>
						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
 8004390:	f7ff fc0d 	bl	8003bae <create_chain>
 8004394:	4601      	mov	r1, r0
 8004396:	6120      	str	r0, [r4, #16]
 8004398:	e003      	b.n	80043a2 <f_write+0x70>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800439a:	6961      	ldr	r1, [r4, #20]
 800439c:	f7ff fc07 	bl	8003bae <create_chain>
 80043a0:	4601      	mov	r1, r0
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 80043a2:	b929      	cbnz	r1, 80043b0 <f_write+0x7e>
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
 80043a4:	68a1      	ldr	r1, [r4, #8]
 80043a6:	68e3      	ldr	r3, [r4, #12]
 80043a8:	4299      	cmp	r1, r3
 80043aa:	d979      	bls.n	80044a0 <f_write+0x16e>
 80043ac:	60e1      	str	r1, [r4, #12]
 80043ae:	e077      	b.n	80044a0 <f_write+0x16e>
					else
#endif
						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 80043b0:	2901      	cmp	r1, #1
 80043b2:	d01d      	beq.n	80043f0 <f_write+0xbe>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 80043b4:	1c48      	adds	r0, r1, #1
 80043b6:	d052      	beq.n	800445e <f_write+0x12c>
				fp->clust = clst;			/* Update current cluster */
 80043b8:	6161      	str	r1, [r4, #20]
			}
#if _FS_TINY
			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#else
			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
 80043ba:	79a0      	ldrb	r0, [r4, #6]
 80043bc:	f000 0140 	and.w	r1, r0, #64	; 0x40
 80043c0:	b2ca      	uxtb	r2, r1
 80043c2:	b16a      	cbz	r2, 80043e0 <f_write+0xae>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 80043c4:	4621      	mov	r1, r4
 80043c6:	f851 3b24 	ldr.w	r3, [r1], #36
 80043ca:	69a2      	ldr	r2, [r4, #24]
 80043cc:	7858      	ldrb	r0, [r3, #1]
 80043ce:	2301      	movs	r3, #1
 80043d0:	f000 fd0e 	bl	8004df0 <disk_write>
 80043d4:	2800      	cmp	r0, #0
 80043d6:	d142      	bne.n	800445e <f_write+0x12c>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 80043d8:	79a0      	ldrb	r0, [r4, #6]
 80043da:	f020 0140 	bic.w	r1, r0, #64	; 0x40
 80043de:	71a1      	strb	r1, [r4, #6]
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 80043e0:	6822      	ldr	r2, [r4, #0]
 80043e2:	6961      	ldr	r1, [r4, #20]
 80043e4:	4610      	mov	r0, r2
 80043e6:	9201      	str	r2, [sp, #4]
 80043e8:	f7ff faa4 	bl	8003934 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 80043ec:	9b01      	ldr	r3, [sp, #4]
 80043ee:	b908      	cbnz	r0, 80043f4 <f_write+0xc2>
 80043f0:	2502      	movs	r5, #2
 80043f2:	e035      	b.n	8004460 <f_write+0x12e>
			sect += csect;
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 80043f4:	ea5f 2b57 	movs.w	fp, r7, lsr #9
				fp->flag &= ~FA__DIRTY;
			}
#endif
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
 80043f8:	eb00 060a 	add.w	r6, r0, sl
			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
			if (cc) {						/* Write maximum contiguous sectors directly */
 80043fc:	d020      	beq.n	8004440 <f_write+0x10e>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 80043fe:	7898      	ldrb	r0, [r3, #2]
 8004400:	eb0b 010a 	add.w	r1, fp, sl
 8004404:	4281      	cmp	r1, r0
					cc = fp->fs->csize - csect;
 8004406:	bf88      	it	hi
 8004408:	ebca 0b00 	rsbhi	fp, sl, r0
				if (disk_write(fp->fs->drv, wbuff, sect, cc))
 800440c:	4641      	mov	r1, r8
 800440e:	7858      	ldrb	r0, [r3, #1]
 8004410:	4632      	mov	r2, r6
 8004412:	465b      	mov	r3, fp
 8004414:	f000 fcec 	bl	8004df0 <disk_write>
 8004418:	bb08      	cbnz	r0, 800445e <f_write+0x12c>
				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
					fp->fs->wflag = 0;
				}
#else
				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 800441a:	69a3      	ldr	r3, [r4, #24]
 800441c:	1b9e      	subs	r6, r3, r6
 800441e:	455e      	cmp	r6, fp
 8004420:	d20b      	bcs.n	800443a <f_write+0x108>
					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
 8004422:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8004426:	f44f 7200 	mov.w	r2, #512	; 0x200
 800442a:	eb08 2146 	add.w	r1, r8, r6, lsl #9
 800442e:	f7fe ffad 	bl	800338c <mem_cpy>
					fp->flag &= ~FA__DIRTY;
 8004432:	79a2      	ldrb	r2, [r4, #6]
 8004434:	f022 0040 	bic.w	r0, r2, #64	; 0x40
 8004438:	71a0      	strb	r0, [r4, #6]
				}
#endif
#endif
				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
 800443a:	ea4f 264b 	mov.w	r6, fp, lsl #9
				continue;
 800443e:	e024      	b.n	800448a <f_write+0x158>
			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
 8004440:	69a0      	ldr	r0, [r4, #24]
 8004442:	42b0      	cmp	r0, r6
 8004444:	d00e      	beq.n	8004464 <f_write+0x132>
				if (fp->fptr < fp->fsize &&
 8004446:	68a1      	ldr	r1, [r4, #8]
 8004448:	68e2      	ldr	r2, [r4, #12]
 800444a:	4291      	cmp	r1, r2
 800444c:	d20a      	bcs.n	8004464 <f_write+0x132>
					disk_read(fp->fs->drv, fp->buf, sect, 1))
 800444e:	7858      	ldrb	r0, [r3, #1]
 8004450:	f104 0124 	add.w	r1, r4, #36	; 0x24
 8004454:	4632      	mov	r2, r6
 8004456:	2301      	movs	r3, #1
 8004458:	f000 fc88 	bl	8004d6c <disk_read>
				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
				fp->fs->winsect = sect;
			}
#else
			if (fp->dsect != sect) {		/* Fill sector cache with file data */
				if (fp->fptr < fp->fsize &&
 800445c:	b110      	cbz	r0, 8004464 <f_write+0x132>
					disk_read(fp->fs->drv, fp->buf, sect, 1))
						ABORT(fp->fs, FR_DISK_ERR);
 800445e:	2501      	movs	r5, #1
 8004460:	71e5      	strb	r5, [r4, #7]
 8004462:	e025      	b.n	80044b0 <f_write+0x17e>
			}
#endif
			fp->dsect = sect;
 8004464:	61a6      	str	r6, [r4, #24]
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 8004466:	68a6      	ldr	r6, [r4, #8]
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8004468:	4641      	mov	r1, r8
						ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
 800446a:	05f3      	lsls	r3, r6, #23
 800446c:	0dd8      	lsrs	r0, r3, #23
 800446e:	f5c0 7600 	rsb	r6, r0, #512	; 0x200
 8004472:	42b7      	cmp	r7, r6
 8004474:	bf38      	it	cc
 8004476:	463e      	movcc	r6, r7
		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
		fp->fs->wflag = 1;
#else
		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
 8004478:	1820      	adds	r0, r4, r0
 800447a:	4632      	mov	r2, r6
 800447c:	3024      	adds	r0, #36	; 0x24
 800447e:	f7fe ff85 	bl	800338c <mem_cpy>
		fp->flag |= FA__DIRTY;
 8004482:	79a1      	ldrb	r1, [r4, #6]
 8004484:	f041 0240 	orr.w	r2, r1, #64	; 0x40
 8004488:	71a2      	strb	r2, [r4, #6]
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */

	for ( ;  btw;							/* Repeat until all data written */
		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
 800448a:	68a1      	ldr	r1, [r4, #8]
 800448c:	f8d9 2000 	ldr.w	r2, [r9]
 8004490:	198b      	adds	r3, r1, r6
 8004492:	1990      	adds	r0, r2, r6
 8004494:	60a3      	str	r3, [r4, #8]
 8004496:	44b0      	add	r8, r6
 8004498:	f8c9 0000 	str.w	r0, [r9]
 800449c:	1bbf      	subs	r7, r7, r6
 800449e:	e766      	b.n	800436e <f_write+0x3c>
		fp->flag |= FA__DIRTY;
#endif
	}

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */
 80044a0:	79a2      	ldrb	r2, [r4, #6]
 80044a2:	f042 0020 	orr.w	r0, r2, #32
 80044a6:	71a0      	strb	r0, [r4, #6]

	LEAVE_FF(fp->fs, FR_OK);
 80044a8:	e002      	b.n	80044b0 <f_write+0x17e>

	*bw = 0;	/* Clear write byte counter */

	res = validate(fp);						/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)							/* Check error */
 80044aa:	4605      	mov	r5, r0
 80044ac:	e000      	b.n	80044b0 <f_write+0x17e>
		LEAVE_FF(fp->fs, (FRESULT)fp->err);
	if (!(fp->flag & FA_WRITE))				/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
 80044ae:	2507      	movs	r5, #7

	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
	fp->flag |= FA__WRITTEN;						/* Set file change flag */

	LEAVE_FF(fp->fs, FR_OK);
}
 80044b0:	4628      	mov	r0, r5
 80044b2:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080044b6 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 80044b6:	b570      	push	{r4, r5, r6, lr}
 80044b8:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tm;
	BYTE *dir;


	res = validate(fp);					/* Check validity of the object */
 80044ba:	f7fe ffb4 	bl	8003426 <validate>
	if (res == FR_OK) {
 80044be:	2800      	cmp	r0, #0
 80044c0:	d14e      	bne.n	8004560 <f_sync+0xaa>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
 80044c2:	79a3      	ldrb	r3, [r4, #6]
 80044c4:	f003 0220 	and.w	r2, r3, #32
 80044c8:	b2d1      	uxtb	r1, r2
 80044ca:	2900      	cmp	r1, #0
 80044cc:	d048      	beq.n	8004560 <f_sync+0xaa>
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
 80044ce:	f003 0040 	and.w	r0, r3, #64	; 0x40
 80044d2:	b2c3      	uxtb	r3, r0
 80044d4:	b16b      	cbz	r3, 80044f2 <f_sync+0x3c>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 80044d6:	4621      	mov	r1, r4
 80044d8:	f851 2b24 	ldr.w	r2, [r1], #36
 80044dc:	2301      	movs	r3, #1
 80044de:	7850      	ldrb	r0, [r2, #1]
 80044e0:	69a2      	ldr	r2, [r4, #24]
 80044e2:	f000 fc85 	bl	8004df0 <disk_write>
 80044e6:	2800      	cmp	r0, #0
 80044e8:	d139      	bne.n	800455e <f_sync+0xa8>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 80044ea:	79a6      	ldrb	r6, [r4, #6]
 80044ec:	f026 0140 	bic.w	r1, r6, #64	; 0x40
 80044f0:	71a1      	strb	r1, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
 80044f2:	6820      	ldr	r0, [r4, #0]
 80044f4:	69e1      	ldr	r1, [r4, #28]
 80044f6:	f7ff f837 	bl	8003568 <move_window>
 80044fa:	4606      	mov	r6, r0
			if (res == FR_OK) {
 80044fc:	2e00      	cmp	r6, #0
 80044fe:	d12f      	bne.n	8004560 <f_sync+0xaa>
				dir = fp->dir_ptr;
 8004500:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
 8004502:	7ae8      	ldrb	r0, [r5, #11]
 8004504:	f040 0320 	orr.w	r3, r0, #32
 8004508:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
 800450a:	68e2      	ldr	r2, [r4, #12]
 800450c:	772a      	strb	r2, [r5, #28]
 800450e:	89a1      	ldrh	r1, [r4, #12]
 8004510:	0a08      	lsrs	r0, r1, #8
 8004512:	7768      	strb	r0, [r5, #29]
 8004514:	89e3      	ldrh	r3, [r4, #14]
 8004516:	77ab      	strb	r3, [r5, #30]
 8004518:	7be2      	ldrb	r2, [r4, #15]
 800451a:	77ea      	strb	r2, [r5, #31]
				st_clust(dir, fp->sclust);					/* Update start cluster */
 800451c:	6921      	ldr	r1, [r4, #16]
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 800451e:	0c0b      	lsrs	r3, r1, #16
 8004520:	0a1a      	lsrs	r2, r3, #8
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 8004522:	f3c1 2007 	ubfx	r0, r1, #8, #8
 8004526:	76a9      	strb	r1, [r5, #26]
	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
 8004528:	752b      	strb	r3, [r5, #20]
 800452a:	756a      	strb	r2, [r5, #21]
void st_clust (
	BYTE* dir,	/* Pointer to the directory entry */
	DWORD cl	/* Value to be set */
)
{
	ST_WORD(dir+DIR_FstClusLO, cl);
 800452c:	76e8      	strb	r0, [r5, #27]
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
 800452e:	f000 fdeb 	bl	8005108 <get_fattime>
				ST_DWORD(dir+DIR_WrtTime, tm);
 8004532:	75a8      	strb	r0, [r5, #22]
 8004534:	0c03      	lsrs	r3, r0, #16
 8004536:	f3c0 2107 	ubfx	r1, r0, #8, #8
 800453a:	0e00      	lsrs	r0, r0, #24
 800453c:	75e9      	strb	r1, [r5, #23]
 800453e:	7668      	strb	r0, [r5, #25]
 8004540:	762b      	strb	r3, [r5, #24]
				ST_WORD(dir+DIR_LstAccDate, 0);
 8004542:	74ae      	strb	r6, [r5, #18]
 8004544:	74ee      	strb	r6, [r5, #19]
				fp->flag &= ~FA__WRITTEN;
 8004546:	79a2      	ldrb	r2, [r4, #6]
				fp->fs->wflag = 1;
 8004548:	6823      	ldr	r3, [r4, #0]
 800454a:	2001      	movs	r0, #1
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				st_clust(dir, fp->sclust);					/* Update start cluster */
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
 800454c:	f022 0120 	bic.w	r1, r2, #32
 8004550:	71a1      	strb	r1, [r4, #6]
				fp->fs->wflag = 1;
 8004552:	7118      	strb	r0, [r3, #4]
				res = sync_fs(fp->fs);
 8004554:	6820      	ldr	r0, [r4, #0]
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 8004556:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				tm = get_fattime();							/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tm);
				ST_WORD(dir+DIR_LstAccDate, 0);
				fp->flag &= ~FA__WRITTEN;
				fp->fs->wflag = 1;
				res = sync_fs(fp->fs);
 800455a:	f7fe bfac 	b.w	80034b6 <sync_fs>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
			/* Write-back dirty buffer */
#if !_FS_TINY
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
					LEAVE_FF(fp->fs, FR_DISK_ERR);
 800455e:	2001      	movs	r0, #1
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
 8004560:	bd70      	pop	{r4, r5, r6, pc}

08004562 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 8004562:	b510      	push	{r4, lr}
 8004564:	4604      	mov	r4, r0
#endif
		if (res == FR_OK) fp->fs = 0;	/* Invalidate file object */
		LEAVE_FF(fs, res);
	}
#else
	res = f_sync(fp);					/* Flush cached data */
 8004566:	f7ff ffa6 	bl	80044b6 <f_sync>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;		/* Invalidate file object */
 800456a:	b900      	cbnz	r0, 800456e <f_close+0xc>
 800456c:	6020      	str	r0, [r4, #0]
	return res;
#endif
}
 800456e:	bd10      	pop	{r4, pc}

08004570 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 8004570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004572:	4604      	mov	r4, r0
 8004574:	460f      	mov	r7, r1
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
 8004576:	f7fe ff56 	bl	8003426 <validate>
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 800457a:	4606      	mov	r6, r0
 800457c:	2800      	cmp	r0, #0
 800457e:	f040 808f 	bne.w	80046a0 <f_lseek+0x130>
	if (fp->err)						/* Check error */
 8004582:	79e3      	ldrb	r3, [r4, #7]
 8004584:	2b00      	cmp	r3, #0
 8004586:	f040 808a 	bne.w	800469e <f_lseek+0x12e>

	/* Normal Seek */
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
 800458a:	68e5      	ldr	r5, [r4, #12]
 800458c:	42af      	cmp	r7, r5
 800458e:	d801      	bhi.n	8004594 <f_lseek+0x24>

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
 8004590:	463d      	mov	r5, r7
 8004592:	e005      	b.n	80045a0 <f_lseek+0x30>
	{
		DWORD clst, bcs, nsect, ifptr;

		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
 8004594:	79a0      	ldrb	r0, [r4, #6]
 8004596:	f000 0102 	and.w	r1, r0, #2
 800459a:	b2ca      	uxtb	r2, r1
 800459c:	2a00      	cmp	r2, #0
 800459e:	d1f7      	bne.n	8004590 <f_lseek+0x20>
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
 80045a0:	2000      	movs	r0, #0
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
 80045a2:	68a3      	ldr	r3, [r4, #8]
		fp->fptr = nsect = 0;
 80045a4:	60a0      	str	r0, [r4, #8]
		if (ofs) {
 80045a6:	b90d      	cbnz	r5, 80045ac <f_lseek+0x3c>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
 80045a8:	2500      	movs	r5, #0
 80045aa:	e04a      	b.n	8004642 <f_lseek+0xd2>
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
 80045ac:	6820      	ldr	r0, [r4, #0]
 80045ae:	7887      	ldrb	r7, [r0, #2]
 80045b0:	027f      	lsls	r7, r7, #9
			if (ifptr > 0 &&
 80045b2:	b16b      	cbz	r3, 80045d0 <f_lseek+0x60>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 80045b4:	3b01      	subs	r3, #1
 80045b6:	1e69      	subs	r1, r5, #1
 80045b8:	fbb1 f1f7 	udiv	r1, r1, r7
 80045bc:	fbb3 f2f7 	udiv	r2, r3, r7

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
 80045c0:	4291      	cmp	r1, r2
 80045c2:	d305      	bcc.n	80045d0 <f_lseek+0x60>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
 80045c4:	4278      	negs	r0, r7
 80045c6:	4003      	ands	r3, r0
 80045c8:	60a3      	str	r3, [r4, #8]
				ofs -= fp->fptr;
 80045ca:	1aed      	subs	r5, r5, r3
				clst = fp->clust;
 80045cc:	6961      	ldr	r1, [r4, #20]
 80045ce:	e00a      	b.n	80045e6 <f_lseek+0x76>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
 80045d0:	6921      	ldr	r1, [r4, #16]
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 80045d2:	b939      	cbnz	r1, 80045e4 <f_lseek+0x74>
					clst = create_chain(fp->fs, 0);
 80045d4:	f7ff faeb 	bl	8003bae <create_chain>
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 80045d8:	2801      	cmp	r0, #1
				clst = fp->clust;
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
					clst = create_chain(fp->fs, 0);
 80045da:	4601      	mov	r1, r0
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
 80045dc:	d02d      	beq.n	800463a <f_lseek+0xca>
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 80045de:	1c42      	adds	r2, r0, #1
 80045e0:	d04f      	beq.n	8004682 <f_lseek+0x112>
					fp->sclust = clst;
 80045e2:	6120      	str	r0, [r4, #16]
				}
#endif
				fp->clust = clst;
 80045e4:	6161      	str	r1, [r4, #20]
			}
			if (clst != 0) {
 80045e6:	2900      	cmp	r1, #0
 80045e8:	d0de      	beq.n	80045a8 <f_lseek+0x38>
				while (ofs > bcs) {						/* Cluster following loop */
 80045ea:	42bd      	cmp	r5, r7
 80045ec:	d91c      	bls.n	8004628 <f_lseek+0xb8>
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 80045ee:	79a3      	ldrb	r3, [r4, #6]
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 80045f0:	6820      	ldr	r0, [r4, #0]
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 80045f2:	f003 0202 	and.w	r2, r3, #2
 80045f6:	b2d3      	uxtb	r3, r2
 80045f8:	b123      	cbz	r3, 8004604 <f_lseek+0x94>
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
 80045fa:	f7ff fad8 	bl	8003bae <create_chain>
						if (clst == 0) {				/* When disk gets full, clip file size */
 80045fe:	4601      	mov	r1, r0
 8004600:	b918      	cbnz	r0, 800460a <f_lseek+0x9a>
 8004602:	e010      	b.n	8004626 <f_lseek+0xb6>
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
 8004604:	f7ff f9a2 	bl	800394c <get_fat>
 8004608:	4601      	mov	r1, r0
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 800460a:	1c4b      	adds	r3, r1, #1
 800460c:	d039      	beq.n	8004682 <f_lseek+0x112>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
 800460e:	2901      	cmp	r1, #1
 8004610:	d913      	bls.n	800463a <f_lseek+0xca>
 8004612:	6820      	ldr	r0, [r4, #0]
 8004614:	6942      	ldr	r2, [r0, #20]
 8004616:	4291      	cmp	r1, r2
 8004618:	d20f      	bcs.n	800463a <f_lseek+0xca>
					fp->clust = clst;
					fp->fptr += bcs;
 800461a:	68a3      	ldr	r3, [r4, #8]
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
 800461c:	6161      	str	r1, [r4, #20]
					fp->fptr += bcs;
 800461e:	19d8      	adds	r0, r3, r7
 8004620:	60a0      	str	r0, [r4, #8]
					ofs -= bcs;
 8004622:	1bed      	subs	r5, r5, r7
 8004624:	e7e1      	b.n	80045ea <f_lseek+0x7a>
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
						if (clst == 0) {				/* When disk gets full, clip file size */
 8004626:	463d      	mov	r5, r7
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
 8004628:	68a2      	ldr	r2, [r4, #8]
 800462a:	1953      	adds	r3, r2, r5
 800462c:	60a3      	str	r3, [r4, #8]
				if (ofs % SS(fp->fs)) {
 800462e:	05eb      	lsls	r3, r5, #23
 8004630:	d0ba      	beq.n	80045a8 <f_lseek+0x38>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
 8004632:	6820      	ldr	r0, [r4, #0]
 8004634:	f7ff f97e 	bl	8003934 <clust2sect>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
 8004638:	b908      	cbnz	r0, 800463e <f_lseek+0xce>
 800463a:	2602      	movs	r6, #2
 800463c:	e022      	b.n	8004684 <f_lseek+0x114>
					nsect += ofs / SS(fp->fs);
 800463e:	eb00 2555 	add.w	r5, r0, r5, lsr #9
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
 8004642:	68a1      	ldr	r1, [r4, #8]
 8004644:	05cb      	lsls	r3, r1, #23
 8004646:	d020      	beq.n	800468a <f_lseek+0x11a>
 8004648:	69a2      	ldr	r2, [r4, #24]
 800464a:	4295      	cmp	r5, r2
 800464c:	d01d      	beq.n	800468a <f_lseek+0x11a>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
 800464e:	79a0      	ldrb	r0, [r4, #6]
 8004650:	f000 0340 	and.w	r3, r0, #64	; 0x40
 8004654:	b2d9      	uxtb	r1, r3
 8004656:	b159      	cbz	r1, 8004670 <f_lseek+0x100>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
 8004658:	4621      	mov	r1, r4
 800465a:	f851 0b24 	ldr.w	r0, [r1], #36
 800465e:	2301      	movs	r3, #1
 8004660:	7840      	ldrb	r0, [r0, #1]
 8004662:	f000 fbc5 	bl	8004df0 <disk_write>
 8004666:	b960      	cbnz	r0, 8004682 <f_lseek+0x112>
					ABORT(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
 8004668:	79a2      	ldrb	r2, [r4, #6]
 800466a:	f022 0340 	bic.w	r3, r2, #64	; 0x40
 800466e:	71a3      	strb	r3, [r4, #6]
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1))	/* Fill sector cache */
 8004670:	4621      	mov	r1, r4
 8004672:	f851 0b24 	ldr.w	r0, [r1], #36
 8004676:	462a      	mov	r2, r5
 8004678:	7840      	ldrb	r0, [r0, #1]
 800467a:	2301      	movs	r3, #1
 800467c:	f000 fb76 	bl	8004d6c <disk_read>
 8004680:	b110      	cbz	r0, 8004688 <f_lseek+0x118>
				ABORT(fp->fs, FR_DISK_ERR);
 8004682:	2601      	movs	r6, #1
 8004684:	71e6      	strb	r6, [r4, #7]
 8004686:	e00b      	b.n	80046a0 <f_lseek+0x130>
#endif
			fp->dsect = nsect;
 8004688:	61a5      	str	r5, [r4, #24]
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
 800468a:	68a1      	ldr	r1, [r4, #8]
 800468c:	68e2      	ldr	r2, [r4, #12]
 800468e:	4291      	cmp	r1, r2
 8004690:	d906      	bls.n	80046a0 <f_lseek+0x130>
			fp->fsize = fp->fptr;
			fp->flag |= FA__WRITTEN;
 8004692:	79a3      	ldrb	r3, [r4, #6]
#endif
			fp->dsect = nsect;
		}
#if !_FS_READONLY
		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
			fp->fsize = fp->fptr;
 8004694:	60e1      	str	r1, [r4, #12]
			fp->flag |= FA__WRITTEN;
 8004696:	f043 0020 	orr.w	r0, r3, #32
 800469a:	71a0      	strb	r0, [r4, #6]
 800469c:	e000      	b.n	80046a0 <f_lseek+0x130>
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->err)						/* Check error */
 800469e:	461e      	mov	r6, r3
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
 80046a0:	4630      	mov	r0, r6
 80046a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080046a4 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80046a4:	b510      	push	{r4, lr}
 80046a6:	b086      	sub	sp, #24
 80046a8:	9101      	str	r1, [sp, #4]
	FRESULT res;
	FATFS* fs;
	DEF_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
 80046aa:	4604      	mov	r4, r0
 80046ac:	b348      	cbz	r0, 8004702 <f_opendir+0x5e>

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
 80046ae:	a802      	add	r0, sp, #8
 80046b0:	a901      	add	r1, sp, #4
 80046b2:	2200      	movs	r2, #0
 80046b4:	f7fe ffb4 	bl	8003620 <find_volume>
	if (res == FR_OK) {
 80046b8:	bb00      	cbnz	r0, 80046fc <f_opendir+0x58>
		dp->fs = fs;
 80046ba:	9b02      	ldr	r3, [sp, #8]
		INIT_BUF(*dp);
 80046bc:	a803      	add	r0, sp, #12
 80046be:	61a0      	str	r0, [r4, #24]
	if (!dp) return FR_INVALID_OBJECT;

	/* Get logical drive number */
	res = find_volume(&fs, &path, 0);
	if (res == FR_OK) {
		dp->fs = fs;
 80046c0:	6023      	str	r3, [r4, #0]
		INIT_BUF(*dp);
		res = follow_path(dp, path);			/* Follow the path to the directory */
 80046c2:	4620      	mov	r0, r4
 80046c4:	9901      	ldr	r1, [sp, #4]
 80046c6:	f7ff fb3d 	bl	8003d44 <follow_path>
		FREE_BUF();
		if (res == FR_OK) {						/* Follow completed */
 80046ca:	b990      	cbnz	r0, 80046f2 <f_opendir+0x4e>
			if (dp->dir) {						/* It is not the origin directory itself */
 80046cc:	6961      	ldr	r1, [r4, #20]
 80046ce:	b149      	cbz	r1, 80046e4 <f_opendir+0x40>
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
 80046d0:	7aca      	ldrb	r2, [r1, #11]
 80046d2:	f002 0310 	and.w	r3, r2, #16
 80046d6:	b2d8      	uxtb	r0, r3
 80046d8:	b178      	cbz	r0, 80046fa <f_opendir+0x56>
					dp->sclust = ld_clust(fs, dp->dir);
 80046da:	9a02      	ldr	r2, [sp, #8]
 80046dc:	7810      	ldrb	r0, [r2, #0]
 80046de:	f7fe feb7 	bl	8003450 <ld_clust.isra.0>
 80046e2:	60a0      	str	r0, [r4, #8]
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
 80046e4:	9902      	ldr	r1, [sp, #8]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 80046e6:	4620      	mov	r0, r4
					dp->sclust = ld_clust(fs, dp->dir);
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
 80046e8:	88cb      	ldrh	r3, [r1, #6]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 80046ea:	2100      	movs	r1, #0
					dp->sclust = ld_clust(fs, dp->dir);
				else							/* The object is a file */
					res = FR_NO_PATH;
			}
			if (res == FR_OK) {
				dp->id = fs->id;
 80046ec:	80a3      	strh	r3, [r4, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 80046ee:	f7ff f991 	bl	8003a14 <dir_sdi>
					}
				}
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 80046f2:	2804      	cmp	r0, #4
 80046f4:	d001      	beq.n	80046fa <f_opendir+0x56>
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
 80046f6:	b128      	cbz	r0, 8004704 <f_opendir+0x60>
 80046f8:	e000      	b.n	80046fc <f_opendir+0x58>
		if (res == FR_OK) {						/* Follow completed */
			if (dp->dir) {						/* It is not the origin directory itself */
				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
					dp->sclust = ld_clust(fs, dp->dir);
				else							/* The object is a file */
					res = FR_NO_PATH;
 80046fa:	2005      	movs	r0, #5
#endif
			}
		}
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
 80046fc:	2200      	movs	r2, #0
 80046fe:	6022      	str	r2, [r4, #0]
 8004700:	e000      	b.n	8004704 <f_opendir+0x60>
	FRESULT res;
	FATFS* fs;
	DEF_NAMEBUF;


	if (!dp) return FR_INVALID_OBJECT;
 8004702:	2009      	movs	r0, #9
		if (res == FR_NO_FILE) res = FR_NO_PATH;
	}
	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */

	LEAVE_FF(fs, res);
}
 8004704:	b006      	add	sp, #24
 8004706:	bd10      	pop	{r4, pc}

08004708 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 8004708:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800470a:	4604      	mov	r4, r0
 800470c:	460e      	mov	r6, r1
	FRESULT res;
	DEF_NAMEBUF;


	res = validate(dp);						/* Check validity of the object */
 800470e:	f7fe fe8a 	bl	8003426 <validate>
	if (res == FR_OK) {
 8004712:	4605      	mov	r5, r0
 8004714:	b9e8      	cbnz	r0, 8004752 <f_readdir+0x4a>
		if (!fno) {
 8004716:	b926      	cbnz	r6, 8004722 <f_readdir+0x1a>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8004718:	4620      	mov	r0, r4
 800471a:	4629      	mov	r1, r5
 800471c:	f7ff f97a 	bl	8003a14 <dir_sdi>
 8004720:	e016      	b.n	8004750 <f_readdir+0x48>
		} else {
			INIT_BUF(*dp);
 8004722:	ab01      	add	r3, sp, #4
 8004724:	61a3      	str	r3, [r4, #24]
			res = dir_read(dp, 0);			/* Read an item */
 8004726:	4620      	mov	r0, r4
 8004728:	f7ff fc02 	bl	8003f30 <dir_read.constprop.9>
			if (res == FR_NO_FILE) {		/* Reached end of directory */
 800472c:	2804      	cmp	r0, #4
 800472e:	d101      	bne.n	8004734 <f_readdir+0x2c>
				dp->sect = 0;
 8004730:	6125      	str	r5, [r4, #16]
 8004732:	e000      	b.n	8004736 <f_readdir+0x2e>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
 8004734:	b960      	cbnz	r0, 8004750 <f_readdir+0x48>
				get_fileinfo(dp, fno);		/* Get the object information */
 8004736:	4620      	mov	r0, r4
 8004738:	4631      	mov	r1, r6
 800473a:	f7fe fe30 	bl	800339e <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 800473e:	2100      	movs	r1, #0
 8004740:	4620      	mov	r0, r4
 8004742:	f7ff fa83 	bl	8003c4c <dir_next>
				if (res == FR_NO_FILE) {
 8004746:	2804      	cmp	r0, #4
 8004748:	d102      	bne.n	8004750 <f_readdir+0x48>
					dp->sect = 0;
 800474a:	2000      	movs	r0, #0
 800474c:	6120      	str	r0, [r4, #16]
 800474e:	e000      	b.n	8004752 <f_readdir+0x4a>
				res = FR_OK;
			}
			if (res == FR_OK) {				/* A valid entry is found */
				get_fileinfo(dp, fno);		/* Get the object information */
				res = dir_next(dp, 0);		/* Increment index for next */
				if (res == FR_NO_FILE) {
 8004750:	4605      	mov	r5, r0
			FREE_BUF();
		}
	}

	LEAVE_FF(dp->fs, res);
}
 8004752:	4628      	mov	r0, r5
 8004754:	b004      	add	sp, #16
 8004756:	bd70      	pop	{r4, r5, r6, pc}

08004758 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 8004758:	b530      	push	{r4, r5, lr}
 800475a:	b08d      	sub	sp, #52	; 0x34
 800475c:	9001      	str	r0, [sp, #4]
 800475e:	460d      	mov	r5, r1
	DIR dj;
	DEF_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
 8004760:	a805      	add	r0, sp, #20
 8004762:	a901      	add	r1, sp, #4
 8004764:	2200      	movs	r2, #0
 8004766:	f7fe ff5b 	bl	8003620 <find_volume>
	if (res == FR_OK) {
 800476a:	4604      	mov	r4, r0
 800476c:	b980      	cbnz	r0, 8004790 <f_stat+0x38>
		INIT_BUF(dj);
 800476e:	ab02      	add	r3, sp, #8
		res = follow_path(&dj, path);	/* Follow the file path */
 8004770:	a805      	add	r0, sp, #20
 8004772:	9901      	ldr	r1, [sp, #4]


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004774:	930b      	str	r3, [sp, #44]	; 0x2c
		res = follow_path(&dj, path);	/* Follow the file path */
 8004776:	f7ff fae5 	bl	8003d44 <follow_path>
		if (res == FR_OK) {				/* Follow completed */
 800477a:	4604      	mov	r4, r0
 800477c:	b940      	cbnz	r0, 8004790 <f_stat+0x38>
			if (dj.dir) {		/* Found an object */
 800477e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8004780:	b128      	cbz	r0, 800478e <f_stat+0x36>
				if (fno) get_fileinfo(&dj, fno);
 8004782:	b12d      	cbz	r5, 8004790 <f_stat+0x38>
 8004784:	a805      	add	r0, sp, #20
 8004786:	4629      	mov	r1, r5
 8004788:	f7fe fe09 	bl	800339e <get_fileinfo>
 800478c:	e000      	b.n	8004790 <f_stat+0x38>
			} else {			/* It is root directory */
				res = FR_INVALID_NAME;
 800478e:	2406      	movs	r4, #6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 8004790:	4620      	mov	r0, r4
 8004792:	b00d      	add	sp, #52	; 0x34
 8004794:	bd30      	pop	{r4, r5, pc}

08004796 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
 8004796:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 800479a:	ab02      	add	r3, sp, #8
 800479c:	f843 0d04 	str.w	r0, [r3, #-4]!
 80047a0:	4614      	mov	r4, r2
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
 80047a2:	4610      	mov	r0, r2
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
 80047a4:	4688      	mov	r8, r1
	UINT i;
	BYTE fat, *p;


	/* Get logical drive number */
	res = find_volume(fatfs, &path, 0);
 80047a6:	2200      	movs	r2, #0
 80047a8:	4619      	mov	r1, r3
 80047aa:	f7fe ff39 	bl	8003620 <find_volume>
	fs = *fatfs;
 80047ae:	6824      	ldr	r4, [r4, #0]
	if (res == FR_OK) {
 80047b0:	4605      	mov	r5, r0
 80047b2:	2800      	cmp	r0, #0
 80047b4:	d15d      	bne.n	8004872 <f_getfree+0xdc>
		/* If free_clust is valid, return it without full cluster scan */
		if (fs->free_clust <= fs->n_fatent - 2) {
 80047b6:	6967      	ldr	r7, [r4, #20]
 80047b8:	6920      	ldr	r0, [r4, #16]
 80047ba:	1eba      	subs	r2, r7, #2
 80047bc:	4290      	cmp	r0, r2
 80047be:	d802      	bhi.n	80047c6 <f_getfree+0x30>
			*nclst = fs->free_clust;
 80047c0:	f8c8 0000 	str.w	r0, [r8]
 80047c4:	e055      	b.n	8004872 <f_getfree+0xdc>
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
 80047c6:	f894 9000 	ldrb.w	r9, [r4]
			n = 0;
			if (fat == FS_FAT12) {
 80047ca:	f1b9 0f01 	cmp.w	r9, #1
 80047ce:	d110      	bne.n	80047f2 <f_getfree+0x5c>
 80047d0:	2702      	movs	r7, #2
 80047d2:	462e      	mov	r6, r5
				clst = 2;
				do {
					stat = get_fat(fs, clst);
 80047d4:	4639      	mov	r1, r7
 80047d6:	4620      	mov	r0, r4
 80047d8:	f7ff f8b8 	bl	800394c <get_fat>
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 80047dc:	1c41      	adds	r1, r0, #1
 80047de:	d03c      	beq.n	800485a <f_getfree+0xc4>
					if (stat == 1) { res = FR_INT_ERR; break; }
 80047e0:	2801      	cmp	r0, #1
 80047e2:	d03c      	beq.n	800485e <f_getfree+0xc8>
					if (stat == 0) n++;
 80047e4:	b900      	cbnz	r0, 80047e8 <f_getfree+0x52>
 80047e6:	3601      	adds	r6, #1
				} while (++clst < fs->n_fatent);
 80047e8:	6961      	ldr	r1, [r4, #20]
 80047ea:	3701      	adds	r7, #1
 80047ec:	428f      	cmp	r7, r1
 80047ee:	d3f1      	bcc.n	80047d4 <f_getfree+0x3e>
 80047f0:	e038      	b.n	8004864 <f_getfree+0xce>
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
 80047f2:	6a21      	ldr	r1, [r4, #32]
				i = 0; p = 0;
 80047f4:	462b      	mov	r3, r5
 80047f6:	462a      	mov	r2, r5
		if (fs->free_clust <= fs->n_fatent - 2) {
			*nclst = fs->free_clust;
		} else {
			/* Get number of free clusters */
			fat = fs->fs_type;
			n = 0;
 80047f8:	462e      	mov	r6, r5
			} else {
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
 80047fa:	b952      	cbnz	r2, 8004812 <f_getfree+0x7c>
						res = move_window(fs, sect++);
 80047fc:	4620      	mov	r0, r4
 80047fe:	f101 0a01 	add.w	sl, r1, #1
 8004802:	f7fe feb1 	bl	8003568 <move_window>
						if (res != FR_OK) break;
 8004806:	bb60      	cbnz	r0, 8004862 <f_getfree+0xcc>
						p = fs->win;
 8004808:	f104 0330 	add.w	r3, r4, #48	; 0x30
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
 800480c:	4651      	mov	r1, sl
						if (res != FR_OK) break;
						p = fs->win;
						i = SS(fs);
 800480e:	f44f 7200 	mov.w	r2, #512	; 0x200
					}
					if (fat == FS_FAT16) {
 8004812:	f1b9 0f02 	cmp.w	r9, #2
 8004816:	d109      	bne.n	800482c <f_getfree+0x96>
						if (LD_WORD(p) == 0) n++;
 8004818:	f893 e001 	ldrb.w	lr, [r3, #1]
 800481c:	7818      	ldrb	r0, [r3, #0]
 800481e:	ea50 200e 	orrs.w	r0, r0, lr, lsl #8
 8004822:	bf08      	it	eq
 8004824:	3601      	addeq	r6, #1
						p += 2; i -= 2;
 8004826:	3302      	adds	r3, #2
 8004828:	3a02      	subs	r2, #2
 800482a:	e013      	b.n	8004854 <f_getfree+0xbe>
					} else {
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
 800482c:	7898      	ldrb	r0, [r3, #2]
 800482e:	f893 c003 	ldrb.w	ip, [r3, #3]
 8004832:	0400      	lsls	r0, r0, #16
 8004834:	f893 e000 	ldrb.w	lr, [r3]
 8004838:	ea40 600c 	orr.w	r0, r0, ip, lsl #24
 800483c:	f893 c001 	ldrb.w	ip, [r3, #1]
 8004840:	ea40 000e 	orr.w	r0, r0, lr
 8004844:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
 8004848:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 800484c:	b900      	cbnz	r0, 8004850 <f_getfree+0xba>
 800484e:	3601      	adds	r6, #1
						p += 4; i -= 4;
 8004850:	3304      	adds	r3, #4
 8004852:	3a04      	subs	r2, #4
					}
				} while (--clst);
 8004854:	3f01      	subs	r7, #1
 8004856:	d1d0      	bne.n	80047fa <f_getfree+0x64>
 8004858:	e004      	b.n	8004864 <f_getfree+0xce>
			n = 0;
			if (fat == FS_FAT12) {
				clst = 2;
				do {
					stat = get_fat(fs, clst);
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 800485a:	2501      	movs	r5, #1
 800485c:	e002      	b.n	8004864 <f_getfree+0xce>
					if (stat == 1) { res = FR_INT_ERR; break; }
 800485e:	2502      	movs	r5, #2
 8004860:	e000      	b.n	8004864 <f_getfree+0xce>
				clst = fs->n_fatent;
				sect = fs->fatbase;
				i = 0; p = 0;
				do {
					if (!i) {
						res = move_window(fs, sect++);
 8004862:	4605      	mov	r5, r0
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
			fs->fsi_flag |= 1;
 8004864:	7963      	ldrb	r3, [r4, #5]
						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
						p += 4; i -= 4;
					}
				} while (--clst);
			}
			fs->free_clust = n;
 8004866:	6126      	str	r6, [r4, #16]
			fs->fsi_flag |= 1;
 8004868:	f043 0201 	orr.w	r2, r3, #1
 800486c:	7162      	strb	r2, [r4, #5]
			*nclst = n;
 800486e:	f8c8 6000 	str.w	r6, [r8]
		}
	}
	LEAVE_FF(fs, res);
}
 8004872:	4628      	mov	r0, r5
 8004874:	e8bd 87fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}

08004878 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 8004878:	b570      	push	{r4, r5, r6, lr}
 800487a:	b094      	sub	sp, #80	; 0x50
 800487c:	9001      	str	r0, [sp, #4]
	DWORD dclst;
	DEF_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
 800487e:	a901      	add	r1, sp, #4
 8004880:	a806      	add	r0, sp, #24
 8004882:	2201      	movs	r2, #1
 8004884:	f7fe fecc 	bl	8003620 <find_volume>
	if (res == FR_OK) {
 8004888:	4604      	mov	r4, r0
 800488a:	2800      	cmp	r0, #0
 800488c:	d14b      	bne.n	8004926 <f_unlink+0xae>
		INIT_BUF(dj);
 800488e:	ab03      	add	r3, sp, #12
		res = follow_path(&dj, path);		/* Follow the file path */
 8004890:	a806      	add	r0, sp, #24
 8004892:	9901      	ldr	r1, [sp, #4]


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 1);
	if (res == FR_OK) {
		INIT_BUF(dj);
 8004894:	930c      	str	r3, [sp, #48]	; 0x30
		res = follow_path(&dj, path);		/* Follow the file path */
 8004896:	f7ff fa55 	bl	8003d44 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
#if _FS_LOCK
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
 800489a:	4604      	mov	r4, r0
 800489c:	2800      	cmp	r0, #0
 800489e:	d142      	bne.n	8004926 <f_unlink+0xae>
			dir = dj.dir;
 80048a0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
			if (!dir) {
 80048a2:	b136      	cbz	r6, 80048b2 <f_unlink+0x3a>
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
			} else {
				if (dir[DIR_Attr] & AM_RDO)
 80048a4:	7af0      	ldrb	r0, [r6, #11]
					res = FR_DENIED;		/* Cannot remove R/O object */
 80048a6:	f010 0f01 	tst.w	r0, #1
 80048aa:	bf0c      	ite	eq
 80048ac:	2400      	moveq	r4, #0
 80048ae:	2407      	movne	r4, #7
 80048b0:	e000      	b.n	80048b4 <f_unlink+0x3c>
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
#endif
		if (res == FR_OK) {					/* The object is accessible */
			dir = dj.dir;
			if (!dir) {
				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
 80048b2:	2406      	movs	r4, #6
			} else {
				if (dir[DIR_Attr] & AM_RDO)
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
 80048b4:	9906      	ldr	r1, [sp, #24]
 80048b6:	7808      	ldrb	r0, [r1, #0]
 80048b8:	4631      	mov	r1, r6
 80048ba:	f7fe fdc9 	bl	8003450 <ld_clust.isra.0>
 80048be:	4605      	mov	r5, r0
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
 80048c0:	2c00      	cmp	r4, #0
 80048c2:	d130      	bne.n	8004926 <f_unlink+0xae>
 80048c4:	7af2      	ldrb	r2, [r6, #11]
 80048c6:	f002 0410 	and.w	r4, r2, #16
 80048ca:	b2e3      	uxtb	r3, r4
 80048cc:	b1cb      	cbz	r3, 8004902 <f_unlink+0x8a>
				if (dclst < 2) {
 80048ce:	2801      	cmp	r0, #1
 80048d0:	d913      	bls.n	80048fa <f_unlink+0x82>
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-directory is empty or not */
 80048d2:	a80d      	add	r0, sp, #52	; 0x34
 80048d4:	a906      	add	r1, sp, #24
 80048d6:	221c      	movs	r2, #28
 80048d8:	f7fe fd58 	bl	800338c <mem_cpy>
					sdj.sclust = dclst;
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 80048dc:	a80d      	add	r0, sp, #52	; 0x34
 80048de:	2102      	movs	r1, #2
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
					res = FR_INT_ERR;
				} else {
					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-directory is empty or not */
					sdj.sclust = dclst;
 80048e0:	950f      	str	r5, [sp, #60]	; 0x3c
					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
 80048e2:	f7ff f897 	bl	8003a14 <dir_sdi>
					if (res == FR_OK) {
 80048e6:	4604      	mov	r4, r0
 80048e8:	b9e8      	cbnz	r0, 8004926 <f_unlink+0xae>
						res = dir_read(&sdj, 0);	/* Read an item */
 80048ea:	a80d      	add	r0, sp, #52	; 0x34
 80048ec:	f7ff fb20 	bl	8003f30 <dir_read.constprop.9>
						if (res == FR_OK		/* Not empty directory */
 80048f0:	4604      	mov	r4, r0
 80048f2:	b120      	cbz	r0, 80048fe <f_unlink+0x86>
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current directory */
#endif
						) res = FR_DENIED;
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
 80048f4:	2804      	cmp	r0, #4
 80048f6:	d004      	beq.n	8004902 <f_unlink+0x8a>
 80048f8:	e015      	b.n	8004926 <f_unlink+0xae>
					res = FR_DENIED;		/* Cannot remove R/O object */
			}
			dclst = ld_clust(dj.fs, dir);
			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
				if (dclst < 2) {
					res = FR_INT_ERR;
 80048fa:	2402      	movs	r4, #2
 80048fc:	e013      	b.n	8004926 <f_unlink+0xae>
						res = dir_read(&sdj, 0);	/* Read an item */
						if (res == FR_OK		/* Not empty directory */
#if _FS_RPATH
						|| dclst == dj.fs->cdir	/* Current directory */
#endif
						) res = FR_DENIED;
 80048fe:	2407      	movs	r4, #7
 8004900:	e011      	b.n	8004926 <f_unlink+0xae>
						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
					}
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
 8004902:	a806      	add	r0, sp, #24
 8004904:	f7ff f8c8 	bl	8003a98 <dir_remove>
				if (res == FR_OK) {
 8004908:	4604      	mov	r4, r0
 800490a:	b960      	cbnz	r0, 8004926 <f_unlink+0xae>
					if (dclst)				/* Remove the cluster chain if exist */
 800490c:	b925      	cbnz	r5, 8004918 <f_unlink+0xa0>
						res = remove_chain(dj.fs, dclst);
					if (res == FR_OK) res = sync_fs(dj.fs);
 800490e:	9806      	ldr	r0, [sp, #24]
 8004910:	f7fe fdd1 	bl	80034b6 <sync_fs>
 8004914:	4604      	mov	r4, r0
 8004916:	e006      	b.n	8004926 <f_unlink+0xae>
			}
			if (res == FR_OK) {
				res = dir_remove(&dj);		/* Remove the directory entry */
				if (res == FR_OK) {
					if (dclst)				/* Remove the cluster chain if exist */
						res = remove_chain(dj.fs, dclst);
 8004918:	9806      	ldr	r0, [sp, #24]
 800491a:	4629      	mov	r1, r5
 800491c:	f7ff fb5e 	bl	8003fdc <remove_chain>
					if (res == FR_OK) res = sync_fs(dj.fs);
 8004920:	4604      	mov	r4, r0
 8004922:	2800      	cmp	r0, #0
 8004924:	d0f3      	beq.n	800490e <f_unlink+0x96>
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
 8004926:	4620      	mov	r0, r4
 8004928:	b014      	add	sp, #80	; 0x50
 800492a:	bd70      	pop	{r4, r5, r6, pc}

0800492c <stm32_spi_rw>:

@param[in] out: BYTE value to send.
*/

static BYTE stm32_spi_rw( BYTE out )
{
 800492c:	4601      	mov	r1, r0
 800492e:	b508      	push	{r3, lr}
    return spi_xfer(SPI_SD,out);
 8004930:	4802      	ldr	r0, [pc, #8]	; (800493c <stm32_spi_rw+0x10>)
 8004932:	f002 fadd 	bl	8006ef0 <spi_xfer>
}
 8004936:	b2c0      	uxtb	r0, r0
 8004938:	bd08      	pop	{r3, pc}
 800493a:	bf00      	nop
 800493c:	40003800 	.word	0x40003800

08004940 <rcvr_spi>:
@returns BYTE value received.
*/

static BYTE rcvr_spi(void)
{
	return stm32_spi_rw(0xff);
 8004940:	20ff      	movs	r0, #255	; 0xff
 8004942:	f7ff bff3 	b.w	800492c <stm32_spi_rw>
	...

08004948 <release_spi>:
/** @brief Deselect the card and release SPI bus

*/

static void release_spi(void)
{
 8004948:	b508      	push	{r3, lr}
	DESELECT();
 800494a:	4804      	ldr	r0, [pc, #16]	; (800495c <release_spi+0x14>)
 800494c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004950:	f002 fa3c 	bl	8006dcc <gpio_set>
	rcvr_spi();
}
 8004954:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
*/

static void release_spi(void)
{
	DESELECT();
	rcvr_spi();
 8004958:	f7ff bff2 	b.w	8004940 <rcvr_spi>
 800495c:	40010c00 	.word	0x40010c00

08004960 <xmit_datablock.part.3>:
@param *buff: BYTE 512 byte data block to be transmitted
@param token: BYTE Data/Stop token
*/

#if _FS_READONLY == 0
static BOOL xmit_datablock (const BYTE *buff,BYTE token)
 8004960:	b538      	push	{r3, r4, r5, lr}
 8004962:	4605      	mov	r5, r0
 8004964:	2400      	movs	r4, #0
		stm32_dma_transfer( FALSE, buff, 512 );
#else
		wc = 0;
		do
        {							/* transmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
 8004966:	5d28      	ldrb	r0, [r5, r4]
 8004968:	f7ff ffe0 	bl	800492c <stm32_spi_rw>
@param *buff: BYTE 512 byte data block to be transmitted
@param token: BYTE Data/Stop token
*/

#if _FS_READONLY == 0
static BOOL xmit_datablock (const BYTE *buff,BYTE token)
 800496c:	192b      	adds	r3, r5, r4
#else
		wc = 0;
		do
        {							/* transmit the 512 byte data block to MMC */
			xmit_spi(*buff++);
			xmit_spi(*buff++);
 800496e:	7858      	ldrb	r0, [r3, #1]
 8004970:	3402      	adds	r4, #2
 8004972:	f7ff ffdb 	bl	800492c <stm32_spi_rw>
		}
        while (--wc);
 8004976:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 800497a:	d1f4      	bne.n	8004966 <xmit_datablock.part.3+0x6>
#endif /* STM32_SD_USE_DMA */

		xmit_spi(0xFF);					/* CRC (Dummy) */
 800497c:	20ff      	movs	r0, #255	; 0xff
 800497e:	f7ff ffd5 	bl	800492c <stm32_spi_rw>
		xmit_spi(0xFF);
 8004982:	20ff      	movs	r0, #255	; 0xff
 8004984:	f7ff ffd2 	bl	800492c <stm32_spi_rw>
		resp = rcvr_spi();				/* Receive data response */
 8004988:	f7ff ffda 	bl	8004940 <rcvr_spi>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
 800498c:	f000 001f 	and.w	r0, r0, #31
			return FALSE;
        }
	}

	return TRUE;
}
 8004990:	1f41      	subs	r1, r0, #5
 8004992:	424a      	negs	r2, r1
 8004994:	eb52 0001 	adcs.w	r0, r2, r1
 8004998:	bd38      	pop	{r3, r4, r5, pc}
	...

0800499c <timeout>:
BOOL timeout(DWORD timer, DWORD delay)
{
#if _FS_REENTRANT
    vTaskDelay(1);                   /* relinquish for 1 tick */
#endif
    if (Timer1 > timer) return (Timer1-timer > delay);
 800499c:	4b09      	ldr	r3, [pc, #36]	; (80049c4 <timeout+0x28>)
 800499e:	681a      	ldr	r2, [r3, #0]
 80049a0:	4282      	cmp	r2, r0
 80049a2:	d903      	bls.n	80049ac <timeout+0x10>
 80049a4:	681b      	ldr	r3, [r3, #0]
 80049a6:	1a18      	subs	r0, r3, r0
 80049a8:	4288      	cmp	r0, r1
 80049aa:	e004      	b.n	80049b6 <timeout+0x1a>
    else if (timer+delay > timer) return false;
 80049ac:	1809      	adds	r1, r1, r0
 80049ae:	4281      	cmp	r1, r0
 80049b0:	d805      	bhi.n	80049be <timeout+0x22>
    else return (timer+delay > Timer1);
 80049b2:	6818      	ldr	r0, [r3, #0]
 80049b4:	4281      	cmp	r1, r0
 80049b6:	bf94      	ite	ls
 80049b8:	2000      	movls	r0, #0
 80049ba:	2001      	movhi	r0, #1
 80049bc:	4770      	bx	lr
{
#if _FS_REENTRANT
    vTaskDelay(1);                   /* relinquish for 1 tick */
#endif
    if (Timer1 > timer) return (Timer1-timer > delay);
    else if (timer+delay > timer) return false;
 80049be:	2000      	movs	r0, #0
    else return (timer+delay > Timer1);
}
 80049c0:	4770      	bx	lr
 80049c2:	bf00      	nop
 80049c4:	20001118 	.word	0x20001118

080049c8 <power_on>:

All peripherals are initialised and the power is turned on to the card.
*/

static void power_on (void)
{
 80049c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	volatile BYTE dummyread;

	/* Enable GPIO clock for CS */
	rcc_peripheral_enable_clock(&RCC_GPIO, RCC_GPIO_PORT_CS);
 80049ca:	482c      	ldr	r0, [pc, #176]	; (8004a7c <power_on+0xb4>)
 80049cc:	2108      	movs	r1, #8
 80049ce:	f002 fc8a 	bl	80072e6 <rcc_peripheral_enable_clock>
	/* Enable SPI clock, SPI1: APB2, SPI2: APB1 */
	rcc_peripheral_enable_clock(&RCC_SPI, RCC_SPI_SD);
 80049d2:	482b      	ldr	r0, [pc, #172]	; (8004a80 <power_on+0xb8>)
 80049d4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80049d8:	f002 fc85 	bl	80072e6 <rcc_peripheral_enable_clock>
	socket_wp_init();

#if _FS_REENTRANT
    vTaskDelay(250);
#else
    DWORD timer = Timer1;
 80049dc:	4b29      	ldr	r3, [pc, #164]	; (8004a84 <power_on+0xbc>)
 80049de:	681c      	ldr	r4, [r3, #0]
	while (!timeout(timer,25));	        /* Wait for 250ms */
 80049e0:	4620      	mov	r0, r4
 80049e2:	2119      	movs	r1, #25
 80049e4:	f7ff ffda 	bl	800499c <timeout>
 80049e8:	2800      	cmp	r0, #0
 80049ea:	d0f9      	beq.n	80049e0 <power_on+0x18>
#endif

	/* Configure I/O for Card Chip select */
    gpio_set_mode(GPIO_PORT_CS, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_PUSHPULL,
 80049ec:	2200      	movs	r2, #0
 80049ee:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
 80049f2:	4825      	ldr	r0, [pc, #148]	; (8004a88 <power_on+0xc0>)
 80049f4:	2103      	movs	r1, #3
 80049f6:	f001 ff4d 	bl	8006894 <gpio_set_mode>
			    GPIOCS | GPIOSPI_SD_MISO);

	/* De-select the Card: Chip Select high */
	DESELECT();
 80049fa:	4823      	ldr	r0, [pc, #140]	; (8004a88 <power_on+0xc0>)
 80049fc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004a00:	f002 f9e4 	bl	8006dcc <gpio_set>

	/* Configure SPI pins: SCK and MOSI with default alternate function (not re-mapped) push-pull */
    gpio_set_mode(GPIO_PORT_SPI_SD, GPIO_MODE_OUTPUT_50_MHZ, GPIO_CNF_OUTPUT_ALTFN_PUSHPULL,
 8004a04:	4820      	ldr	r0, [pc, #128]	; (8004a88 <power_on+0xc0>)
 8004a06:	2103      	movs	r1, #3
 8004a08:	2202      	movs	r2, #2
 8004a0a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 8004a0e:	f001 ff41 	bl	8006894 <gpio_set_mode>
			    GPIOSPI_SD_SCK | GPIOSPI_SD_MOSI);
	/* Configure MISO as Input with internal pull-up */
    gpio_set_mode(GPIO_PORT_SPI_SD, GPIO_MODE_INPUT, GPIO_CNF_INPUT_PULL_UPDOWN,
 8004a12:	2202      	movs	r2, #2
 8004a14:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8004a18:	481b      	ldr	r0, [pc, #108]	; (8004a88 <power_on+0xc0>)
 8004a1a:	2100      	movs	r1, #0
 8004a1c:	f001 ff3a 	bl	8006894 <gpio_set_mode>
			    GPIOSPI_SD_MISO);

    /* Set the pull-up/pull-down resistors to pull-up for the MISO input
       in case board has no external resistor*/
    gpio_set(GPIO_PORT_SPI_SD,GPIOSPI_SD_MISO);
 8004a20:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8004a24:	4818      	ldr	r0, [pc, #96]	; (8004a88 <power_on+0xc0>)
 8004a26:	f002 f9d1 	bl	8006dcc <gpio_set>

    /* Clear all SPI and associated RCC registers */
	spi_reset(SPI_SD);
 8004a2a:	4818      	ldr	r0, [pc, #96]	; (8004a8c <power_on+0xc4>)
 8004a2c:	f002 fa3e 	bl	8006eac <spi_reset>

	/* SPI configuration */
	spi_init_master(SPI_SD, SPI_CR1_BAUDRATE_FPCLK_DIV_256, SPI_CR1_CPOL_CLK_TO_0_WHEN_IDLE,
 8004a30:	2200      	movs	r2, #0
 8004a32:	2138      	movs	r1, #56	; 0x38
 8004a34:	9200      	str	r2, [sp, #0]
 8004a36:	9201      	str	r2, [sp, #4]
 8004a38:	4613      	mov	r3, r2
 8004a3a:	4814      	ldr	r0, [pc, #80]	; (8004a8c <power_on+0xc4>)
 8004a3c:	f002 fa7d 	bl	8006f3a <spi_init_master>
			SPI_CR1_CPHA_CLK_TRANSITION_1, SPI_CR1_DFF_8BIT, SPI_CR1_MSBFIRST);
    spi_set_full_duplex_mode(SPI_SD);
 8004a40:	4812      	ldr	r0, [pc, #72]	; (8004a8c <power_on+0xc4>)
 8004a42:	f002 fa61 	bl	8006f08 <spi_set_full_duplex_mode>
	 * Note:
	 * Setting nss high is very important, even if we are controlling the GPIO
	 * ourselves this bit needs to be at least set to 1, otherwise the spi
	 * peripheral will not send any data out.
	 */
	spi_enable_software_slave_management(SPI_SD);
 8004a46:	4811      	ldr	r0, [pc, #68]	; (8004a8c <power_on+0xc4>)
 8004a48:	f002 fa63 	bl	8006f12 <spi_enable_software_slave_management>
	spi_set_nss_high(SPI_SD);
 8004a4c:	480f      	ldr	r0, [pc, #60]	; (8004a8c <power_on+0xc4>)
 8004a4e:	f002 fa65 	bl	8006f1c <spi_set_nss_high>
    spi_disable_crc(SPI_SD);
 8004a52:	480e      	ldr	r0, [pc, #56]	; (8004a8c <power_on+0xc4>)
 8004a54:	f002 fa53 	bl	8006efe <spi_disable_crc>

	spi_enable(SPI_SD);
 8004a58:	480c      	ldr	r0, [pc, #48]	; (8004a8c <power_on+0xc4>)
 8004a5a:	f002 fa3f 	bl	8006edc <spi_enable>

    gpio_clear(GPIOB, GPIO12);
 8004a5e:	480a      	ldr	r0, [pc, #40]	; (8004a88 <power_on+0xc0>)
 8004a60:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004a64:	f002 f9b4 	bl	8006dd0 <gpio_clear>

	/* drain SPI */
	while (!(SPI_SR(SPI_SD) & SPI_SR_TXE));
 8004a68:	4809      	ldr	r0, [pc, #36]	; (8004a90 <power_on+0xc8>)
 8004a6a:	6801      	ldr	r1, [r0, #0]
 8004a6c:	078a      	lsls	r2, r1, #30
 8004a6e:	d5fb      	bpl.n	8004a68 <power_on+0xa0>
	dummyread = SPI_DR(SPI_SD);
 8004a70:	4a08      	ldr	r2, [pc, #32]	; (8004a94 <power_on+0xcc>)
 8004a72:	6813      	ldr	r3, [r2, #0]
 8004a74:	b2d8      	uxtb	r0, r3
 8004a76:	f88d 000f 	strb.w	r0, [sp, #15]

#ifdef STM32_SD_USE_DMA
	/* enable DMA clock */
	rcc_peripheral_enable_clock(&RCC_AHBENR, RCC_AHBENR_DMA1EN);
#endif
}
 8004a7a:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8004a7c:	40021018 	.word	0x40021018
 8004a80:	4002101c 	.word	0x4002101c
 8004a84:	20001118 	.word	0x20001118
 8004a88:	40010c00 	.word	0x40010c00
 8004a8c:	40003800 	.word	0x40003800
 8004a90:	40003808 	.word	0x40003808
 8004a94:	4000380c 	.word	0x4000380c

08004a98 <wait_ready>:

@returns BYTE value of a status result. 0xFF means success, otherwise timeout.
*/

static BYTE wait_ready(void)
{
 8004a98:	b538      	push	{r3, r4, r5, lr}
	BYTE res;

	DWORD timer = Timer1;	        /* Wait for ready in timeout of 500ms */
 8004a9a:	4b08      	ldr	r3, [pc, #32]	; (8004abc <wait_ready+0x24>)
 8004a9c:	681d      	ldr	r5, [r3, #0]
	rcvr_spi();
 8004a9e:	f7ff ff4f 	bl	8004940 <rcvr_spi>
	do
    {
		res = rcvr_spi();
 8004aa2:	f7ff ff4d 	bl	8004940 <rcvr_spi>
    }
	while ((res != 0xFF) && !timeout(timer,50));
 8004aa6:	28ff      	cmp	r0, #255	; 0xff

	DWORD timer = Timer1;	        /* Wait for ready in timeout of 500ms */
	rcvr_spi();
	do
    {
		res = rcvr_spi();
 8004aa8:	4604      	mov	r4, r0
    }
	while ((res != 0xFF) && !timeout(timer,50));
 8004aaa:	d005      	beq.n	8004ab8 <wait_ready+0x20>
 8004aac:	4628      	mov	r0, r5
 8004aae:	2132      	movs	r1, #50	; 0x32
 8004ab0:	f7ff ff74 	bl	800499c <timeout>
 8004ab4:	2800      	cmp	r0, #0
 8004ab6:	d0f4      	beq.n	8004aa2 <wait_ready+0xa>

	return res;
}
 8004ab8:	4620      	mov	r0, r4
 8004aba:	bd38      	pop	{r3, r4, r5, pc}
 8004abc:	20001118 	.word	0x20001118

08004ac0 <power_off>:
All peripherals are disabled and the power is turned off to the card.
*/

static
void power_off (void)
{
 8004ac0:	b508      	push	{r3, lr}
	if (!(Stat & STA_NOINIT)) {
 8004ac2:	4b11      	ldr	r3, [pc, #68]	; (8004b08 <power_off+0x48>)
 8004ac4:	7818      	ldrb	r0, [r3, #0]
 8004ac6:	07c1      	lsls	r1, r0, #31
 8004ac8:	d408      	bmi.n	8004adc <power_off+0x1c>
		SELECT();
 8004aca:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004ace:	480f      	ldr	r0, [pc, #60]	; (8004b0c <power_off+0x4c>)
 8004ad0:	f002 f97e 	bl	8006dd0 <gpio_clear>
		wait_ready();
 8004ad4:	f7ff ffe0 	bl	8004a98 <wait_ready>
		release_spi();
 8004ad8:	f7ff ff36 	bl	8004948 <release_spi>
	}

	spi_disable(SPI_SD);
 8004adc:	480c      	ldr	r0, [pc, #48]	; (8004b10 <power_off+0x50>)
 8004ade:	f002 fa02 	bl	8006ee6 <spi_disable>
	rcc_peripheral_disable_clock(&RCC_SPI, RCC_SPI_SD);
 8004ae2:	480c      	ldr	r0, [pc, #48]	; (8004b14 <power_off+0x54>)
 8004ae4:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8004ae8:	f002 fc01 	bl	80072ee <rcc_peripheral_disable_clock>

	/* All SPI-Pins to input with weak internal pull-downs */
    gpio_set_mode(GPIO_PORT_SPI_SD, GPIO_MODE_INPUT, GPIO_CNF_INPUT_PULL_UPDOWN,
 8004aec:	2100      	movs	r1, #0
 8004aee:	2202      	movs	r2, #2
 8004af0:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 8004af4:	4805      	ldr	r0, [pc, #20]	; (8004b0c <power_off+0x4c>)
 8004af6:	f001 fecd 	bl	8006894 <gpio_set_mode>
			    GPIOSPI_SD_SCK | GPIOSPI_SD_MISO | GPIOSPI_SD_MOSI);

	card_power(0);

	Stat |= STA_NOINIT;		/* Set STA_NOINIT */
 8004afa:	4903      	ldr	r1, [pc, #12]	; (8004b08 <power_off+0x48>)
 8004afc:	780a      	ldrb	r2, [r1, #0]
 8004afe:	f042 0301 	orr.w	r3, r2, #1
 8004b02:	700b      	strb	r3, [r1, #0]
 8004b04:	bd08      	pop	{r3, pc}
 8004b06:	bf00      	nop
 8004b08:	20000001 	.word	0x20000001
 8004b0c:	40010c00 	.word	0x40010c00
 8004b10:	40003800 	.word	0x40003800
 8004b14:	4002101c 	.word	0x4002101c

08004b18 <send_cmd>:
static BYTE send_cmd (BYTE cmd,DWORD arg)
{
	BYTE n, res;

    /* ACMD<n> is the command sequence of CMD55-CMD<n> */
	if (cmd & 0x80)
 8004b18:	0602      	lsls	r2, r0, #24
@param arg: DWORD argument for command
@returns BYTE response
*/

static BYTE send_cmd (BYTE cmd,DWORD arg)
{
 8004b1a:	b538      	push	{r3, r4, r5, lr}
 8004b1c:	4604      	mov	r4, r0
 8004b1e:	460d      	mov	r5, r1
	BYTE n, res;

    /* ACMD<n> is the command sequence of CMD55-CMD<n> */
	if (cmd & 0x80)
 8004b20:	d507      	bpl.n	8004b32 <send_cmd+0x1a>
    {
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
 8004b22:	2077      	movs	r0, #119	; 0x77
 8004b24:	2100      	movs	r1, #0
 8004b26:	f7ff fff7 	bl	8004b18 <send_cmd>
		if (res > 1) return res;
 8004b2a:	2801      	cmp	r0, #1
 8004b2c:	d839      	bhi.n	8004ba2 <send_cmd+0x8a>
	BYTE n, res;

    /* ACMD<n> is the command sequence of CMD55-CMD<n> */
	if (cmd & 0x80)
    {
		cmd &= 0x7F;
 8004b2e:	f004 047f 	and.w	r4, r4, #127	; 0x7f
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
	}

	/* Select the card and wait for ready */
	DESELECT();
 8004b32:	481c      	ldr	r0, [pc, #112]	; (8004ba4 <send_cmd+0x8c>)
 8004b34:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004b38:	f002 f948 	bl	8006dcc <gpio_set>
	SELECT();
 8004b3c:	4819      	ldr	r0, [pc, #100]	; (8004ba4 <send_cmd+0x8c>)
 8004b3e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004b42:	f002 f945 	bl	8006dd0 <gpio_clear>
	if (wait_ready() != 0xFF)
 8004b46:	f7ff ffa7 	bl	8004a98 <wait_ready>
 8004b4a:	28ff      	cmp	r0, #255	; 0xff
 8004b4c:	d128      	bne.n	8004ba0 <send_cmd+0x88>
    {
		return 0xFF;
	}

	/* Send command packet */
	xmit_spi(cmd);						/* Start + Command index */
 8004b4e:	4620      	mov	r0, r4
 8004b50:	f7ff feec 	bl	800492c <stm32_spi_rw>
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 8004b54:	0e28      	lsrs	r0, r5, #24
 8004b56:	f7ff fee9 	bl	800492c <stm32_spi_rw>
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
 8004b5a:	f3c5 4007 	ubfx	r0, r5, #16, #8
 8004b5e:	f7ff fee5 	bl	800492c <stm32_spi_rw>
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
 8004b62:	f3c5 2007 	ubfx	r0, r5, #8, #8
 8004b66:	f7ff fee1 	bl	800492c <stm32_spi_rw>
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
 8004b6a:	b2e8      	uxtb	r0, r5
 8004b6c:	f7ff fede 	bl	800492c <stm32_spi_rw>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 8004b70:	2c40      	cmp	r4, #64	; 0x40
 8004b72:	d004      	beq.n	8004b7e <send_cmd+0x66>
	xmit_spi(cmd);						/* Start + Command index */
	xmit_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
 8004b74:	2c48      	cmp	r4, #72	; 0x48
 8004b76:	bf0c      	ite	eq
 8004b78:	2087      	moveq	r0, #135	; 0x87
 8004b7a:	2001      	movne	r0, #1
 8004b7c:	e000      	b.n	8004b80 <send_cmd+0x68>
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 8004b7e:	2095      	movs	r0, #149	; 0x95
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xmit_spi(n);
 8004b80:	f7ff fed4 	bl	800492c <stm32_spi_rw>

	/* Receive command response */
	if (cmd == CMD12) rcvr_spi();		/* Skip a stuff byte when stop reading */
 8004b84:	2c4c      	cmp	r4, #76	; 0x4c
 8004b86:	d101      	bne.n	8004b8c <send_cmd+0x74>
 8004b88:	f7ff feda 	bl	8004940 <rcvr_spi>
	xmit_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xmit_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xmit_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 8004b8c:	240a      	movs	r4, #10

    /* Wait for a valid response in timeout of 10 attempts */
	n = 10;
	do
    {
		res = rcvr_spi();
 8004b8e:	f7ff fed7 	bl	8004940 <rcvr_spi>
    }
	while ((res & 0x80) && --n);
 8004b92:	0603      	lsls	r3, r0, #24
 8004b94:	d505      	bpl.n	8004ba2 <send_cmd+0x8a>
 8004b96:	3c01      	subs	r4, #1
 8004b98:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8004b9c:	d1f7      	bne.n	8004b8e <send_cmd+0x76>
 8004b9e:	bd38      	pop	{r3, r4, r5, pc}
	/* Select the card and wait for ready */
	DESELECT();
	SELECT();
	if (wait_ready() != 0xFF)
    {
		return 0xFF;
 8004ba0:	20ff      	movs	r0, #255	; 0xff
		res = rcvr_spi();
    }
	while ((res & 0x80) && --n);

	return res;			                /* Return with the response value */
}
 8004ba2:	bd38      	pop	{r3, r4, r5, pc}
 8004ba4:	40010c00 	.word	0x40010c00

08004ba8 <rcvr_datablock>:

static BOOL rcvr_datablock (BYTE *buff,UINT btr)
{
	BYTE token;

	DWORD timer = Timer1;
 8004ba8:	4b16      	ldr	r3, [pc, #88]	; (8004c04 <rcvr_datablock+0x5c>)
@param *buff: BYTE 512 byte data block to store received data 
@param btr: UINT Byte count (must be multiple of 4)
*/

static BOOL rcvr_datablock (BYTE *buff,UINT btr)
{
 8004baa:	b570      	push	{r4, r5, r6, lr}
	BYTE token;

	DWORD timer = Timer1;
 8004bac:	681c      	ldr	r4, [r3, #0]
@param *buff: BYTE 512 byte data block to store received data 
@param btr: UINT Byte count (must be multiple of 4)
*/

static BOOL rcvr_datablock (BYTE *buff,UINT btr)
{
 8004bae:	4605      	mov	r5, r0
 8004bb0:	460e      	mov	r6, r1
	BYTE token;

	DWORD timer = Timer1;
	do
    {							/* Wait for data packet in timeout of 100ms */
		token = rcvr_spi();
 8004bb2:	f7ff fec5 	bl	8004940 <rcvr_spi>
	}
    while ((token == 0xFF) && !timeout(timer,10));
 8004bb6:	28ff      	cmp	r0, #255	; 0xff
 8004bb8:	d107      	bne.n	8004bca <rcvr_datablock+0x22>
 8004bba:	4620      	mov	r0, r4
 8004bbc:	210a      	movs	r1, #10
 8004bbe:	f7ff feed 	bl	800499c <timeout>
 8004bc2:	2800      	cmp	r0, #0
 8004bc4:	d0f5      	beq.n	8004bb2 <rcvr_datablock+0xa>
	if(token != 0xFE) return FALSE;	/* If not valid data token, return with error */
 8004bc6:	2000      	movs	r0, #0
 8004bc8:	bd70      	pop	{r4, r5, r6, pc}
 8004bca:	28fe      	cmp	r0, #254	; 0xfe
 8004bcc:	d1fb      	bne.n	8004bc6 <rcvr_datablock+0x1e>
 8004bce:	462c      	mov	r4, r5
#ifdef STM32_SD_USE_DMA
	stm32_dma_transfer( TRUE, buff, btr );
#else
	do
    {							/* Receive the data block into buffer */
		rcvr_spi_m(buff++);
 8004bd0:	20ff      	movs	r0, #255	; 0xff
 8004bd2:	f7ff feab 	bl	800492c <stm32_spi_rw>
 8004bd6:	7020      	strb	r0, [r4, #0]
		rcvr_spi_m(buff++);
 8004bd8:	20ff      	movs	r0, #255	; 0xff
 8004bda:	f7ff fea7 	bl	800492c <stm32_spi_rw>
 8004bde:	7060      	strb	r0, [r4, #1]
		rcvr_spi_m(buff++);
 8004be0:	20ff      	movs	r0, #255	; 0xff
 8004be2:	f7ff fea3 	bl	800492c <stm32_spi_rw>
 8004be6:	70a0      	strb	r0, [r4, #2]
		rcvr_spi_m(buff++);
 8004be8:	20ff      	movs	r0, #255	; 0xff
 8004bea:	f7ff fe9f 	bl	800492c <stm32_spi_rw>
 8004bee:	70e0      	strb	r0, [r4, #3]

@param *buff: BYTE 512 byte data block to store received data 
@param btr: UINT Byte count (must be multiple of 4)
*/

static BOOL rcvr_datablock (BYTE *buff,UINT btr)
 8004bf0:	3404      	adds	r4, #4
 8004bf2:	19a8      	adds	r0, r5, r6
		rcvr_spi_m(buff++);
		rcvr_spi_m(buff++);
		rcvr_spi_m(buff++);
		rcvr_spi_m(buff++);
	}
    while (btr -= 4);
 8004bf4:	42a0      	cmp	r0, r4
 8004bf6:	d1eb      	bne.n	8004bd0 <rcvr_datablock+0x28>
#endif /* STM32_SD_USE_DMA */

	rcvr_spi();						/* Discard CRC */
 8004bf8:	f7ff fea2 	bl	8004940 <rcvr_spi>
	rcvr_spi();
 8004bfc:	f7ff fea0 	bl	8004940 <rcvr_spi>
 8004c00:	2001      	movs	r0, #1

	return TRUE;					/* Return with success */
}
 8004c02:	bd70      	pop	{r4, r5, r6, pc}
 8004c04:	20001118 	.word	0x20001118

08004c08 <disk_initialize>:

@param[in] drv: BYTE Physical drive number (only 0 allowed)
*/

DSTATUS disk_initialize(BYTE drv)
{
 8004c08:	b573      	push	{r0, r1, r4, r5, r6, lr}
	BYTE n, cmd, ty, ocr[4];

	if (drv) return STA_NOINIT;			/* Supports only single drive */
 8004c0a:	2800      	cmp	r0, #0
 8004c0c:	f040 809b 	bne.w	8004d46 <disk_initialize+0x13e>
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
 8004c10:	4b4e      	ldr	r3, [pc, #312]	; (8004d4c <disk_initialize+0x144>)
 8004c12:	781a      	ldrb	r2, [r3, #0]
 8004c14:	f002 0002 	and.w	r0, r2, #2
 8004c18:	b2c1      	uxtb	r1, r0
 8004c1a:	2900      	cmp	r1, #0
 8004c1c:	f040 8091 	bne.w	8004d42 <disk_initialize+0x13a>
	/* Force socket power on and initialize interface */
	power_on();
 8004c20:	f7ff fed2 	bl	80049c8 <power_on>
static void interface_speed( enum speed_setting speed )
{
	if ( speed == INTERFACE_SLOW )
    {
		/* Set slow clock (100k-400k) */
		spi_set_baudrate_prescaler(SPI_SD,SPI_BaudRatePrescaler_slow);
 8004c24:	484a      	ldr	r0, [pc, #296]	; (8004d50 <disk_initialize+0x148>)
 8004c26:	2107      	movs	r1, #7
 8004c28:	f002 f97d 	bl	8006f26 <spi_set_baudrate_prescaler>
 8004c2c:	240a      	movs	r4, #10
 8004c2e:	3c01      	subs	r4, #1
	if (Stat & STA_NODISK) return Stat;	/* No card in the socket */
	/* Force socket power on and initialize interface */
	power_on();

	interface_speed(INTERFACE_SLOW);
	for (n = 10; n; n--) rcvr_spi();	/* 80 dummy clocks */
 8004c30:	f7ff fe86 	bl	8004940 <rcvr_spi>
 8004c34:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8004c38:	d1f9      	bne.n	8004c2e <disk_initialize+0x26>

	ty = 0;
    /* Enter Idle state */
	if (send_cmd(CMD0, 0) == 1)
 8004c3a:	2040      	movs	r0, #64	; 0x40
 8004c3c:	4621      	mov	r1, r4
 8004c3e:	f7ff ff6b 	bl	8004b18 <send_cmd>
 8004c42:	2801      	cmp	r0, #1
 8004c44:	d001      	beq.n	8004c4a <disk_initialize+0x42>
	power_on();

	interface_speed(INTERFACE_SLOW);
	for (n = 10; n; n--) rcvr_spi();	/* 80 dummy clocks */

	ty = 0;
 8004c46:	2400      	movs	r4, #0
 8004c48:	e069      	b.n	8004d1e <disk_initialize+0x116>
    /* Enter Idle state */
	if (send_cmd(CMD0, 0) == 1)
    {
		/* Initialization timeout of 1000 milliseconds */
		DWORD timer = Timer1;
 8004c4a:	4b42      	ldr	r3, [pc, #264]	; (8004d54 <disk_initialize+0x14c>)
        /* SDHC */
		if (send_cmd(CMD8, 0x1AA) == 1)
 8004c4c:	2048      	movs	r0, #72	; 0x48
 8004c4e:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
	ty = 0;
    /* Enter Idle state */
	if (send_cmd(CMD0, 0) == 1)
    {
		/* Initialization timeout of 1000 milliseconds */
		DWORD timer = Timer1;
 8004c52:	681d      	ldr	r5, [r3, #0]
        /* SDHC */
		if (send_cmd(CMD8, 0x1AA) == 1)
 8004c54:	f7ff ff60 	bl	8004b18 <send_cmd>
 8004c58:	2801      	cmp	r0, #1
 8004c5a:	d13a      	bne.n	8004cd2 <disk_initialize+0xca>
        {
            /* Get trailing return value of R7 response */
			for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();
 8004c5c:	f7ff fe70 	bl	8004940 <rcvr_spi>
 8004c60:	aa01      	add	r2, sp, #4
 8004c62:	5510      	strb	r0, [r2, r4]
 8004c64:	3401      	adds	r4, #1
 8004c66:	2c04      	cmp	r4, #4
 8004c68:	d1f8      	bne.n	8004c5c <disk_initialize+0x54>
            /* The card can work at VDD range of 2.7-3.6V */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA)
 8004c6a:	f89d 0006 	ldrb.w	r0, [sp, #6]
 8004c6e:	2801      	cmp	r0, #1
 8004c70:	d1e9      	bne.n	8004c46 <disk_initialize+0x3e>
 8004c72:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8004c76:	29aa      	cmp	r1, #170	; 0xaa
 8004c78:	d1e5      	bne.n	8004c46 <disk_initialize+0x3e>
            {
                /* Wait for leaving idle state (ACMD41 with HCS bit) */
				while (!timeout(timer,100) && send_cmd(ACMD41, 1UL << 30));
 8004c7a:	4628      	mov	r0, r5
 8004c7c:	2164      	movs	r1, #100	; 0x64
 8004c7e:	f7ff fe8d 	bl	800499c <timeout>
 8004c82:	b138      	cbz	r0, 8004c94 <disk_initialize+0x8c>
				if (!timeout(timer,100) && send_cmd(CMD58, 0) == 0)
 8004c84:	2164      	movs	r1, #100	; 0x64
 8004c86:	4628      	mov	r0, r5
 8004c88:	f7ff fe88 	bl	800499c <timeout>
 8004c8c:	4601      	mov	r1, r0
 8004c8e:	2800      	cmp	r0, #0
 8004c90:	d1d9      	bne.n	8004c46 <disk_initialize+0x3e>
 8004c92:	e007      	b.n	8004ca4 <disk_initialize+0x9c>
			for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();
            /* The card can work at VDD range of 2.7-3.6V */
			if (ocr[2] == 0x01 && ocr[3] == 0xAA)
            {
                /* Wait for leaving idle state (ACMD41 with HCS bit) */
				while (!timeout(timer,100) && send_cmd(ACMD41, 1UL << 30));
 8004c94:	20e9      	movs	r0, #233	; 0xe9
 8004c96:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8004c9a:	f7ff ff3d 	bl	8004b18 <send_cmd>
 8004c9e:	2800      	cmp	r0, #0
 8004ca0:	d1eb      	bne.n	8004c7a <disk_initialize+0x72>
 8004ca2:	e7ef      	b.n	8004c84 <disk_initialize+0x7c>
				if (!timeout(timer,100) && send_cmd(CMD58, 0) == 0)
 8004ca4:	207a      	movs	r0, #122	; 0x7a
 8004ca6:	f7ff ff37 	bl	8004b18 <send_cmd>
 8004caa:	2800      	cmp	r0, #0
 8004cac:	d1cb      	bne.n	8004c46 <disk_initialize+0x3e>
 8004cae:	4604      	mov	r4, r0
                {		                /* Check CCS bit in the OCR */
					for (n = 0; n < 4; n++) ocr[n] = rcvr_spi();
 8004cb0:	f7ff fe46 	bl	8004940 <rcvr_spi>
 8004cb4:	ab01      	add	r3, sp, #4
 8004cb6:	5518      	strb	r0, [r3, r4]
 8004cb8:	3401      	adds	r4, #1
 8004cba:	2c04      	cmp	r4, #4
 8004cbc:	d1f8      	bne.n	8004cb0 <disk_initialize+0xa8>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;
 8004cbe:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8004cc2:	f002 0040 	and.w	r0, r2, #64	; 0x40
 8004cc6:	b2c1      	uxtb	r1, r0
 8004cc8:	2900      	cmp	r1, #0
 8004cca:	bf0c      	ite	eq
 8004ccc:	2404      	moveq	r4, #4
 8004cce:	240c      	movne	r4, #12
 8004cd0:	e025      	b.n	8004d1e <disk_initialize+0x116>
			}
		}
        /* SDSC or MMC */
        else
        {
			if (send_cmd(ACMD41, 0) <= 1) 	
 8004cd2:	20e9      	movs	r0, #233	; 0xe9
 8004cd4:	4621      	mov	r1, r4
 8004cd6:	f7ff ff1f 	bl	8004b18 <send_cmd>
            {
				ty = CT_SD1; cmd = ACMD41;	/* SDSC */
 8004cda:	2801      	cmp	r0, #1
 8004cdc:	bf8c      	ite	hi
 8004cde:	2401      	movhi	r4, #1
 8004ce0:	2402      	movls	r4, #2
 8004ce2:	bf8c      	ite	hi
 8004ce4:	2641      	movhi	r6, #65	; 0x41
 8004ce6:	26e9      	movls	r6, #233	; 0xe9
            else
            {
				ty = CT_MMC; cmd = CMD1;	/* MMC */
			}
            /* Wait for leaving idle state */
			while (!timeout(timer,100) && send_cmd(cmd, 0));
 8004ce8:	2164      	movs	r1, #100	; 0x64
 8004cea:	4628      	mov	r0, r5
 8004cec:	f7ff fe56 	bl	800499c <timeout>
 8004cf0:	4601      	mov	r1, r0
 8004cf2:	b170      	cbz	r0, 8004d12 <disk_initialize+0x10a>
            /* Set R/W block length to 512 */
			if (timeout(timer,100) || send_cmd(CMD16, 512) != 0)
 8004cf4:	4628      	mov	r0, r5
 8004cf6:	2164      	movs	r1, #100	; 0x64
 8004cf8:	f7ff fe50 	bl	800499c <timeout>
 8004cfc:	2800      	cmp	r0, #0
 8004cfe:	d1a2      	bne.n	8004c46 <disk_initialize+0x3e>
 8004d00:	2050      	movs	r0, #80	; 0x50
 8004d02:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004d06:	f7ff ff07 	bl	8004b18 <send_cmd>
				ty = 0;
 8004d0a:	2800      	cmp	r0, #0
 8004d0c:	bf18      	it	ne
 8004d0e:	2400      	movne	r4, #0
 8004d10:	e005      	b.n	8004d1e <disk_initialize+0x116>
            else
            {
				ty = CT_MMC; cmd = CMD1;	/* MMC */
			}
            /* Wait for leaving idle state */
			while (!timeout(timer,100) && send_cmd(cmd, 0));
 8004d12:	4630      	mov	r0, r6
 8004d14:	f7ff ff00 	bl	8004b18 <send_cmd>
 8004d18:	2800      	cmp	r0, #0
 8004d1a:	d1e5      	bne.n	8004ce8 <disk_initialize+0xe0>
 8004d1c:	e7ea      	b.n	8004cf4 <disk_initialize+0xec>
            /* Set R/W block length to 512 */
			if (timeout(timer,100) || send_cmd(CMD16, 512) != 0)
				ty = 0;
		}
	}
	CardType = ty;
 8004d1e:	4b0e      	ldr	r3, [pc, #56]	; (8004d58 <disk_initialize+0x150>)
 8004d20:	701c      	strb	r4, [r3, #0]
	release_spi();
 8004d22:	f7ff fe11 	bl	8004948 <release_spi>

	if (ty)
 8004d26:	b14c      	cbz	r4, 8004d3c <disk_initialize+0x134>
    {			                    /* Initialization succeeded */
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
 8004d28:	4808      	ldr	r0, [pc, #32]	; (8004d4c <disk_initialize+0x144>)
 8004d2a:	7802      	ldrb	r2, [r0, #0]
 8004d2c:	f002 01fe 	and.w	r1, r2, #254	; 0xfe
 8004d30:	7001      	strb	r1, [r0, #0]
		spi_set_baudrate_prescaler(SPI_SD,SPI_BaudRatePrescaler_slow);
	}
    else
    {
		/* Set fast clock (depends on the CSD) */
		spi_set_baudrate_prescaler(SPI_SD,SPI_BaudRatePrescaler_fast);
 8004d32:	4807      	ldr	r0, [pc, #28]	; (8004d50 <disk_initialize+0x148>)
 8004d34:	2101      	movs	r1, #1
 8004d36:	f002 f8f6 	bl	8006f26 <spi_set_baudrate_prescaler>
 8004d3a:	e001      	b.n	8004d40 <disk_initialize+0x138>
		Stat &= ~STA_NOINIT;		/* Clear STA_NOINIT */
		interface_speed(INTERFACE_FAST);
	}
    else
    {			                    /* Initialization failed */
		power_off();
 8004d3c:	f7ff fec0 	bl	8004ac0 <power_off>
	}

	return Stat;
 8004d40:	4b02      	ldr	r3, [pc, #8]	; (8004d4c <disk_initialize+0x144>)
 8004d42:	7818      	ldrb	r0, [r3, #0]
 8004d44:	e000      	b.n	8004d48 <disk_initialize+0x140>

DSTATUS disk_initialize(BYTE drv)
{
	BYTE n, cmd, ty, ocr[4];

	if (drv) return STA_NOINIT;			/* Supports only single drive */
 8004d46:	2001      	movs	r0, #1
    {			                    /* Initialization failed */
		power_off();
	}

	return Stat;
}
 8004d48:	bd7c      	pop	{r2, r3, r4, r5, r6, pc}
 8004d4a:	bf00      	nop
 8004d4c:	20000001 	.word	0x20000001
 8004d50:	40003800 	.word	0x40003800
 8004d54:	20001118 	.word	0x20001118
 8004d58:	2000111c 	.word	0x2000111c

08004d5c <disk_status>:
@returns DSTATUS
*/

DSTATUS disk_status(BYTE drv)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
 8004d5c:	b910      	cbnz	r0, 8004d64 <disk_status+0x8>
	return Stat;
 8004d5e:	4b02      	ldr	r3, [pc, #8]	; (8004d68 <disk_status+0xc>)
 8004d60:	7818      	ldrb	r0, [r3, #0]
 8004d62:	4770      	bx	lr
@returns DSTATUS
*/

DSTATUS disk_status(BYTE drv)
{
	if (drv) return STA_NOINIT;		/* Supports only single drive */
 8004d64:	2001      	movs	r0, #1
	return Stat;
}
 8004d66:	4770      	bx	lr
 8004d68:	20000001 	.word	0x20000001

08004d6c <disk_read>:
@param[in] count: BYTE number of sectors to read
@returns DRESULT success (RES_OK) or fail.
*/

DRESULT disk_read(BYTE drv,BYTE *buff,DWORD sector,UINT count)
{
 8004d6c:	b538      	push	{r3, r4, r5, lr}
 8004d6e:	460d      	mov	r5, r1
 8004d70:	461c      	mov	r4, r3
 8004d72:	4611      	mov	r1, r2
	if (drv || !count)
 8004d74:	2800      	cmp	r0, #0
 8004d76:	d133      	bne.n	8004de0 <disk_read+0x74>
 8004d78:	2b00      	cmp	r3, #0
 8004d7a:	d031      	beq.n	8004de0 <disk_read+0x74>
    {
        return RES_PARERR;
    }
	if (Stat & STA_NOINIT)
 8004d7c:	4b1a      	ldr	r3, [pc, #104]	; (8004de8 <disk_read+0x7c>)
 8004d7e:	7818      	ldrb	r0, [r3, #0]
 8004d80:	07c0      	lsls	r0, r0, #31
 8004d82:	d42f      	bmi.n	8004de4 <disk_read+0x78>
    {
        return RES_NOTRDY;
    }
	/* Convert to byte address if needed */
	if (!(CardType & CT_BLOCK)) sector *= 512;
 8004d84:	4a19      	ldr	r2, [pc, #100]	; (8004dec <disk_read+0x80>)
 8004d86:	7813      	ldrb	r3, [r2, #0]
 8004d88:	f003 0008 	and.w	r0, r3, #8
 8004d8c:	b2c2      	uxtb	r2, r0
 8004d8e:	b902      	cbnz	r2, 8004d92 <disk_read+0x26>
 8004d90:	0249      	lsls	r1, r1, #9
	/* Single block read */
	if (count == 1)
 8004d92:	2c01      	cmp	r4, #1
 8004d94:	d10c      	bne.n	8004db0 <disk_read+0x44>
    {
		if (send_cmd(CMD17, sector) == 0)
 8004d96:	2051      	movs	r0, #81	; 0x51
 8004d98:	f7ff febe 	bl	8004b18 <send_cmd>
 8004d9c:	b9d0      	cbnz	r0, 8004dd4 <disk_read+0x68>
        {                               /* READ_SINGLE_BLOCK */
			if (rcvr_datablock(buff, 512))
 8004d9e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004da2:	4628      	mov	r0, r5
 8004da4:	f7ff ff00 	bl	8004ba8 <rcvr_datablock>
 8004da8:	f080 0101 	eor.w	r1, r0, #1
 8004dac:	b2cc      	uxtb	r4, r1
 8004dae:	e011      	b.n	8004dd4 <disk_read+0x68>
		}
	}
	/* Multiple block read */
	else
    {
		if (send_cmd(CMD18, sector) == 0)
 8004db0:	2052      	movs	r0, #82	; 0x52
 8004db2:	f7ff feb1 	bl	8004b18 <send_cmd>
 8004db6:	b968      	cbnz	r0, 8004dd4 <disk_read+0x68>
        {	                            /* READ_MULTIPLE_BLOCK */
			do
            {
				if (!rcvr_datablock(buff, 512)) break;
 8004db8:	4628      	mov	r0, r5
 8004dba:	f44f 7100 	mov.w	r1, #512	; 0x200
 8004dbe:	f7ff fef3 	bl	8004ba8 <rcvr_datablock>
 8004dc2:	b118      	cbz	r0, 8004dcc <disk_read+0x60>
				buff += 512;
			}
            while (--count);
 8004dc4:	3c01      	subs	r4, #1
		if (send_cmd(CMD18, sector) == 0)
        {	                            /* READ_MULTIPLE_BLOCK */
			do
            {
				if (!rcvr_datablock(buff, 512)) break;
				buff += 512;
 8004dc6:	f505 7500 	add.w	r5, r5, #512	; 0x200
			}
            while (--count);
 8004dca:	d1f5      	bne.n	8004db8 <disk_read+0x4c>
			send_cmd(CMD12, 0);			/* STOP_TRANSMISSION */
 8004dcc:	204c      	movs	r0, #76	; 0x4c
 8004dce:	2100      	movs	r1, #0
 8004dd0:	f7ff fea2 	bl	8004b18 <send_cmd>
		}
	}
	release_spi();
 8004dd4:	f7ff fdb8 	bl	8004948 <release_spi>

	return count ? RES_ERROR : RES_OK;
 8004dd8:	1c20      	adds	r0, r4, #0
 8004dda:	bf18      	it	ne
 8004ddc:	2001      	movne	r0, #1
 8004dde:	bd38      	pop	{r3, r4, r5, pc}

DRESULT disk_read(BYTE drv,BYTE *buff,DWORD sector,UINT count)
{
	if (drv || !count)
    {
        return RES_PARERR;
 8004de0:	2004      	movs	r0, #4
 8004de2:	bd38      	pop	{r3, r4, r5, pc}
    }
	if (Stat & STA_NOINIT)
    {
        return RES_NOTRDY;
 8004de4:	2003      	movs	r0, #3
		}
	}
	release_spi();

	return count ? RES_ERROR : RES_OK;
}
 8004de6:	bd38      	pop	{r3, r4, r5, pc}
 8004de8:	20000001 	.word	0x20000001
 8004dec:	2000111c 	.word	0x2000111c

08004df0 <disk_write>:
*/

#if _FS_READONLY == 0

DRESULT disk_write(BYTE drv,const BYTE *buff,DWORD sector,UINT count)
{
 8004df0:	b570      	push	{r4, r5, r6, lr}
 8004df2:	460d      	mov	r5, r1
 8004df4:	4616      	mov	r6, r2
 8004df6:	461c      	mov	r4, r3
	if (drv || !count)
 8004df8:	2800      	cmp	r0, #0
 8004dfa:	d151      	bne.n	8004ea0 <disk_write+0xb0>
 8004dfc:	2b00      	cmp	r3, #0
 8004dfe:	d04f      	beq.n	8004ea0 <disk_write+0xb0>
    {
        return RES_PARERR;
    }
	if (Stat & STA_NOINIT)
 8004e00:	4b2a      	ldr	r3, [pc, #168]	; (8004eac <disk_write+0xbc>)
 8004e02:	781a      	ldrb	r2, [r3, #0]
 8004e04:	07d2      	lsls	r2, r2, #31
 8004e06:	d44d      	bmi.n	8004ea4 <disk_write+0xb4>
    {
        return RES_NOTRDY;
    }
	if (Stat & STA_PROTECT)
 8004e08:	7818      	ldrb	r0, [r3, #0]
 8004e0a:	f000 0104 	and.w	r1, r0, #4
 8004e0e:	b2cb      	uxtb	r3, r1
 8004e10:	2b00      	cmp	r3, #0
 8004e12:	d149      	bne.n	8004ea8 <disk_write+0xb8>
    {
        return RES_WRPRT;
    }
	/* Convert to byte address if needed */
	if (!(CardType & CT_BLOCK)) sector *= 512;
 8004e14:	4a26      	ldr	r2, [pc, #152]	; (8004eb0 <disk_write+0xc0>)
 8004e16:	7810      	ldrb	r0, [r2, #0]
 8004e18:	f000 0108 	and.w	r1, r0, #8
 8004e1c:	b2cb      	uxtb	r3, r1
 8004e1e:	b903      	cbnz	r3, 8004e22 <disk_write+0x32>
 8004e20:	0276      	lsls	r6, r6, #9
	/* Single block write */
	if (count == 1)
 8004e22:	2c01      	cmp	r4, #1
 8004e24:	d114      	bne.n	8004e50 <disk_write+0x60>
    {
		if ((send_cmd(CMD24, sector) == 0)  /* WRITE_BLOCK */
 8004e26:	2058      	movs	r0, #88	; 0x58
 8004e28:	4631      	mov	r1, r6
 8004e2a:	f7ff fe75 	bl	8004b18 <send_cmd>
 8004e2e:	b108      	cbz	r0, 8004e34 <disk_write+0x44>
*/

#if _FS_READONLY == 0

DRESULT disk_write(BYTE drv,const BYTE *buff,DWORD sector,UINT count)
{
 8004e30:	2401      	movs	r4, #1
 8004e32:	e02f      	b.n	8004e94 <disk_write+0xa4>
	BYTE resp;
#ifndef STM32_SD_USE_DMA
	BYTE wc;
#endif

	if (wait_ready() != 0xFF)
 8004e34:	f7ff fe30 	bl	8004a98 <wait_ready>
 8004e38:	28ff      	cmp	r0, #255	; 0xff
 8004e3a:	d1f9      	bne.n	8004e30 <disk_write+0x40>
    {
        return FALSE;
    }

	xmit_spi(token);					/* transmit data token */
 8004e3c:	20fe      	movs	r0, #254	; 0xfe
 8004e3e:	f7ff fd75 	bl	800492c <stm32_spi_rw>
 8004e42:	4628      	mov	r0, r5
 8004e44:	f7ff fd8c 	bl	8004960 <xmit_datablock.part.3>
	if (!(CardType & CT_BLOCK)) sector *= 512;
	/* Single block write */
	if (count == 1)
    {
		if ((send_cmd(CMD24, sector) == 0)  /* WRITE_BLOCK */
			&& xmit_datablock(buff, 0xFE))
 8004e48:	f080 0401 	eor.w	r4, r0, #1
 8004e4c:	b2e4      	uxtb	r4, r4
 8004e4e:	e021      	b.n	8004e94 <disk_write+0xa4>
			count = 0;
	}
	/* Multiple block write */
	else
    {
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
 8004e50:	f010 0f06 	tst.w	r0, #6
 8004e54:	d003      	beq.n	8004e5e <disk_write+0x6e>
 8004e56:	20d7      	movs	r0, #215	; 0xd7
 8004e58:	4621      	mov	r1, r4
 8004e5a:	f7ff fe5d 	bl	8004b18 <send_cmd>
		if (send_cmd(CMD25, sector) == 0)
 8004e5e:	2059      	movs	r0, #89	; 0x59
 8004e60:	4631      	mov	r1, r6
 8004e62:	f7ff fe59 	bl	8004b18 <send_cmd>
 8004e66:	b9a8      	cbnz	r0, 8004e94 <disk_write+0xa4>
	BYTE resp;
#ifndef STM32_SD_USE_DMA
	BYTE wc;
#endif

	if (wait_ready() != 0xFF)
 8004e68:	f7ff fe16 	bl	8004a98 <wait_ready>
 8004e6c:	28ff      	cmp	r0, #255	; 0xff
 8004e6e:	d10a      	bne.n	8004e86 <disk_write+0x96>
    {
        return FALSE;
    }

	xmit_spi(token);					/* transmit data token */
 8004e70:	20fc      	movs	r0, #252	; 0xfc
 8004e72:	f7ff fd5b 	bl	800492c <stm32_spi_rw>
 8004e76:	4628      	mov	r0, r5
 8004e78:	f7ff fd72 	bl	8004960 <xmit_datablock.part.3>
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
		if (send_cmd(CMD25, sector) == 0)
        {                                   /* WRITE_MULTIPLE_BLOCK */
			do
            {
				if (!xmit_datablock(buff, 0xFC)) break;
 8004e7c:	b118      	cbz	r0, 8004e86 <disk_write+0x96>
				buff += 512;
			}
            while (--count);
 8004e7e:	3c01      	subs	r4, #1
		if (send_cmd(CMD25, sector) == 0)
        {                                   /* WRITE_MULTIPLE_BLOCK */
			do
            {
				if (!xmit_datablock(buff, 0xFC)) break;
				buff += 512;
 8004e80:	f505 7500 	add.w	r5, r5, #512	; 0x200
			}
            while (--count);
 8004e84:	d1f0      	bne.n	8004e68 <disk_write+0x78>
	BYTE resp;
#ifndef STM32_SD_USE_DMA
	BYTE wc;
#endif

	if (wait_ready() != 0xFF)
 8004e86:	f7ff fe07 	bl	8004a98 <wait_ready>
 8004e8a:	28ff      	cmp	r0, #255	; 0xff
 8004e8c:	d1d0      	bne.n	8004e30 <disk_write+0x40>
    {
        return FALSE;
    }

	xmit_spi(token);					/* transmit data token */
 8004e8e:	20fd      	movs	r0, #253	; 0xfd
 8004e90:	f7ff fd4c 	bl	800492c <stm32_spi_rw>
            while (--count);
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
				count = 1;
		}
	}
	release_spi();
 8004e94:	f7ff fd58 	bl	8004948 <release_spi>

	return count ? RES_ERROR : RES_OK;
 8004e98:	1c20      	adds	r0, r4, #0
 8004e9a:	bf18      	it	ne
 8004e9c:	2001      	movne	r0, #1
 8004e9e:	bd70      	pop	{r4, r5, r6, pc}

DRESULT disk_write(BYTE drv,const BYTE *buff,DWORD sector,UINT count)
{
	if (drv || !count)
    {
        return RES_PARERR;
 8004ea0:	2004      	movs	r0, #4
 8004ea2:	bd70      	pop	{r4, r5, r6, pc}
    }
	if (Stat & STA_NOINIT)
    {
        return RES_NOTRDY;
 8004ea4:	2003      	movs	r0, #3
 8004ea6:	bd70      	pop	{r4, r5, r6, pc}
    }
	if (Stat & STA_PROTECT)
    {
        return RES_WRPRT;
 8004ea8:	2002      	movs	r0, #2
		}
	}
	release_spi();

	return count ? RES_ERROR : RES_OK;
}
 8004eaa:	bd70      	pop	{r4, r5, r6, pc}
 8004eac:	20000001 	.word	0x20000001
 8004eb0:	2000111c 	.word	0x2000111c

08004eb4 <disk_ioctl>:
@returns DRESULT success (RES_OK) or fail (RES_ERROR).
*/

#if (STM32_SD_DISK_IOCTRL == 1)
DRESULT disk_ioctl(BYTE drv,BYTE ctrl,void *buff)
{
 8004eb4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004eb6:	4615      	mov	r5, r2
 8004eb8:	b085      	sub	sp, #20
	DRESULT res;
	BYTE n, csd[16], *ptr = buff;
	WORD csize;

	if (drv) return RES_PARERR;
 8004eba:	4604      	mov	r4, r0
 8004ebc:	2800      	cmp	r0, #0
 8004ebe:	f040 8100 	bne.w	80050c2 <disk_ioctl+0x20e>

	res = RES_ERROR;

	if (ctrl == CTRL_POWER)
 8004ec2:	2905      	cmp	r1, #5
 8004ec4:	d10f      	bne.n	8004ee6 <disk_ioctl+0x32>
    {
		switch (*ptr)
 8004ec6:	7810      	ldrb	r0, [r2, #0]
 8004ec8:	2801      	cmp	r0, #1
 8004eca:	d009      	beq.n	8004ee0 <disk_ioctl+0x2c>
 8004ecc:	d305      	bcc.n	8004eda <disk_ioctl+0x26>
 8004ece:	2802      	cmp	r0, #2
 8004ed0:	f040 80f7 	bne.w	80050c2 <disk_ioctl+0x20e>
			power_on();				/* Power on */
			res = RES_OK;
			break;
		/* Sub control code == 2 (POWER_GET) */
		case 2:
			*(ptr+1) = (BYTE)chk_power();
 8004ed4:	2101      	movs	r1, #1
 8004ed6:	7051      	strb	r1, [r2, #1]
			res = RES_OK;
			break;
 8004ed8:	e0f6      	b.n	80050c8 <disk_ioctl+0x214>
		switch (*ptr)
        {
		/* Sub control code == 0 (POWER_OFF) */
		case 0:
			if (chk_power())
				power_off();		/* Power off */
 8004eda:	f7ff fdf1 	bl	8004ac0 <power_off>
			res = RES_OK;
			break;
 8004ede:	e0f3      	b.n	80050c8 <disk_ioctl+0x214>
		/* Sub control code == 1 (POWER_ON) */
		case 1:
			power_on();				/* Power on */
 8004ee0:	f7ff fd72 	bl	80049c8 <power_on>
			res = RES_OK;
			break;
 8004ee4:	e0f0      	b.n	80050c8 <disk_ioctl+0x214>
			res = RES_PARERR;
		}
	}
	else
    {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
 8004ee6:	4b7a      	ldr	r3, [pc, #488]	; (80050d0 <disk_ioctl+0x21c>)
 8004ee8:	7818      	ldrb	r0, [r3, #0]
 8004eea:	07c0      	lsls	r0, r0, #31
 8004eec:	f100 80eb 	bmi.w	80050c6 <disk_ioctl+0x212>

		switch (ctrl)
 8004ef0:	290e      	cmp	r1, #14
 8004ef2:	f200 80e2 	bhi.w	80050ba <disk_ioctl+0x206>
 8004ef6:	e8df f011 	tbh	[pc, r1, lsl #1]
 8004efa:	000f      	.short	0x000f
 8004efc:	0056001b 	.word	0x0056001b
 8004f00:	00e0005a 	.word	0x00e0005a
 8004f04:	00e000e0 	.word	0x00e000e0
 8004f08:	00e000e0 	.word	0x00e000e0
 8004f0c:	00af00e0 	.word	0x00af00e0
 8004f10:	00b600b4 	.word	0x00b600b4
 8004f14:	00cf00c0 	.word	0x00cf00c0
        {
		/* Make sure that no pending write process */
		case CTRL_SYNC :
			SELECT();
 8004f18:	486e      	ldr	r0, [pc, #440]	; (80050d4 <disk_ioctl+0x220>)
 8004f1a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8004f1e:	f001 ff57 	bl	8006dd0 <gpio_clear>
			if (wait_ready() == 0xFF)
 8004f22:	f7ff fdb9 	bl	8004a98 <wait_ready>
				res = RES_OK;
 8004f26:	f1b0 04ff 	subs.w	r4, r0, #255	; 0xff
 8004f2a:	bf18      	it	ne
 8004f2c:	2401      	movne	r4, #1
 8004f2e:	e0c5      	b.n	80050bc <disk_ioctl+0x208>
			break;
    	/* Get number of sectors on the disk (DWORD) */
		case GET_SECTOR_COUNT :
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16))
 8004f30:	2049      	movs	r0, #73	; 0x49
 8004f32:	2100      	movs	r1, #0
 8004f34:	f7ff fdf0 	bl	8004b18 <send_cmd>
 8004f38:	4604      	mov	r4, r0
 8004f3a:	b108      	cbz	r0, 8004f40 <disk_ioctl+0x8c>
	BYTE n, csd[16], *ptr = buff;
	WORD csize;

	if (drv) return RES_PARERR;

	res = RES_ERROR;
 8004f3c:	2401      	movs	r4, #1
 8004f3e:	e0bd      	b.n	80050bc <disk_ioctl+0x208>
			if (wait_ready() == 0xFF)
				res = RES_OK;
			break;
    	/* Get number of sectors on the disk (DWORD) */
		case GET_SECTOR_COUNT :
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16))
 8004f40:	4668      	mov	r0, sp
 8004f42:	2110      	movs	r1, #16
 8004f44:	f7ff fe30 	bl	8004ba8 <rcvr_datablock>
 8004f48:	2800      	cmp	r0, #0
 8004f4a:	d0f7      	beq.n	8004f3c <disk_ioctl+0x88>
            {
				if ((csd[0] >> 6) == 1)
 8004f4c:	f89d 1000 	ldrb.w	r1, [sp]
 8004f50:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8004f54:	098a      	lsrs	r2, r1, #6
 8004f56:	2a01      	cmp	r2, #1
 8004f58:	d107      	bne.n	8004f6a <disk_ioctl+0xb6>
                {	                        /* SDC version 2.00 */
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
 8004f5a:	f89d 0009 	ldrb.w	r0, [sp, #9]
 8004f5e:	1c41      	adds	r1, r0, #1
 8004f60:	eb01 2303 	add.w	r3, r1, r3, lsl #8
					*(DWORD*)buff = (DWORD)csize << 10;
 8004f64:	b29a      	uxth	r2, r3
 8004f66:	0290      	lsls	r0, r2, #10
 8004f68:	e042      	b.n	8004ff0 <disk_ioctl+0x13c>
				}
                else
                {					        /* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8004f6a:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8004f6e:	0081      	lsls	r1, r0, #2
 8004f70:	eb01 1293 	add.w	r2, r1, r3, lsr #6
 8004f74:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8004f78:	1c50      	adds	r0, r2, #1
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)csize << 10;
				}
                else
                {					        /* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 8004f7a:	f89d 2005 	ldrb.w	r2, [sp, #5]
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
 8004f7e:	f003 0103 	and.w	r1, r3, #3
					*(DWORD*)buff = (DWORD)csize << (n - 9);
 8004f82:	eb00 2081 	add.w	r0, r0, r1, lsl #10
					csize = csd[9] + ((WORD)csd[8] << 8) + 1;
					*(DWORD*)buff = (DWORD)csize << 10;
				}
                else
                {					        /* SDC version 1.XX or MMC*/
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 8004f86:	f002 030f 	and.w	r3, r2, #15
 8004f8a:	f89d 100a 	ldrb.w	r1, [sp, #10]
 8004f8e:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8004f92:	eb03 13d1 	add.w	r3, r3, r1, lsr #7
 8004f96:	f002 0103 	and.w	r1, r2, #3
					csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = (DWORD)csize << (n - 9);
 8004f9a:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 8004f9e:	1fda      	subs	r2, r3, #7
 8004fa0:	fa00 f002 	lsl.w	r0, r0, r2
 8004fa4:	e024      	b.n	8004ff0 <disk_ioctl+0x13c>
				res = RES_OK;
			}
			break;
	    /* Get R/W sector size (WORD) */
		case GET_SECTOR_SIZE :
			*(WORD*)buff = 512;
 8004fa6:	f44f 7400 	mov.w	r4, #512	; 0x200
 8004faa:	8014      	strh	r4, [r2, #0]
 8004fac:	e057      	b.n	800505e <disk_ioctl+0x1aa>
			res = RES_OK;
			break;
    	/* Get erase block size in unit of sector (DWORD) */
		case GET_BLOCK_SIZE :
			if (CardType & CT_SD2)
 8004fae:	4e4a      	ldr	r6, [pc, #296]	; (80050d8 <disk_ioctl+0x224>)
 8004fb0:	7830      	ldrb	r0, [r6, #0]
 8004fb2:	f000 0404 	and.w	r4, r0, #4
 8004fb6:	b2e1      	uxtb	r1, r4
 8004fb8:	b1e1      	cbz	r1, 8004ff4 <disk_ioctl+0x140>
            {	                            /* SDC version 2.00 */
				if (send_cmd(ACMD13, 0) == 0)
 8004fba:	20cd      	movs	r0, #205	; 0xcd
 8004fbc:	2100      	movs	r1, #0
 8004fbe:	f7ff fdab 	bl	8004b18 <send_cmd>
 8004fc2:	2800      	cmp	r0, #0
 8004fc4:	d1ba      	bne.n	8004f3c <disk_ioctl+0x88>
                {	                        /* Read SD status */
					rcvr_spi();
 8004fc6:	f7ff fcbb 	bl	8004940 <rcvr_spi>
					if (rcvr_datablock(csd, 16))
 8004fca:	4668      	mov	r0, sp
 8004fcc:	2110      	movs	r1, #16
 8004fce:	f7ff fdeb 	bl	8004ba8 <rcvr_datablock>
 8004fd2:	2800      	cmp	r0, #0
 8004fd4:	d0b2      	beq.n	8004f3c <disk_ioctl+0x88>
 8004fd6:	2430      	movs	r4, #48	; 0x30
                    {       				/* Read partial block */
                    	/* Purge trailing data */
						for (n = 64 - 16; n; n--) rcvr_spi();
 8004fd8:	f7ff fcb2 	bl	8004940 <rcvr_spi>
 8004fdc:	1e61      	subs	r1, r4, #1
 8004fde:	f011 04ff 	ands.w	r4, r1, #255	; 0xff
 8004fe2:	d1f9      	bne.n	8004fd8 <disk_ioctl+0x124>
						*(DWORD*)buff = 16UL << (csd[10] >> 4);
 8004fe4:	f89d 200a 	ldrb.w	r2, [sp, #10]
 8004fe8:	2310      	movs	r3, #16
 8004fea:	0910      	lsrs	r0, r2, #4
 8004fec:	fa03 f000 	lsl.w	r0, r3, r0
 8004ff0:	6028      	str	r0, [r5, #0]
 8004ff2:	e063      	b.n	80050bc <disk_ioctl+0x208>
					}
				}
			}
            else
            {           					/* SDC version 1.XX or MMC */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16))
 8004ff4:	2049      	movs	r0, #73	; 0x49
 8004ff6:	f7ff fd8f 	bl	8004b18 <send_cmd>
 8004ffa:	4607      	mov	r7, r0
 8004ffc:	2800      	cmp	r0, #0
 8004ffe:	d19d      	bne.n	8004f3c <disk_ioctl+0x88>
 8005000:	4668      	mov	r0, sp
 8005002:	2110      	movs	r1, #16
 8005004:	f7ff fdd0 	bl	8004ba8 <rcvr_datablock>
 8005008:	2800      	cmp	r0, #0
 800500a:	d097      	beq.n	8004f3c <disk_ioctl+0x88>
                {	                        /* Read CSD */
					if (CardType & CT_SD1)
 800500c:	7831      	ldrb	r1, [r6, #0]
 800500e:	f89d 000a 	ldrb.w	r0, [sp, #10]
 8005012:	f001 0202 	and.w	r2, r1, #2
 8005016:	b2d4      	uxtb	r4, r2
 8005018:	b184      	cbz	r4, 800503c <disk_ioctl+0x188>
                    {                   	/* SDC version 1.XX */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + \
 800501a:	f000 043f 	and.w	r4, r0, #63	; 0x3f
                            ((WORD)(csd[11] & 128) >> 7) + 1) \
 800501e:	f89d 000b 	ldrb.w	r0, [sp, #11]
 8005022:	09c3      	lsrs	r3, r0, #7
            {           					/* SDC version 1.XX or MMC */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16))
                {	                        /* Read CSD */
					if (CardType & CT_SD1)
                    {                   	/* SDC version 1.XX */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + \
 8005024:	eb03 0144 	add.w	r1, r3, r4, lsl #1
                            ((WORD)(csd[11] & 128) >> 7) + 1) \
                            << ((csd[13] >> 6) - 1);
 8005028:	f89d 400d 	ldrb.w	r4, [sp, #13]
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16))
                {	                        /* Read CSD */
					if (CardType & CT_SD1)
                    {                   	/* SDC version 1.XX */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + \
                            ((WORD)(csd[11] & 128) >> 7) + 1) \
 800502c:	1c4a      	adds	r2, r1, #1
                            << ((csd[13] >> 6) - 1);
 800502e:	09a0      	lsrs	r0, r4, #6
 8005030:	1e43      	subs	r3, r0, #1
 8005032:	fa02 f203 	lsl.w	r2, r2, r3
                    {   					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) \
                            * (((csd[11] & 3) << 3) + \
                            ((csd[11] & 224) >> 5) + 1);
					}
					res = RES_OK;
 8005036:	463c      	mov	r4, r7
            {           					/* SDC version 1.XX or MMC */
				if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16))
                {	                        /* Read CSD */
					if (CardType & CT_SD1)
                    {                   	/* SDC version 1.XX */
						*(DWORD*)buff = (((csd[10] & 63) << 1) + \
 8005038:	602a      	str	r2, [r5, #0]
 800503a:	e03f      	b.n	80050bc <disk_ioctl+0x208>
                            << ((csd[13] >> 6) - 1);
					}
                    else
                    {   					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) \
                            * (((csd[11] & 3) << 3) + \
 800503c:	f89d 300b 	ldrb.w	r3, [sp, #11]
                            ((WORD)(csd[11] & 128) >> 7) + 1) \
                            << ((csd[13] >> 6) - 1);
					}
                    else
                    {   					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) \
 8005040:	f3c0 0184 	ubfx	r1, r0, #2, #5
                            * (((csd[11] & 3) << 3) + \
 8005044:	f003 0203 	and.w	r2, r3, #3
                            ((csd[11] & 224) >> 5) + 1);
 8005048:	095b      	lsrs	r3, r3, #5
                            ((WORD)(csd[11] & 128) >> 7) + 1) \
                            << ((csd[13] >> 6) - 1);
					}
                    else
                    {   					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) \
 800504a:	1c48      	adds	r0, r1, #1
                            * (((csd[11] & 3) << 3) + \
 800504c:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
                            ((csd[11] & 224) >> 5) + 1);
 8005050:	1c4a      	adds	r2, r1, #1
                            << ((csd[13] >> 6) - 1);
					}
                    else
                    {   					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) \
                            * (((csd[11] & 3) << 3) + \
 8005052:	4342      	muls	r2, r0
                            ((WORD)(csd[11] & 128) >> 7) + 1) \
                            << ((csd[13] >> 6) - 1);
					}
                    else
                    {   					/* MMC */
						*(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) \
 8005054:	602a      	str	r2, [r5, #0]
 8005056:	e031      	b.n	80050bc <disk_ioctl+0x208>
				}
			}
			break;
		/* Get card type flags (1 byte) */
		case MMC_GET_TYPE :
			*ptr = CardType;
 8005058:	4a1f      	ldr	r2, [pc, #124]	; (80050d8 <disk_ioctl+0x224>)
 800505a:	7813      	ldrb	r3, [r2, #0]
 800505c:	702b      	strb	r3, [r5, #0]
			res = RES_OK;
 800505e:	2400      	movs	r4, #0
			break;
 8005060:	e02c      	b.n	80050bc <disk_ioctl+0x208>
		/* Receive CSD as a data block (16 bytes) */
		case MMC_GET_CSD :
			if (send_cmd(CMD9, 0) == 0		/* READ_CSD */
 8005062:	2049      	movs	r0, #73	; 0x49
 8005064:	e000      	b.n	8005068 <disk_ioctl+0x1b4>
				&& rcvr_datablock(ptr, 16))
				res = RES_OK;
			break;
		/* Receive CID as a data block (16 bytes) */
		case MMC_GET_CID :
			if (send_cmd(CMD10, 0) == 0		/* READ_CID */
 8005066:	204a      	movs	r0, #74	; 0x4a
 8005068:	2100      	movs	r1, #0
 800506a:	f7ff fd55 	bl	8004b18 <send_cmd>
 800506e:	2800      	cmp	r0, #0
 8005070:	f47f af64 	bne.w	8004f3c <disk_ioctl+0x88>
				&& rcvr_datablock(ptr, 16))
 8005074:	4628      	mov	r0, r5
 8005076:	2110      	movs	r1, #16
 8005078:	e019      	b.n	80050ae <disk_ioctl+0x1fa>
				res = RES_OK;
			break;
        /* Receive OCR as an R3 resp (4 bytes) */
		case MMC_GET_OCR :
			if (send_cmd(CMD58, 0) == 0)
 800507a:	207a      	movs	r0, #122	; 0x7a
 800507c:	2100      	movs	r1, #0
 800507e:	f7ff fd4b 	bl	8004b18 <send_cmd>
 8005082:	2800      	cmp	r0, #0
 8005084:	f47f af5a 	bne.w	8004f3c <disk_ioctl+0x88>
 8005088:	4604      	mov	r4, r0
            {	                            /* READ_OCR */
				for (n = 4; n; n--) *ptr++ = rcvr_spi();
 800508a:	f7ff fc59 	bl	8004940 <rcvr_spi>
 800508e:	5528      	strb	r0, [r5, r4]
 8005090:	3401      	adds	r4, #1
 8005092:	2c04      	cmp	r4, #4
 8005094:	d1f9      	bne.n	800508a <disk_ioctl+0x1d6>
 8005096:	e7e2      	b.n	800505e <disk_ioctl+0x1aa>
				res = RES_OK;
			}
			break;
        /* Receive SD status as a data block (64 bytes) */
		case MMC_GET_SDSTAT :
			if (send_cmd(ACMD13, 0) == 0)
 8005098:	20cd      	movs	r0, #205	; 0xcd
 800509a:	2100      	movs	r1, #0
 800509c:	f7ff fd3c 	bl	8004b18 <send_cmd>
 80050a0:	2800      	cmp	r0, #0
 80050a2:	f47f af4b 	bne.w	8004f3c <disk_ioctl+0x88>
            {	                            /* SD_STATUS */
				rcvr_spi();
 80050a6:	f7ff fc4b 	bl	8004940 <rcvr_spi>
				if (rcvr_datablock(ptr, 64))
 80050aa:	4628      	mov	r0, r5
 80050ac:	2140      	movs	r1, #64	; 0x40
 80050ae:	f7ff fd7b 	bl	8004ba8 <rcvr_datablock>
 80050b2:	f080 0101 	eor.w	r1, r0, #1
        {
		/* Make sure that no pending write process */
		case CTRL_SYNC :
			SELECT();
			if (wait_ready() == 0xFF)
				res = RES_OK;
 80050b6:	b2cc      	uxtb	r4, r1
 80050b8:	e000      	b.n	80050bc <disk_ioctl+0x208>
					res = RES_OK;
			}
			break;

		default:
			res = RES_PARERR;
 80050ba:	2404      	movs	r4, #4
		}

		release_spi();
 80050bc:	f7ff fc44 	bl	8004948 <release_spi>
 80050c0:	e002      	b.n	80050c8 <disk_ioctl+0x214>
		case 2:
			*(ptr+1) = (BYTE)chk_power();
			res = RES_OK;
			break;
		default :
			res = RES_PARERR;
 80050c2:	2404      	movs	r4, #4
 80050c4:	e000      	b.n	80050c8 <disk_ioctl+0x214>
		}
	}
	else
    {
		if (Stat & STA_NOINIT) return RES_NOTRDY;
 80050c6:	2403      	movs	r4, #3

		release_spi();
	}

	return res;
}
 80050c8:	4620      	mov	r0, r4
 80050ca:	b005      	add	sp, #20
 80050cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80050ce:	bf00      	nop
 80050d0:	20000001 	.word	0x20000001
 80050d4:	40010c00 	.word	0x40010c00
 80050d8:	2000111c 	.word	0x2000111c

080050dc <disk_timerproc>:
{
	static DWORD pv;          /* previous reading of socket status */
	DWORD ns;
	BYTE s;

    Timer1++;
 80050dc:	4b07      	ldr	r3, [pc, #28]	; (80050fc <disk_timerproc+0x20>)

	ns = pv;
    /* Sample the socket switch to check empty or write protect */
	pv = socket_is_empty() | socket_is_write_protected();
 80050de:	2100      	movs	r1, #0
{
	static DWORD pv;          /* previous reading of socket status */
	DWORD ns;
	BYTE s;

    Timer1++;
 80050e0:	681a      	ldr	r2, [r3, #0]
 80050e2:	1c50      	adds	r0, r2, #1
 80050e4:	6018      	str	r0, [r3, #0]

	ns = pv;
 80050e6:	4b06      	ldr	r3, [pc, #24]	; (8005100 <disk_timerproc+0x24>)
 80050e8:	681a      	ldr	r2, [r3, #0]
    /* Sample the socket switch to check empty or write protect */
	pv = socket_is_empty() | socket_is_write_protected();
 80050ea:	6019      	str	r1, [r3, #0]

	if (ns == pv)
 80050ec:	b922      	cbnz	r2, 80050f8 <disk_timerproc+0x1c>
    {                         /* Have contacts stabled? */
		s = Stat;
 80050ee:	4805      	ldr	r0, [pc, #20]	; (8005104 <disk_timerproc+0x28>)
 80050f0:	7803      	ldrb	r3, [r0, #0]
			s &= ~STA_PROTECT;

		if (pv & socket_state_mask_cp)      /* INS = H (Socket empty) */
			s |= (STA_NODISK | STA_NOINIT);
		else                                /* INS = L (Card inserted) */
			s &= ~STA_NODISK;
 80050f2:	f003 02f9 	and.w	r2, r3, #249	; 0xf9

/* Stat is a global status for card inserted and write protect */
		Stat = s;
 80050f6:	7002      	strb	r2, [r0, #0]
 80050f8:	4770      	bx	lr
 80050fa:	bf00      	nop
 80050fc:	20001118 	.word	0x20001118
 8005100:	20001120 	.word	0x20001120
 8005104:	20000001 	.word	0x20000001

08005108 <get_fattime>:
#include "integer.h"
#include "fattime.h"
#include "rtc.h"

DWORD get_fattime (void)
{
 8005108:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	DWORD res;
	RTC_t rtc;

	rtc_gettime( &rtc );
 800510a:	a801      	add	r0, sp, #4
 800510c:	f000 f886 	bl	800521c <rtc_gettime>
	
	res =  (((DWORD)rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
 8005110:	f89d 2006 	ldrb.w	r2, [sp, #6]
			| ((DWORD)rtc.mday << 16)
 8005114:	f89d 3007 	ldrb.w	r3, [sp, #7]
	RTC_t rtc;

	rtc_gettime( &rtc );
	
	res =  (((DWORD)rtc.year - 1980) << 25)
			| ((DWORD)rtc.month << 21)
 8005118:	0550      	lsls	r0, r2, #21
 800511a:	ea40 4103 	orr.w	r1, r0, r3, lsl #16
			| ((DWORD)rtc.mday << 16)
			| (WORD)(rtc.hour << 11)
			| (WORD)(rtc.min << 5)
			| (WORD)(rtc.sec >> 1);
 800511e:	f89d 300b 	ldrb.w	r3, [sp, #11]
	DWORD res;
	RTC_t rtc;

	rtc_gettime( &rtc );
	
	res =  (((DWORD)rtc.year - 1980) << 25)
 8005122:	f8bd 0004 	ldrh.w	r0, [sp, #4]
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
 8005126:	ea41 0253 	orr.w	r2, r1, r3, lsr #1
	DWORD res;
	RTC_t rtc;

	rtc_gettime( &rtc );
	
	res =  (((DWORD)rtc.year - 1980) << 25)
 800512a:	f2a0 71bc 	subw	r1, r0, #1980	; 0x7bc
			| ((DWORD)rtc.month << 21)
			| ((DWORD)rtc.mday << 16)
			| (WORD)(rtc.hour << 11)
 800512e:	ea42 6341 	orr.w	r3, r2, r1, lsl #25
 8005132:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8005136:	02d0      	lsls	r0, r2, #11
 8005138:	b281      	uxth	r1, r0
			| (WORD)(rtc.min << 5)
 800513a:	f89d 200a 	ldrb.w	r2, [sp, #10]
 800513e:	430b      	orrs	r3, r1
			| (WORD)(rtc.sec >> 1);

	return res;
}
 8005140:	ea43 1042 	orr.w	r0, r3, r2, lsl #5
 8005144:	b005      	add	sp, #20
 8005146:	bd00      	pop	{pc}

08005148 <isDST>:
*******************************************************************************/
static bool isDST( const RTC_t *t )
{
	uint8_t wday, month;		// locals for faster access

	month = t->month;
 8005148:	7883      	ldrb	r3, [r0, #2]

	if( month < 3 || month > 10 ) {		// month 1, 2, 11, 12
 800514a:	1eda      	subs	r2, r3, #3
 800514c:	2a07      	cmp	r2, #7
 800514e:	d80e      	bhi.n	800516e <isDST+0x26>
		return false;					// -> Winter
	}

	wday  = t->wday;
 8005150:	7902      	ldrb	r2, [r0, #4]

	if( t->mday - wday >= 25 && (wday || t->hour >= 2) ) { // after last Sunday 2:00
 8005152:	78c1      	ldrb	r1, [r0, #3]
 8005154:	1a89      	subs	r1, r1, r2
 8005156:	2918      	cmp	r1, #24
 8005158:	dd07      	ble.n	800516a <isDST+0x22>
 800515a:	b912      	cbnz	r2, 8005162 <isDST+0x1a>
 800515c:	7940      	ldrb	r0, [r0, #5]
 800515e:	2801      	cmp	r0, #1
 8005160:	d903      	bls.n	800516a <isDST+0x22>
		if( month == 10 ) {				// October -> Winter
 8005162:	2b0a      	cmp	r3, #10
 8005164:	d003      	beq.n	800516e <isDST+0x26>
		if( month == 3 ) {				// March -> Winter
			return false;
		}
	}

	return true;
 8005166:	2001      	movs	r0, #1
 8005168:	4770      	bx	lr
	if( t->mday - wday >= 25 && (wday || t->hour >= 2) ) { // after last Sunday 2:00
		if( month == 10 ) {				// October -> Winter
			return false;
		}
	} else {							// before last Sunday 2:00
		if( month == 3 ) {				// March -> Winter
 800516a:	2b03      	cmp	r3, #3
 800516c:	e7fa      	b.n	8005164 <isDST+0x1c>
	uint8_t wday, month;		// locals for faster access

	month = t->month;

	if( month < 3 || month > 10 ) {		// month 1, 2, 11, 12
		return false;					// -> Winter
 800516e:	2000      	movs	r0, #0
			return false;
		}
	}

	return true;
}
 8005170:	4770      	bx	lr
	...

08005174 <counter_to_struct>:
	uint8_t year;
	uint16_t dayofyear;
	uint8_t leap400;
	uint8_t month;

	t->sec = sec % 60;
 8005174:	233c      	movs	r3, #60	; 0x3c
 8005176:	fbb0 f2f3 	udiv	r2, r0, r3
 800517a:	fb03 0012 	mls	r0, r3, r2, r0
* Output         : time-struct gets populated, DST not taken into account here
* Return         : none
*  Based on code from Peter Dannegger found in the mikrocontroller.net forum.
*******************************************************************************/
static void counter_to_struct( uint32_t sec, RTC_t *t )
{
 800517e:	b510      	push	{r4, lr}
	uint8_t year;
	uint16_t dayofyear;
	uint8_t leap400;
	uint8_t month;

	t->sec = sec % 60;
 8005180:	71c8      	strb	r0, [r1, #7]
	sec /= 60;
	t->min = sec % 60;
 8005182:	fbb2 f4f3 	udiv	r4, r2, r3
	sec /= 60;
	t->hour = sec % 24;
 8005186:	2018      	movs	r0, #24
	uint8_t leap400;
	uint8_t month;

	t->sec = sec % 60;
	sec /= 60;
	t->min = sec % 60;
 8005188:	fb03 2314 	mls	r3, r3, r4, r2
	sec /= 60;
	t->hour = sec % 24;
 800518c:	fbb4 f2f0 	udiv	r2, r4, r0
 8005190:	fb00 4412 	mls	r4, r0, r2, r4
	uint8_t leap400;
	uint8_t month;

	t->sec = sec % 60;
	sec /= 60;
	t->min = sec % 60;
 8005194:	718b      	strb	r3, [r1, #6]
	sec /= 60;
	t->hour = sec % 24;
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 8005196:	2007      	movs	r0, #7
	t->sec = sec % 60;
	sec /= 60;
	t->min = sec % 60;
	sec /= 60;
	t->hour = sec % 24;
	day = (uint16_t)(sec / 24);
 8005198:	b293      	uxth	r3, r2

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 800519a:	3206      	adds	r2, #6

	t->sec = sec % 60;
	sec /= 60;
	t->min = sec % 60;
	sec /= 60;
	t->hour = sec % 24;
 800519c:	714c      	strb	r4, [r1, #5]
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 800519e:	fb92 f4f0 	sdiv	r4, r2, r0
 80051a2:	fb00 2214 	mls	r2, r0, r4, r2

	year = FIRSTYEAR % 100;				// 0..99
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1
 80051a6:	2401      	movs	r4, #1
	t->min = sec % 60;
	sec /= 60;
	t->hour = sec % 24;
	day = (uint16_t)(sec / 24);

	t->wday = (day + FIRSTDAY) % 7;		// weekday
 80051a8:	710a      	strb	r2, [r1, #4]

	year = FIRSTYEAR % 100;				// 0..99
 80051aa:	2200      	movs	r2, #0
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
		if( (year & 3) == 0 ) {
 80051ac:	0790      	lsls	r0, r2, #30
 80051ae:	d10d      	bne.n	80051cc <counter_to_struct+0x58>
			dayofyear = 366;					// leap year
			if( year == 0 || year == 100 || year == 200 ) {	// 100 year exception
 80051b0:	b11a      	cbz	r2, 80051ba <counter_to_struct+0x46>
 80051b2:	2a64      	cmp	r2, #100	; 0x64
 80051b4:	d001      	beq.n	80051ba <counter_to_struct+0x46>
 80051b6:	2ac8      	cmp	r2, #200	; 0xc8
 80051b8:	d10b      	bne.n	80051d2 <counter_to_struct+0x5e>
				if( --leap400 ) {					// 400 year exception
 80051ba:	3c01      	subs	r4, #1
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
		if( (year & 3) == 0 ) {
			dayofyear = 366;					// leap year
 80051bc:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80051c0:	f240 106d 	movw	r0, #365	; 0x16d
 80051c4:	bf08      	it	eq
 80051c6:	f44f 70b7 	moveq.w	r0, #366	; 0x16e
 80051ca:	e004      	b.n	80051d6 <counter_to_struct+0x62>

	year = FIRSTYEAR % 100;				// 0..99
	leap400 = 4 - ((FIRSTYEAR - 1) / 100 & 3);	// 4, 3, 2, 1

	for(;;) {
		dayofyear = 365;
 80051cc:	f240 106d 	movw	r0, #365	; 0x16d
 80051d0:	e001      	b.n	80051d6 <counter_to_struct+0x62>
		if( (year & 3) == 0 ) {
			dayofyear = 366;					// leap year
 80051d2:	f44f 70b7 	mov.w	r0, #366	; 0x16e
				if( --leap400 ) {					// 400 year exception
					dayofyear = 365;
				}
			}
		}
		if( day < dayofyear ) {
 80051d6:	4283      	cmp	r3, r0
 80051d8:	d304      	bcc.n	80051e4 <counter_to_struct+0x70>
			break;
		}
		day -= dayofyear;
 80051da:	1a1b      	subs	r3, r3, r0
		year++;					// 00..136 / 99..235
 80051dc:	3201      	adds	r2, #1
			}
		}
		if( day < dayofyear ) {
			break;
		}
		day -= dayofyear;
 80051de:	b29b      	uxth	r3, r3
		year++;					// 00..136 / 99..235
 80051e0:	b2d2      	uxtb	r2, r2
	}
 80051e2:	e7e3      	b.n	80051ac <counter_to_struct+0x38>
	t->year = year + FIRSTYEAR / 100 * 100;	// + century
 80051e4:	f502 62fa 	add.w	r2, r2, #2000	; 0x7d0
 80051e8:	800a      	strh	r2, [r1, #0]

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
 80051ea:	07c2      	lsls	r2, r0, #31
 80051ec:	d503      	bpl.n	80051f6 <counter_to_struct+0x82>
 80051ee:	2b3a      	cmp	r3, #58	; 0x3a
 80051f0:	d901      	bls.n	80051f6 <counter_to_struct+0x82>
		day++;					// skip 29.2.
 80051f2:	1c58      	adds	r0, r3, #1
 80051f4:	b283      	uxth	r3, r0
				if( --leap400 ) {					// 400 year exception
					dayofyear = 365;
				}
			}
		}
		if( day < dayofyear ) {
 80051f6:	2201      	movs	r2, #1

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
		day++;					// skip 29.2.
	}

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
 80051f8:	4807      	ldr	r0, [pc, #28]	; (8005218 <counter_to_struct+0xa4>)
 80051fa:	1880      	adds	r0, r0, r2
 80051fc:	f810 0c01 	ldrb.w	r0, [r0, #-1]
 8005200:	4283      	cmp	r3, r0
 8005202:	d304      	bcc.n	800520e <counter_to_struct+0x9a>
		day -= DaysInMonth[month-1];
 8005204:	1a18      	subs	r0, r3, r0

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
		day++;					// skip 29.2.
	}

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
 8005206:	3201      	adds	r2, #1
		day -= DaysInMonth[month-1];
 8005208:	b283      	uxth	r3, r0

	if( dayofyear & 1 && day > 58 ) { 	// no leap year and after 28.2.
		day++;					// skip 29.2.
	}

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
 800520a:	b2d2      	uxtb	r2, r2
 800520c:	e7f4      	b.n	80051f8 <counter_to_struct+0x84>
		day -= DaysInMonth[month-1];
	}

	t->month = month;				// 1..12
	t->mday = day + 1;				// 1..31
 800520e:	3301      	adds	r3, #1

	for( month = 1; day >= DaysInMonth[month-1]; month++ ) {
		day -= DaysInMonth[month-1];
	}

	t->month = month;				// 1..12
 8005210:	708a      	strb	r2, [r1, #2]
	t->mday = day + 1;				// 1..31
 8005212:	70cb      	strb	r3, [r1, #3]
 8005214:	bd10      	pop	{r4, pc}
 8005216:	bf00      	nop
 8005218:	08007597 	.word	0x08007597

0800521c <rtc_gettime>:
* Input          : None
* Output         : time-struct gets modified
* Return         : always true/not used
*******************************************************************************/
bool rtc_gettime (RTC_t *rtc)
{
 800521c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005220:	4604      	mov	r4, r0
	uint32_t t;

	while ( ( t = rtc_get_counter_val() ) != rtc_get_counter_val() ) { ; }
 8005222:	f001 fd13 	bl	8006c4c <rtc_get_counter_val>
 8005226:	4605      	mov	r5, r0
 8005228:	f001 fd10 	bl	8006c4c <rtc_get_counter_val>
 800522c:	4285      	cmp	r5, r0
 800522e:	d1f8      	bne.n	8005222 <rtc_gettime+0x6>
	counter_to_struct( t, rtc ); // get non DST time
 8005230:	4621      	mov	r1, r4
 8005232:	f7ff ff9f 	bl	8005174 <counter_to_struct>
	hour  = t->hour;
	day   = t->mday;
	wday  = t->wday;
	month = t->month;

	if ( isDST(t) ) {
 8005236:	4620      	mov	r0, r4
*******************************************************************************/
static bool adjustDST( RTC_t *t )
{
	uint8_t hour, day, wday, month;			// locals for faster access

	hour  = t->hour;
 8005238:	f894 8005 	ldrb.w	r8, [r4, #5]
	day   = t->mday;
 800523c:	78e5      	ldrb	r5, [r4, #3]
	wday  = t->wday;
 800523e:	7927      	ldrb	r7, [r4, #4]
	month = t->month;
 8005240:	78a6      	ldrb	r6, [r4, #2]

	if ( isDST(t) ) {
 8005242:	f7ff ff81 	bl	8005148 <isDST>
 8005246:	b1e0      	cbz	r0, 8005282 <rtc_gettime+0x66>
		t->dst = 1;
 8005248:	2301      	movs	r3, #1
		hour++;								// add one hour
 800524a:	eb08 0003 	add.w	r0, r8, r3
 800524e:	b2c0      	uxtb	r0, r0
		if( hour == 24 ){					// next day
 8005250:	2818      	cmp	r0, #24
	day   = t->mday;
	wday  = t->wday;
	month = t->month;

	if ( isDST(t) ) {
		t->dst = 1;
 8005252:	7223      	strb	r3, [r4, #8]
		hour++;								// add one hour
		if( hour == 24 ){					// next day
 8005254:	d110      	bne.n	8005278 <rtc_gettime+0x5c>
			hour = 0;
			wday++;							// next weekday
			if( wday == 7 ) {
				wday = 0;
			}
			if( day == DaysInMonth[month-1] ) {		// next month
 8005256:	490d      	ldr	r1, [pc, #52]	; (800528c <rtc_gettime+0x70>)
	if ( isDST(t) ) {
		t->dst = 1;
		hour++;								// add one hour
		if( hour == 24 ){					// next day
			hour = 0;
			wday++;							// next weekday
 8005258:	3701      	adds	r7, #1
			if( wday == 7 ) {
				wday = 0;
			}
			if( day == DaysInMonth[month-1] ) {		// next month
 800525a:	198a      	adds	r2, r1, r6
 800525c:	f812 3c01 	ldrb.w	r3, [r2, #-1]
	if ( isDST(t) ) {
		t->dst = 1;
		hour++;								// add one hour
		if( hour == 24 ){					// next day
			hour = 0;
			wday++;							// next weekday
 8005260:	b2ff      	uxtb	r7, r7
			if( wday == 7 ) {
				wday = 0;
 8005262:	2f07      	cmp	r7, #7
 8005264:	bf08      	it	eq
 8005266:	2700      	moveq	r7, #0
			}
			if( day == DaysInMonth[month-1] ) {		// next month
 8005268:	42ab      	cmp	r3, r5
 800526a:	d102      	bne.n	8005272 <rtc_gettime+0x56>
				day = 0;
				month++;
 800526c:	3601      	adds	r6, #1
 800526e:	b2f6      	uxtb	r6, r6
			wday++;							// next weekday
			if( wday == 7 ) {
				wday = 0;
			}
			if( day == DaysInMonth[month-1] ) {		// next month
				day = 0;
 8005270:	2500      	movs	r5, #0
				month++;
			}
			day++;
 8005272:	3501      	adds	r5, #1
 8005274:	b2ed      	uxtb	r5, r5

	if ( isDST(t) ) {
		t->dst = 1;
		hour++;								// add one hour
		if( hour == 24 ){					// next day
			hour = 0;
 8005276:	2000      	movs	r0, #0
				day = 0;
				month++;
			}
			day++;
		}
		t->month = month;
 8005278:	70a6      	strb	r6, [r4, #2]
		t->hour  = hour;
 800527a:	7160      	strb	r0, [r4, #5]
		t->mday  = day;
 800527c:	70e5      	strb	r5, [r4, #3]
		t->wday  = wday;
 800527e:	7127      	strb	r7, [r4, #4]
 8005280:	e000      	b.n	8005284 <rtc_gettime+0x68>
		return true;
	} else {
		t->dst = 0;
 8005282:	7220      	strb	r0, [r4, #8]
	while ( ( t = rtc_get_counter_val() ) != rtc_get_counter_val() ) { ; }
	counter_to_struct( t, rtc ); // get non DST time
	adjustDST( rtc );

	return true;
}
 8005284:	2001      	movs	r0, #1
 8005286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800528a:	bf00      	nop
 800528c:	08007597 	.word	0x08007597

08005290 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8005290:	4b0e      	ldr	r3, [pc, #56]	; (80052cc <prvAddCurrentTaskToDelayedList+0x3c>)
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 8005292:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8005294:	681a      	ldr	r2, [r3, #0]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 8005296:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8005298:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 800529a:	480d      	ldr	r0, [pc, #52]	; (80052d0 <prvAddCurrentTaskToDelayedList+0x40>)
 800529c:	6801      	ldr	r1, [r0, #0]
 800529e:	428c      	cmp	r4, r1
 80052a0:	d207      	bcs.n	80052b2 <prvAddCurrentTaskToDelayedList+0x22>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80052a2:	4a0c      	ldr	r2, [pc, #48]	; (80052d4 <prvAddCurrentTaskToDelayedList+0x44>)
 80052a4:	6810      	ldr	r0, [r2, #0]
 80052a6:	681b      	ldr	r3, [r3, #0]
 80052a8:	1d19      	adds	r1, r3, #4
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
 80052aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80052ae:	f000 bbe1 	b.w	8005a74 <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80052b2:	4a09      	ldr	r2, [pc, #36]	; (80052d8 <prvAddCurrentTaskToDelayedList+0x48>)
 80052b4:	6810      	ldr	r0, [r2, #0]
 80052b6:	681b      	ldr	r3, [r3, #0]
 80052b8:	1d19      	adds	r1, r3, #4
 80052ba:	f000 fbdb 	bl	8005a74 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 80052be:	4807      	ldr	r0, [pc, #28]	; (80052dc <prvAddCurrentTaskToDelayedList+0x4c>)
 80052c0:	6801      	ldr	r1, [r0, #0]
 80052c2:	428c      	cmp	r4, r1
		{
			xNextTaskUnblockTime = xTimeToWake;
 80052c4:	bf38      	it	cc
 80052c6:	6004      	strcc	r4, [r0, #0]
 80052c8:	bd10      	pop	{r4, pc}
 80052ca:	bf00      	nop
 80052cc:	200011dc 	.word	0x200011dc
 80052d0:	200011f4 	.word	0x200011f4
 80052d4:	200011f8 	.word	0x200011f8
 80052d8:	20001138 	.word	0x20001138
 80052dc:	20000004 	.word	0x20000004

080052e0 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80052e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80052e4:	4682      	mov	sl, r0
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 80052e6:	2048      	movs	r0, #72	; 0x48
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80052e8:	4688      	mov	r8, r1
 80052ea:	4693      	mov	fp, r2
 80052ec:	4699      	mov	r9, r3
 80052ee:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80052f0:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 80052f2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 80052f4:	f001 f836 	bl	8006364 <pvPortMalloc>

	if( pxNewTCB != NULL )
 80052f8:	4604      	mov	r4, r0
 80052fa:	2800      	cmp	r0, #0
 80052fc:	f000 8098 	beq.w	8005430 <xTaskGenericCreate+0x150>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005300:	b925      	cbnz	r5, 800530c <xTaskGenericCreate+0x2c>
 8005302:	ea4f 008b 	mov.w	r0, fp, lsl #2
 8005306:	f001 f82d 	bl	8006364 <pvPortMalloc>
 800530a:	4605      	mov	r5, r0
 800530c:	6325      	str	r5, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 800530e:	b91d      	cbnz	r5, 8005318 <xTaskGenericCreate+0x38>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8005310:	4620      	mov	r0, r4
 8005312:	f001 f851 	bl	80063b8 <vPortFree>
 8005316:	e08b      	b.n	8005430 <xTaskGenericCreate+0x150>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 8005318:	4628      	mov	r0, r5
 800531a:	ea4f 028b 	mov.w	r2, fp, lsl #2
 800531e:	21a5      	movs	r1, #165	; 0xa5
 8005320:	f001 f8fa 	bl	8006518 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 8005324:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005326:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 800532a:	eb03 008b 	add.w	r0, r3, fp, lsl #2
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800532e:	f020 0b07 	bic.w	fp, r0, #7
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
 8005332:	2500      	movs	r5, #0
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8005334:	f818 2005 	ldrb.w	r2, [r8, r5]

	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
 8005338:	1961      	adds	r1, r4, r5
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 800533a:	f881 2034 	strb.w	r2, [r1, #52]	; 0x34

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 800533e:	f918 3005 	ldrsb.w	r3, [r8, r5]
 8005342:	b113      	cbz	r3, 800534a <xTaskGenericCreate+0x6a>
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
 8005344:	3501      	adds	r5, #1
 8005346:	2d10      	cmp	r5, #16
 8005348:	d1f4      	bne.n	8005334 <xTaskGenericCreate+0x54>
 800534a:	2e04      	cmp	r6, #4
 800534c:	bf34      	ite	cc
 800534e:	4635      	movcc	r5, r6
 8005350:	2504      	movcs	r5, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 8005352:	2000      	movs	r0, #0
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8005354:	f104 0804 	add.w	r8, r4, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 8005358:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
 800535c:	62e5      	str	r5, [r4, #44]	; 0x2c
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800535e:	4640      	mov	r0, r8
	}

	pxTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8005360:	6465      	str	r5, [r4, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8005362:	f000 fb78 	bl	8005a56 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8005366:	f104 0018 	add.w	r0, r4, #24
 800536a:	f000 fb74 	bl	8005a56 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800536e:	f1c5 0205 	rsb	r2, r5, #5
 8005372:	61a2      	str	r2, [r4, #24]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8005374:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8005376:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8005378:	4658      	mov	r0, fp
 800537a:	4651      	mov	r1, sl
 800537c:	464a      	mov	r2, r9
 800537e:	f000 ff4b 	bl	8006218 <pxPortInitialiseStack>
 8005382:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 8005384:	b107      	cbz	r7, 8005388 <xTaskGenericCreate+0xa8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8005386:	603c      	str	r4, [r7, #0]
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 8005388:	f000 ff78 	bl	800627c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 800538c:	492a      	ldr	r1, [pc, #168]	; (8005438 <xTaskGenericCreate+0x158>)
 800538e:	680b      	ldr	r3, [r1, #0]
 8005390:	1c58      	adds	r0, r3, #1
			if( pxCurrentTCB == NULL )
 8005392:	4b2a      	ldr	r3, [pc, #168]	; (800543c <xTaskGenericCreate+0x15c>)

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 8005394:	6008      	str	r0, [r1, #0]
			if( pxCurrentTCB == NULL )
 8005396:	681d      	ldr	r5, [r3, #0]
 8005398:	bb15      	cbnz	r5, 80053e0 <xTaskGenericCreate+0x100>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 800539a:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800539c:	680b      	ldr	r3, [r1, #0]
 800539e:	2b01      	cmp	r3, #1
 80053a0:	d126      	bne.n	80053f0 <xTaskGenericCreate+0x110>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80053a2:	4927      	ldr	r1, [pc, #156]	; (8005440 <xTaskGenericCreate+0x160>)
 80053a4:	2714      	movs	r7, #20
 80053a6:	fb07 1005 	mla	r0, r7, r5, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
 80053aa:	3501      	adds	r5, #1
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80053ac:	f000 fb48 	bl	8005a40 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
 80053b0:	2d05      	cmp	r5, #5
 80053b2:	d1f6      	bne.n	80053a2 <xTaskGenericCreate+0xc2>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 80053b4:	4f23      	ldr	r7, [pc, #140]	; (8005444 <xTaskGenericCreate+0x164>)
	vListInitialise( &xDelayedTaskList2 );
 80053b6:	4d24      	ldr	r5, [pc, #144]	; (8005448 <xTaskGenericCreate+0x168>)
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 80053b8:	4638      	mov	r0, r7
 80053ba:	f000 fb41 	bl	8005a40 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 80053be:	4628      	mov	r0, r5
 80053c0:	f000 fb3e 	bl	8005a40 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 80053c4:	4821      	ldr	r0, [pc, #132]	; (800544c <xTaskGenericCreate+0x16c>)
 80053c6:	f000 fb3b 	bl	8005a40 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 80053ca:	4821      	ldr	r0, [pc, #132]	; (8005450 <xTaskGenericCreate+0x170>)
 80053cc:	f000 fb38 	bl	8005a40 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 80053d0:	4820      	ldr	r0, [pc, #128]	; (8005454 <xTaskGenericCreate+0x174>)
 80053d2:	f000 fb35 	bl	8005a40 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80053d6:	4820      	ldr	r0, [pc, #128]	; (8005458 <xTaskGenericCreate+0x178>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80053d8:	4a20      	ldr	r2, [pc, #128]	; (800545c <xTaskGenericCreate+0x17c>)
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 80053da:	6007      	str	r7, [r0, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80053dc:	6015      	str	r5, [r2, #0]
 80053de:	e007      	b.n	80053f0 <xTaskGenericCreate+0x110>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 80053e0:	4a1f      	ldr	r2, [pc, #124]	; (8005460 <xTaskGenericCreate+0x180>)
 80053e2:	6811      	ldr	r1, [r2, #0]
 80053e4:	b921      	cbnz	r1, 80053f0 <xTaskGenericCreate+0x110>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 80053e6:	6818      	ldr	r0, [r3, #0]
 80053e8:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80053ea:	42b2      	cmp	r2, r6
					{
						pxCurrentTCB = pxNewTCB;
 80053ec:	bf98      	it	ls
 80053ee:	601c      	strls	r4, [r3, #0]
					}
				}
			}

			uxTaskNumber++;
 80053f0:	4b1c      	ldr	r3, [pc, #112]	; (8005464 <xTaskGenericCreate+0x184>)
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 80053f2:	4a1d      	ldr	r2, [pc, #116]	; (8005468 <xTaskGenericCreate+0x188>)
						pxCurrentTCB = pxNewTCB;
					}
				}
			}

			uxTaskNumber++;
 80053f4:	6819      	ldr	r1, [r3, #0]
 80053f6:	1c48      	adds	r0, r1, #1
 80053f8:	6018      	str	r0, [r3, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 80053fa:	6811      	ldr	r1, [r2, #0]
 80053fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80053fe:	428b      	cmp	r3, r1
 8005400:	bf88      	it	hi
 8005402:	6013      	strhi	r3, [r2, #0]
 8005404:	4a0e      	ldr	r2, [pc, #56]	; (8005440 <xTaskGenericCreate+0x160>)
 8005406:	2014      	movs	r0, #20
 8005408:	fb00 2003 	mla	r0, r0, r3, r2
 800540c:	4641      	mov	r1, r8
 800540e:	f000 fb25 	bl	8005a5c <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8005412:	f000 ff49 	bl	80062a8 <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8005416:	4b12      	ldr	r3, [pc, #72]	; (8005460 <xTaskGenericCreate+0x180>)
 8005418:	6819      	ldr	r1, [r3, #0]
 800541a:	b131      	cbz	r1, 800542a <xTaskGenericCreate+0x14a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800541c:	4807      	ldr	r0, [pc, #28]	; (800543c <xTaskGenericCreate+0x15c>)
 800541e:	6802      	ldr	r2, [r0, #0]
 8005420:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8005422:	42b3      	cmp	r3, r6
 8005424:	d201      	bcs.n	800542a <xTaskGenericCreate+0x14a>
			{
				taskYIELD_IF_USING_PREEMPTION();
 8005426:	f000 ff15 	bl	8006254 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
 800542a:	2001      	movs	r0, #1
 800542c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8005430:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
			}
		}
	}

	return xReturn;
}
 8005434:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005438:	20001214 	.word	0x20001214
 800543c:	200011dc 	.word	0x200011dc
 8005440:	20001170 	.word	0x20001170
 8005444:	20001200 	.word	0x20001200
 8005448:	20001158 	.word	0x20001158
 800544c:	200011e0 	.word	0x200011e0
 8005450:	20001144 	.word	0x20001144
 8005454:	20001124 	.word	0x20001124
 8005458:	20001138 	.word	0x20001138
 800545c:	200011f8 	.word	0x200011f8
 8005460:	2000113c 	.word	0x2000113c
 8005464:	200011fc 	.word	0x200011fc
 8005468:	20001218 	.word	0x20001218

0800546c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
 800546c:	b538      	push	{r3, r4, r5, lr}
 800546e:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8005470:	f000 ff04 	bl	800627c <vPortEnterCritical>
		{
			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8005474:	b90c      	cbnz	r4, 800547a <vTaskDelete+0xe>
 8005476:	4b13      	ldr	r3, [pc, #76]	; (80054c4 <vTaskDelete+0x58>)
 8005478:	681c      	ldr	r4, [r3, #0]

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800547a:	1d25      	adds	r5, r4, #4
 800547c:	4628      	mov	r0, r5
 800547e:	f000 fb11 	bl	8005aa4 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8005482:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8005484:	b118      	cbz	r0, 800548e <vTaskDelete+0x22>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8005486:	f104 0018 	add.w	r0, r4, #24
 800548a:	f000 fb0b 	bl	8005aa4 <uxListRemove>
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 800548e:	480e      	ldr	r0, [pc, #56]	; (80054c8 <vTaskDelete+0x5c>)
 8005490:	4629      	mov	r1, r5
 8005492:	f000 fae3 	bl	8005a5c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 8005496:	490d      	ldr	r1, [pc, #52]	; (80054cc <vTaskDelete+0x60>)

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 8005498:	480d      	ldr	r0, [pc, #52]	; (80054d0 <vTaskDelete+0x64>)
			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 800549a:	680a      	ldr	r2, [r1, #0]
 800549c:	1c53      	adds	r3, r2, #1
 800549e:	600b      	str	r3, [r1, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 80054a0:	6801      	ldr	r1, [r0, #0]
 80054a2:	1c4a      	adds	r2, r1, #1
 80054a4:	6002      	str	r2, [r0, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 80054a6:	f000 feff 	bl	80062a8 <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 80054aa:	4b0a      	ldr	r3, [pc, #40]	; (80054d4 <vTaskDelete+0x68>)
 80054ac:	6818      	ldr	r0, [r3, #0]
 80054ae:	b138      	cbz	r0, 80054c0 <vTaskDelete+0x54>
		{
			if( pxTCB == pxCurrentTCB )
 80054b0:	4904      	ldr	r1, [pc, #16]	; (80054c4 <vTaskDelete+0x58>)
 80054b2:	680a      	ldr	r2, [r1, #0]
 80054b4:	4294      	cmp	r4, r2
 80054b6:	d103      	bne.n	80054c0 <vTaskDelete+0x54>
			{
				portYIELD_WITHIN_API();
			}
		}
	}
 80054b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxTCB == pxCurrentTCB )
			{
				portYIELD_WITHIN_API();
 80054bc:	f000 beca 	b.w	8006254 <vPortYield>
 80054c0:	bd38      	pop	{r3, r4, r5, pc}
 80054c2:	bf00      	nop
 80054c4:	200011dc 	.word	0x200011dc
 80054c8:	20001144 	.word	0x20001144
 80054cc:	20001140 	.word	0x20001140
 80054d0:	200011fc 	.word	0x200011fc
 80054d4:	2000113c 	.word	0x2000113c

080054d8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80054d8:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 80054da:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80054dc:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 80054de:	2280      	movs	r2, #128	; 0x80
 80054e0:	9400      	str	r4, [sp, #0]
 80054e2:	9401      	str	r4, [sp, #4]
 80054e4:	9402      	str	r4, [sp, #8]
 80054e6:	9403      	str	r4, [sp, #12]
 80054e8:	480c      	ldr	r0, [pc, #48]	; (800551c <vTaskStartScheduler+0x44>)
 80054ea:	490d      	ldr	r1, [pc, #52]	; (8005520 <vTaskStartScheduler+0x48>)
 80054ec:	4623      	mov	r3, r4
 80054ee:	f7ff fef7 	bl	80052e0 <xTaskGenericCreate>
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 80054f2:	2801      	cmp	r0, #1
 80054f4:	d10f      	bne.n	8005516 <vTaskStartScheduler+0x3e>
		{
			xReturn = xTimerCreateTimerTask();
 80054f6:	f000 fd61 	bl	8005fbc <xTimerCreateTimerTask>
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80054fa:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 80054fc:	4605      	mov	r5, r0
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80054fe:	d10a      	bne.n	8005516 <vTaskStartScheduler+0x3e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 8005500:	f000 feb4 	bl	800626c <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 8005504:	4b07      	ldr	r3, [pc, #28]	; (8005524 <vTaskStartScheduler+0x4c>)
		xTickCount = ( portTickType ) 0U;
 8005506:	4808      	ldr	r0, [pc, #32]	; (8005528 <vTaskStartScheduler+0x50>)
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 8005508:	601d      	str	r5, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 800550a:	6004      	str	r4, [r0, #0]
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 800550c:	b005      	add	sp, #20
 800550e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 8005512:	f000 bf0f 	b.w	8006334 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8005516:	b005      	add	sp, #20
 8005518:	bd30      	pop	{r4, r5, pc}
 800551a:	bf00      	nop
 800551c:	0800571d 	.word	0x0800571d
 8005520:	080075a3 	.word	0x080075a3
 8005524:	2000113c 	.word	0x2000113c
 8005528:	200011f4 	.word	0x200011f4

0800552c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 800552c:	4b02      	ldr	r3, [pc, #8]	; (8005538 <vTaskSuspendAll+0xc>)
 800552e:	681a      	ldr	r2, [r3, #0]
 8005530:	1c50      	adds	r0, r2, #1
 8005532:	6018      	str	r0, [r3, #0]
 8005534:	4770      	bx	lr
 8005536:	bf00      	nop
 8005538:	200011d4 	.word	0x200011d4

0800553c <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
 800553c:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800553e:	f000 fe9d 	bl	800627c <vPortEnterCritical>
	{
		xTicks = xTickCount;
 8005542:	4b03      	ldr	r3, [pc, #12]	; (8005550 <xTaskGetTickCount+0x14>)
 8005544:	681c      	ldr	r4, [r3, #0]
	}
	taskEXIT_CRITICAL();
 8005546:	f000 feaf 	bl	80062a8 <vPortExitCritical>

	return xTicks;
}
 800554a:	4620      	mov	r0, r4
 800554c:	bd10      	pop	{r4, pc}
 800554e:	bf00      	nop
 8005550:	200011f4 	.word	0x200011f4

08005554 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
 8005554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8005556:	4b36      	ldr	r3, [pc, #216]	; (8005630 <xTaskIncrementTick+0xdc>)
 8005558:	6818      	ldr	r0, [r3, #0]
 800555a:	2800      	cmp	r0, #0
 800555c:	d13c      	bne.n	80055d8 <xTaskIncrementTick+0x84>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 800555e:	4e35      	ldr	r6, [pc, #212]	; (8005634 <xTaskIncrementTick+0xe0>)
 8005560:	6833      	ldr	r3, [r6, #0]
 8005562:	1c58      	adds	r0, r3, #1
 8005564:	6030      	str	r0, [r6, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
 8005566:	6836      	ldr	r6, [r6, #0]

			if( xConstTickCount == ( portTickType ) 0U )
 8005568:	b9ae      	cbnz	r6, 8005596 <xTaskIncrementTick+0x42>
			{
				taskSWITCH_DELAYED_LISTS();
 800556a:	4d33      	ldr	r5, [pc, #204]	; (8005638 <xTaskIncrementTick+0xe4>)
 800556c:	4a33      	ldr	r2, [pc, #204]	; (800563c <xTaskIncrementTick+0xe8>)
 800556e:	6829      	ldr	r1, [r5, #0]
 8005570:	6813      	ldr	r3, [r2, #0]
 8005572:	4833      	ldr	r0, [pc, #204]	; (8005640 <xTaskIncrementTick+0xec>)
 8005574:	602b      	str	r3, [r5, #0]
 8005576:	6011      	str	r1, [r2, #0]
 8005578:	6801      	ldr	r1, [r0, #0]
 800557a:	1c4a      	adds	r2, r1, #1
 800557c:	6002      	str	r2, [r0, #0]
 800557e:	682b      	ldr	r3, [r5, #0]
 8005580:	4930      	ldr	r1, [pc, #192]	; (8005644 <xTaskIncrementTick+0xf0>)
 8005582:	6818      	ldr	r0, [r3, #0]
 8005584:	b910      	cbnz	r0, 800558c <xTaskIncrementTick+0x38>
 8005586:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800558a:	e003      	b.n	8005594 <xTaskIncrementTick+0x40>
 800558c:	682d      	ldr	r5, [r5, #0]
 800558e:	68ea      	ldr	r2, [r5, #12]
 8005590:	68d3      	ldr	r3, [r2, #12]
 8005592:	6858      	ldr	r0, [r3, #4]
 8005594:	6008      	str	r0, [r1, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 8005596:	492b      	ldr	r1, [pc, #172]	; (8005644 <xTaskIncrementTick+0xf0>)
 8005598:	2500      	movs	r5, #0
 800559a:	680a      	ldr	r2, [r1, #0]
 800559c:	4296      	cmp	r6, r2
 800559e:	d310      	bcc.n	80055c2 <xTaskIncrementTick+0x6e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80055a0:	4b25      	ldr	r3, [pc, #148]	; (8005638 <xTaskIncrementTick+0xe4>)
 80055a2:	6818      	ldr	r0, [r3, #0]
 80055a4:	6801      	ldr	r1, [r0, #0]
 80055a6:	b921      	cbnz	r1, 80055b2 <xTaskIncrementTick+0x5e>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 80055a8:	4b26      	ldr	r3, [pc, #152]	; (8005644 <xTaskIncrementTick+0xf0>)
 80055aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80055ae:	6018      	str	r0, [r3, #0]
						break;
 80055b0:	e007      	b.n	80055c2 <xTaskIncrementTick+0x6e>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80055b2:	681c      	ldr	r4, [r3, #0]
 80055b4:	68e2      	ldr	r2, [r4, #12]
 80055b6:	68d4      	ldr	r4, [r2, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 80055b8:	6863      	ldr	r3, [r4, #4]

						if( xConstTickCount < xItemValue )
 80055ba:	429e      	cmp	r6, r3
 80055bc:	d218      	bcs.n	80055f0 <xTaskIncrementTick+0x9c>
						{
							/* It is not time to unblock this item yet, but the item
							value is the time at which the task at the head of the
							blocked list must be removed from the Blocked state -
							so record the item value in xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 80055be:	4921      	ldr	r1, [pc, #132]	; (8005644 <xTaskIncrementTick+0xf0>)
 80055c0:	600b      	str	r3, [r1, #0]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 80055c2:	4a21      	ldr	r2, [pc, #132]	; (8005648 <xTaskIncrementTick+0xf4>)
 80055c4:	2314      	movs	r3, #20
 80055c6:	6811      	ldr	r1, [r2, #0]
 80055c8:	4a20      	ldr	r2, [pc, #128]	; (800564c <xTaskIncrementTick+0xf8>)
 80055ca:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 80055cc:	4358      	muls	r0, r3
 80055ce:	5811      	ldr	r1, [r2, r0]
			{
				xSwitchRequired = pdTRUE;
 80055d0:	2901      	cmp	r1, #1
 80055d2:	bf88      	it	hi
 80055d4:	2501      	movhi	r5, #1
 80055d6:	e004      	b.n	80055e2 <xTaskIncrementTick+0x8e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 80055d8:	491d      	ldr	r1, [pc, #116]	; (8005650 <xTaskIncrementTick+0xfc>)
 80055da:	680a      	ldr	r2, [r1, #0]
 80055dc:	1c55      	adds	r5, r2, #1
 80055de:	600d      	str	r5, [r1, #0]

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
 80055e0:	2500      	movs	r5, #0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 80055e2:	481c      	ldr	r0, [pc, #112]	; (8005654 <xTaskIncrementTick+0x100>)
 80055e4:	6803      	ldr	r3, [r0, #0]
		{
			xSwitchRequired = pdTRUE;
 80055e6:	2b00      	cmp	r3, #0
 80055e8:	bf0c      	ite	eq
 80055ea:	4628      	moveq	r0, r5
 80055ec:	2001      	movne	r0, #1
 80055ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
							xNextTaskUnblockTime = xItemValue;
							break;
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 80055f0:	1d27      	adds	r7, r4, #4
 80055f2:	4638      	mov	r0, r7
 80055f4:	f000 fa56 	bl	8005aa4 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80055f8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80055fa:	b118      	cbz	r0, 8005604 <xTaskIncrementTick+0xb0>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80055fc:	f104 0018 	add.w	r0, r4, #24
 8005600:	f000 fa50 	bl	8005aa4 <uxListRemove>
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8005604:	4a14      	ldr	r2, [pc, #80]	; (8005658 <xTaskIncrementTick+0x104>)
 8005606:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005608:	6811      	ldr	r1, [r2, #0]
 800560a:	428b      	cmp	r3, r1
 800560c:	bf88      	it	hi
 800560e:	6013      	strhi	r3, [r2, #0]
 8005610:	4a0e      	ldr	r2, [pc, #56]	; (800564c <xTaskIncrementTick+0xf8>)
 8005612:	2014      	movs	r0, #20
 8005614:	fb00 2003 	mla	r0, r0, r3, r2
 8005618:	4639      	mov	r1, r7
 800561a:	f000 fa1f 	bl	8005a5c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800561e:	4b0a      	ldr	r3, [pc, #40]	; (8005648 <xTaskIncrementTick+0xf4>)
 8005620:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005622:	6819      	ldr	r1, [r3, #0]
 8005624:	6aca      	ldr	r2, [r1, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 8005626:	4290      	cmp	r0, r2
 8005628:	bf28      	it	cs
 800562a:	2501      	movcs	r5, #1
 800562c:	e7b8      	b.n	80055a0 <xTaskIncrementTick+0x4c>
 800562e:	bf00      	nop
 8005630:	200011d4 	.word	0x200011d4
 8005634:	200011f4 	.word	0x200011f4
 8005638:	20001138 	.word	0x20001138
 800563c:	200011f8 	.word	0x200011f8
 8005640:	200011d8 	.word	0x200011d8
 8005644:	20000004 	.word	0x20000004
 8005648:	200011dc 	.word	0x200011dc
 800564c:	20001170 	.word	0x20001170
 8005650:	2000116c 	.word	0x2000116c
 8005654:	2000121c 	.word	0x2000121c
 8005658:	20001218 	.word	0x20001218

0800565c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 800565c:	b538      	push	{r3, r4, r5, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 800565e:	f000 fe0d 	bl	800627c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8005662:	4b26      	ldr	r3, [pc, #152]	; (80056fc <xTaskResumeAll+0xa0>)
 8005664:	681a      	ldr	r2, [r3, #0]
 8005666:	1e50      	subs	r0, r2, #1
 8005668:	6018      	str	r0, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800566a:	6819      	ldr	r1, [r3, #0]
 800566c:	b109      	cbz	r1, 8005672 <xTaskResumeAll+0x16>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
 800566e:	2400      	movs	r4, #0
 8005670:	e03f      	b.n	80056f2 <xTaskResumeAll+0x96>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 8005672:	4c23      	ldr	r4, [pc, #140]	; (8005700 <xTaskResumeAll+0xa4>)
 8005674:	6823      	ldr	r3, [r4, #0]
 8005676:	2b00      	cmp	r3, #0
 8005678:	d0f9      	beq.n	800566e <xTaskResumeAll+0x12>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800567a:	4822      	ldr	r0, [pc, #136]	; (8005704 <xTaskResumeAll+0xa8>)
 800567c:	6802      	ldr	r2, [r0, #0]
 800567e:	b302      	cbz	r2, 80056c2 <xTaskResumeAll+0x66>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8005680:	68c5      	ldr	r5, [r0, #12]
 8005682:	68ec      	ldr	r4, [r5, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8005684:	1d25      	adds	r5, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8005686:	f104 0018 	add.w	r0, r4, #24
 800568a:	f000 fa0b 	bl	8005aa4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800568e:	4628      	mov	r0, r5
 8005690:	f000 fa08 	bl	8005aa4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8005694:	4a1c      	ldr	r2, [pc, #112]	; (8005708 <xTaskResumeAll+0xac>)
 8005696:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005698:	6811      	ldr	r1, [r2, #0]
 800569a:	428b      	cmp	r3, r1
 800569c:	bf88      	it	hi
 800569e:	6013      	strhi	r3, [r2, #0]
 80056a0:	4a1a      	ldr	r2, [pc, #104]	; (800570c <xTaskResumeAll+0xb0>)
 80056a2:	2014      	movs	r0, #20
 80056a4:	fb00 2003 	mla	r0, r0, r3, r2
 80056a8:	4629      	mov	r1, r5
 80056aa:	f000 f9d7 	bl	8005a5c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80056ae:	4b18      	ldr	r3, [pc, #96]	; (8005710 <xTaskResumeAll+0xb4>)
 80056b0:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
 80056b2:	6819      	ldr	r1, [r3, #0]
 80056b4:	6ac8      	ldr	r0, [r1, #44]	; 0x2c
 80056b6:	4284      	cmp	r4, r0
 80056b8:	d3df      	bcc.n	800567a <xTaskResumeAll+0x1e>
					{
						xYieldPending = pdTRUE;
 80056ba:	4b16      	ldr	r3, [pc, #88]	; (8005714 <xTaskResumeAll+0xb8>)
 80056bc:	2201      	movs	r2, #1
 80056be:	601a      	str	r2, [r3, #0]
 80056c0:	e7db      	b.n	800567a <xTaskResumeAll+0x1e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 80056c2:	4915      	ldr	r1, [pc, #84]	; (8005718 <xTaskResumeAll+0xbc>)
 80056c4:	680c      	ldr	r4, [r1, #0]
 80056c6:	b97c      	cbnz	r4, 80056e8 <xTaskResumeAll+0x8c>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
 80056c8:	4812      	ldr	r0, [pc, #72]	; (8005714 <xTaskResumeAll+0xb8>)
 80056ca:	6804      	ldr	r4, [r0, #0]
 80056cc:	2c01      	cmp	r4, #1
 80056ce:	d1ce      	bne.n	800566e <xTaskResumeAll+0x12>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 80056d0:	f000 fdc0 	bl	8006254 <vPortYield>
 80056d4:	e00d      	b.n	80056f2 <xTaskResumeAll+0x96>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 80056d6:	f7ff ff3d 	bl	8005554 <xTaskIncrementTick>
 80056da:	b110      	cbz	r0, 80056e2 <xTaskResumeAll+0x86>
						{
							xYieldPending = pdTRUE;
 80056dc:	490d      	ldr	r1, [pc, #52]	; (8005714 <xTaskResumeAll+0xb8>)
 80056de:	2201      	movs	r2, #1
 80056e0:	600a      	str	r2, [r1, #0]
						}
						--uxPendedTicks;
 80056e2:	6823      	ldr	r3, [r4, #0]
 80056e4:	1e58      	subs	r0, r3, #1
 80056e6:	6020      	str	r0, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 80056e8:	4c0b      	ldr	r4, [pc, #44]	; (8005718 <xTaskResumeAll+0xbc>)
 80056ea:	6823      	ldr	r3, [r4, #0]
 80056ec:	2b00      	cmp	r3, #0
 80056ee:	d1f2      	bne.n	80056d6 <xTaskResumeAll+0x7a>
 80056f0:	e7ea      	b.n	80056c8 <xTaskResumeAll+0x6c>
					taskYIELD_IF_USING_PREEMPTION();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 80056f2:	f000 fdd9 	bl	80062a8 <vPortExitCritical>

	return xAlreadyYielded;
}
 80056f6:	4620      	mov	r0, r4
 80056f8:	bd38      	pop	{r3, r4, r5, pc}
 80056fa:	bf00      	nop
 80056fc:	200011d4 	.word	0x200011d4
 8005700:	20001214 	.word	0x20001214
 8005704:	200011e0 	.word	0x200011e0
 8005708:	20001218 	.word	0x20001218
 800570c:	20001170 	.word	0x20001170
 8005710:	200011dc 	.word	0x200011dc
 8005714:	2000121c 	.word	0x2000121c
 8005718:	2000116c 	.word	0x2000116c

0800571c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 800571c:	b570      	push	{r4, r5, r6, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 800571e:	4d14      	ldr	r5, [pc, #80]	; (8005770 <prvIdleTask+0x54>)
 8005720:	682b      	ldr	r3, [r5, #0]
 8005722:	b1f3      	cbz	r3, 8005762 <prvIdleTask+0x46>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8005724:	4c13      	ldr	r4, [pc, #76]	; (8005774 <prvIdleTask+0x58>)

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
 8005726:	f7ff ff01 	bl	800552c <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800572a:	6826      	ldr	r6, [r4, #0]
			( void ) xTaskResumeAll();
 800572c:	f7ff ff96 	bl	800565c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8005730:	2e00      	cmp	r6, #0
 8005732:	d0f4      	beq.n	800571e <prvIdleTask+0x2>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8005734:	f000 fda2 	bl	800627c <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8005738:	68e2      	ldr	r2, [r4, #12]
 800573a:	68d4      	ldr	r4, [r2, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 800573c:	1d20      	adds	r0, r4, #4
 800573e:	f000 f9b1 	bl	8005aa4 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8005742:	4b0d      	ldr	r3, [pc, #52]	; (8005778 <prvIdleTask+0x5c>)
 8005744:	6818      	ldr	r0, [r3, #0]
 8005746:	1e41      	subs	r1, r0, #1
 8005748:	6019      	str	r1, [r3, #0]
					--uxTasksDeleted;
 800574a:	682e      	ldr	r6, [r5, #0]
 800574c:	1e72      	subs	r2, r6, #1
 800574e:	602a      	str	r2, [r5, #0]
				}
				taskEXIT_CRITICAL();
 8005750:	f000 fdaa 	bl	80062a8 <vPortExitCritical>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8005754:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8005756:	f000 fe2f 	bl	80063b8 <vPortFree>
		vPortFree( pxTCB );
 800575a:	4620      	mov	r0, r4
 800575c:	f000 fe2c 	bl	80063b8 <vPortFree>
 8005760:	e7dd      	b.n	800571e <prvIdleTask+0x2>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8005762:	4806      	ldr	r0, [pc, #24]	; (800577c <prvIdleTask+0x60>)
 8005764:	6801      	ldr	r1, [r0, #0]
 8005766:	2901      	cmp	r1, #1
 8005768:	d9d9      	bls.n	800571e <prvIdleTask+0x2>
			{
				taskYIELD();
 800576a:	f000 fd73 	bl	8006254 <vPortYield>
 800576e:	e7d6      	b.n	800571e <prvIdleTask+0x2>
 8005770:	20001140 	.word	0x20001140
 8005774:	20001144 	.word	0x20001144
 8005778:	20001214 	.word	0x20001214
 800577c:	20001170 	.word	0x20001170

08005780 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8005780:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 8005782:	4604      	mov	r4, r0
 8005784:	b918      	cbnz	r0, 800578e <vTaskDelay+0xe>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 8005786:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 800578a:	f000 bd63 	b.w	8006254 <vPortYield>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
 800578e:	f7ff fecd 	bl	800552c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8005792:	4b08      	ldr	r3, [pc, #32]	; (80057b4 <vTaskDelay+0x34>)

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8005794:	4908      	ldr	r1, [pc, #32]	; (80057b8 <vTaskDelay+0x38>)
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8005796:	6818      	ldr	r0, [r3, #0]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8005798:	680a      	ldr	r2, [r1, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800579a:	1824      	adds	r4, r4, r0

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800579c:	1d10      	adds	r0, r2, #4
 800579e:	f000 f981 	bl	8005aa4 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 80057a2:	4620      	mov	r0, r4
 80057a4:	f7ff fd74 	bl	8005290 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 80057a8:	f7ff ff58 	bl	800565c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 80057ac:	2800      	cmp	r0, #0
 80057ae:	d0ea      	beq.n	8005786 <vTaskDelay+0x6>
		{
			portYIELD_WITHIN_API();
		}
	}
 80057b0:	bd10      	pop	{r4, pc}
 80057b2:	bf00      	nop
 80057b4:	200011f4 	.word	0x200011f4
 80057b8:	200011dc 	.word	0x200011dc

080057bc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 80057bc:	4b11      	ldr	r3, [pc, #68]	; (8005804 <vTaskSwitchContext+0x48>)
 80057be:	4812      	ldr	r0, [pc, #72]	; (8005808 <vTaskSwitchContext+0x4c>)
 80057c0:	681a      	ldr	r2, [r3, #0]
 80057c2:	b10a      	cbz	r2, 80057c8 <vTaskSwitchContext+0xc>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 80057c4:	2101      	movs	r1, #1
 80057c6:	e01a      	b.n	80057fe <vTaskSwitchContext+0x42>
	}
	else
	{
		xYieldPending = pdFALSE;
 80057c8:	6002      	str	r2, [r0, #0]
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
 80057ca:	4a10      	ldr	r2, [pc, #64]	; (800580c <vTaskSwitchContext+0x50>)
 80057cc:	2314      	movs	r3, #20
 80057ce:	6810      	ldr	r0, [r2, #0]
 80057d0:	490f      	ldr	r1, [pc, #60]	; (8005810 <vTaskSwitchContext+0x54>)
 80057d2:	4358      	muls	r0, r3
 80057d4:	5808      	ldr	r0, [r1, r0]
 80057d6:	b918      	cbnz	r0, 80057e0 <vTaskSwitchContext+0x24>
 80057d8:	6813      	ldr	r3, [r2, #0]
 80057da:	1e59      	subs	r1, r3, #1
 80057dc:	6011      	str	r1, [r2, #0]
 80057de:	e7f4      	b.n	80057ca <vTaskSwitchContext+0xe>
 80057e0:	6812      	ldr	r2, [r2, #0]
 80057e2:	fb03 1302 	mla	r3, r3, r2, r1
 80057e6:	6859      	ldr	r1, [r3, #4]
 80057e8:	f103 0208 	add.w	r2, r3, #8
 80057ec:	6848      	ldr	r0, [r1, #4]
 80057ee:	4290      	cmp	r0, r2
 80057f0:	6058      	str	r0, [r3, #4]
 80057f2:	bf04      	itt	eq
 80057f4:	6840      	ldreq	r0, [r0, #4]
 80057f6:	6058      	streq	r0, [r3, #4]
 80057f8:	685b      	ldr	r3, [r3, #4]
 80057fa:	4806      	ldr	r0, [pc, #24]	; (8005814 <vTaskSwitchContext+0x58>)
 80057fc:	68d9      	ldr	r1, [r3, #12]
 80057fe:	6001      	str	r1, [r0, #0]
 8005800:	4770      	bx	lr
 8005802:	bf00      	nop
 8005804:	200011d4 	.word	0x200011d4
 8005808:	2000121c 	.word	0x2000121c
 800580c:	20001218 	.word	0x20001218
 8005810:	20001170 	.word	0x20001170
 8005814:	200011dc 	.word	0x200011dc

08005818 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
 8005818:	b538      	push	{r3, r4, r5, lr}
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800581a:	4c0d      	ldr	r4, [pc, #52]	; (8005850 <vTaskPlaceOnEventList+0x38>)
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
 800581c:	460d      	mov	r5, r1
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800581e:	6821      	ldr	r1, [r4, #0]
 8005820:	3118      	adds	r1, #24
 8005822:	f000 f927 	bl	8005a74 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8005826:	6820      	ldr	r0, [r4, #0]
 8005828:	3004      	adds	r0, #4
 800582a:	f000 f93b 	bl	8005aa4 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 800582e:	1c69      	adds	r1, r5, #1
 8005830:	d106      	bne.n	8005840 <vTaskPlaceOnEventList+0x28>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8005832:	6822      	ldr	r2, [r4, #0]
 8005834:	4807      	ldr	r0, [pc, #28]	; (8005854 <vTaskPlaceOnEventList+0x3c>)
 8005836:	1d11      	adds	r1, r2, #4
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8005838:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 800583c:	f000 b90e 	b.w	8005a5c <vListInsertEnd>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 8005840:	4b05      	ldr	r3, [pc, #20]	; (8005858 <vTaskPlaceOnEventList+0x40>)
 8005842:	6819      	ldr	r1, [r3, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8005844:	1868      	adds	r0, r5, r1
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8005846:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 800584a:	f7ff bd21 	b.w	8005290 <prvAddCurrentTaskToDelayedList>
 800584e:	bf00      	nop
 8005850:	200011dc 	.word	0x200011dc
 8005854:	20001124 	.word	0x20001124
 8005858:	200011f4 	.word	0x200011f4

0800585c <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
	{
 800585c:	b538      	push	{r3, r4, r5, lr}

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800585e:	4c08      	ldr	r4, [pc, #32]	; (8005880 <vTaskPlaceOnEventListRestricted+0x24>)
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
	{
 8005860:	460d      	mov	r5, r1

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8005862:	6821      	ldr	r1, [r4, #0]
 8005864:	3118      	adds	r1, #24
 8005866:	f000 f8f9 	bl	8005a5c <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 800586a:	6820      	ldr	r0, [r4, #0]
 800586c:	3004      	adds	r0, #4
 800586e:	f000 f919 	bl	8005aa4 <uxListRemove>
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 8005872:	4b04      	ldr	r3, [pc, #16]	; (8005884 <vTaskPlaceOnEventListRestricted+0x28>)
 8005874:	6819      	ldr	r1, [r3, #0]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8005876:	1868      	adds	r0, r5, r1
	}
 8005878:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 800587c:	f7ff bd08 	b.w	8005290 <prvAddCurrentTaskToDelayedList>
 8005880:	200011dc 	.word	0x200011dc
 8005884:	200011f4 	.word	0x200011f4

08005888 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8005888:	b538      	push	{r3, r4, r5, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800588a:	68c3      	ldr	r3, [r0, #12]
 800588c:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800588e:	f104 0518 	add.w	r5, r4, #24
 8005892:	4628      	mov	r0, r5
 8005894:	f000 f906 	bl	8005aa4 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8005898:	4810      	ldr	r0, [pc, #64]	; (80058dc <xTaskRemoveFromEventList+0x54>)
 800589a:	6801      	ldr	r1, [r0, #0]
 800589c:	b971      	cbnz	r1, 80058bc <xTaskRemoveFromEventList+0x34>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 800589e:	1d25      	adds	r5, r4, #4
 80058a0:	4628      	mov	r0, r5
 80058a2:	f000 f8ff 	bl	8005aa4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 80058a6:	4a0e      	ldr	r2, [pc, #56]	; (80058e0 <xTaskRemoveFromEventList+0x58>)
 80058a8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80058aa:	6810      	ldr	r0, [r2, #0]
 80058ac:	4283      	cmp	r3, r0
 80058ae:	bf88      	it	hi
 80058b0:	6013      	strhi	r3, [r2, #0]
 80058b2:	4a0c      	ldr	r2, [pc, #48]	; (80058e4 <xTaskRemoveFromEventList+0x5c>)
 80058b4:	2114      	movs	r1, #20
 80058b6:	fb01 2003 	mla	r0, r1, r3, r2
 80058ba:	e000      	b.n	80058be <xTaskRemoveFromEventList+0x36>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80058bc:	480a      	ldr	r0, [pc, #40]	; (80058e8 <xTaskRemoveFromEventList+0x60>)
 80058be:	4629      	mov	r1, r5
 80058c0:	f000 f8cc 	bl	8005a5c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80058c4:	4b09      	ldr	r3, [pc, #36]	; (80058ec <xTaskRemoveFromEventList+0x64>)
 80058c6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80058c8:	6818      	ldr	r0, [r3, #0]
 80058ca:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80058cc:	4291      	cmp	r1, r2
 80058ce:	d303      	bcc.n	80058d8 <xTaskRemoveFromEventList+0x50>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 80058d0:	4b07      	ldr	r3, [pc, #28]	; (80058f0 <xTaskRemoveFromEventList+0x68>)
 80058d2:	2001      	movs	r0, #1
 80058d4:	6018      	str	r0, [r3, #0]
 80058d6:	bd38      	pop	{r3, r4, r5, pc}
	}
	else
	{
		xReturn = pdFALSE;
 80058d8:	2000      	movs	r0, #0
	}

	return xReturn;
}
 80058da:	bd38      	pop	{r3, r4, r5, pc}
 80058dc:	200011d4 	.word	0x200011d4
 80058e0:	20001218 	.word	0x20001218
 80058e4:	20001170 	.word	0x20001170
 80058e8:	200011e0 	.word	0x200011e0
 80058ec:	200011dc 	.word	0x200011dc
 80058f0:	2000121c 	.word	0x2000121c

080058f4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80058f4:	4b03      	ldr	r3, [pc, #12]	; (8005904 <vTaskSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 80058f6:	4a04      	ldr	r2, [pc, #16]	; (8005908 <vTaskSetTimeOutState+0x14>)
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80058f8:	6819      	ldr	r1, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80058fa:	6813      	ldr	r3, [r2, #0]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80058fc:	6001      	str	r1, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80058fe:	6043      	str	r3, [r0, #4]
 8005900:	4770      	bx	lr
 8005902:	bf00      	nop
 8005904:	200011d8 	.word	0x200011d8
 8005908:	200011f4 	.word	0x200011f4

0800590c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 800590c:	b538      	push	{r3, r4, r5, lr}
 800590e:	4604      	mov	r4, r0
 8005910:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 8005912:	f000 fcb3 	bl	800627c <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
 8005916:	4b0e      	ldr	r3, [pc, #56]	; (8005950 <xTaskCheckForTimeOut+0x44>)
 8005918:	681a      	ldr	r2, [r3, #0]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 800591a:	682b      	ldr	r3, [r5, #0]
 800591c:	1c58      	adds	r0, r3, #1
 800591e:	d010      	beq.n	8005942 <xTaskCheckForTimeOut+0x36>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005920:	490c      	ldr	r1, [pc, #48]	; (8005954 <xTaskCheckForTimeOut+0x48>)
 8005922:	6808      	ldr	r0, [r1, #0]
 8005924:	6821      	ldr	r1, [r4, #0]
 8005926:	4288      	cmp	r0, r1
 8005928:	6860      	ldr	r0, [r4, #4]
 800592a:	d001      	beq.n	8005930 <xTaskCheckForTimeOut+0x24>
 800592c:	4282      	cmp	r2, r0
 800592e:	d20a      	bcs.n	8005946 <xTaskCheckForTimeOut+0x3a>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8005930:	1a11      	subs	r1, r2, r0
 8005932:	4299      	cmp	r1, r3
 8005934:	d207      	bcs.n	8005946 <xTaskCheckForTimeOut+0x3a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 8005936:	1a82      	subs	r2, r0, r2
 8005938:	18d3      	adds	r3, r2, r3
 800593a:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 800593c:	4620      	mov	r0, r4
 800593e:	f7ff ffd9 	bl	80058f4 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 8005942:	2400      	movs	r4, #0
 8005944:	e000      	b.n	8005948 <xTaskCheckForTimeOut+0x3c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8005946:	2401      	movs	r4, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8005948:	f000 fcae 	bl	80062a8 <vPortExitCritical>

	return xReturn;
}
 800594c:	4620      	mov	r0, r4
 800594e:	bd38      	pop	{r3, r4, r5, pc}
 8005950:	200011f4 	.word	0x200011f4
 8005954:	200011d8 	.word	0x200011d8

08005958 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 8005958:	4b01      	ldr	r3, [pc, #4]	; (8005960 <vTaskMissedYield+0x8>)
 800595a:	2201      	movs	r2, #1
 800595c:	601a      	str	r2, [r3, #0]
 800595e:	4770      	bx	lr
 8005960:	2000121c 	.word	0x2000121c

08005964 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8005964:	4b01      	ldr	r3, [pc, #4]	; (800596c <xTaskGetCurrentTaskHandle+0x8>)
 8005966:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
 8005968:	4770      	bx	lr
 800596a:	bf00      	nop
 800596c:	200011dc 	.word	0x200011dc

08005970 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
 8005970:	4b04      	ldr	r3, [pc, #16]	; (8005984 <xTaskGetSchedulerState+0x14>)
 8005972:	6818      	ldr	r0, [r3, #0]
 8005974:	b128      	cbz	r0, 8005982 <xTaskGetSchedulerState+0x12>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8005976:	4804      	ldr	r0, [pc, #16]	; (8005988 <xTaskGetSchedulerState+0x18>)
 8005978:	6801      	ldr	r1, [r0, #0]
			{
				xReturn = taskSCHEDULER_RUNNING;
 800597a:	2900      	cmp	r1, #0
 800597c:	bf14      	ite	ne
 800597e:	2002      	movne	r0, #2
 8005980:	2001      	moveq	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 8005982:	4770      	bx	lr
 8005984:	2000113c 	.word	0x2000113c
 8005988:	200011d4 	.word	0x200011d4

0800598c <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
	{
 800598c:	b570      	push	{r4, r5, r6, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 800598e:	4604      	mov	r4, r0
 8005990:	2800      	cmp	r0, #0
 8005992:	d029      	beq.n	80059e8 <vTaskPriorityInherit+0x5c>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8005994:	4d15      	ldr	r5, [pc, #84]	; (80059ec <vTaskPriorityInherit+0x60>)
 8005996:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8005998:	682a      	ldr	r2, [r5, #0]
 800599a:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 800599c:	4283      	cmp	r3, r0
 800599e:	d223      	bcs.n	80059e8 <vTaskPriorityInherit+0x5c>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80059a0:	6829      	ldr	r1, [r5, #0]
 80059a2:	6aca      	ldr	r2, [r1, #44]	; 0x2c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80059a4:	2114      	movs	r1, #20
		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80059a6:	f1c2 0005 	rsb	r0, r2, #5

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80059aa:	4a11      	ldr	r2, [pc, #68]	; (80059f0 <vTaskPriorityInherit+0x64>)
		if( pxMutexHolder != NULL )
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80059ac:	61a0      	str	r0, [r4, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80059ae:	fb01 2303 	mla	r3, r1, r3, r2
 80059b2:	6960      	ldr	r0, [r4, #20]
 80059b4:	4298      	cmp	r0, r3
 80059b6:	d114      	bne.n	80059e2 <vTaskPriorityInherit+0x56>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 80059b8:	1d26      	adds	r6, r4, #4
 80059ba:	4630      	mov	r0, r6
 80059bc:	f000 f872 	bl	8005aa4 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80059c0:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 80059c2:	480c      	ldr	r0, [pc, #48]	; (80059f4 <vTaskPriorityInherit+0x68>)
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80059c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80059c6:	6801      	ldr	r1, [r0, #0]
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80059c8:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80059ca:	428b      	cmp	r3, r1
 80059cc:	d900      	bls.n	80059d0 <vTaskPriorityInherit+0x44>
 80059ce:	6003      	str	r3, [r0, #0]
 80059d0:	4a07      	ldr	r2, [pc, #28]	; (80059f0 <vTaskPriorityInherit+0x64>)
 80059d2:	2014      	movs	r0, #20
 80059d4:	fb00 2003 	mla	r0, r0, r3, r2
 80059d8:	4631      	mov	r1, r6
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
 80059da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
 80059de:	f000 b83d 	b.w	8005a5c <vListInsertEnd>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80059e2:	6829      	ldr	r1, [r5, #0]
 80059e4:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 80059e6:	62e2      	str	r2, [r4, #44]	; 0x2c
 80059e8:	bd70      	pop	{r4, r5, r6, pc}
 80059ea:	bf00      	nop
 80059ec:	200011dc 	.word	0x200011dc
 80059f0:	20001170 	.word	0x20001170
 80059f4:	20001218 	.word	0x20001218

080059f8 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
	{
 80059f8:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
 80059fa:	4604      	mov	r4, r0
 80059fc:	b1d0      	cbz	r0, 8005a34 <vTaskPriorityDisinherit+0x3c>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80059fe:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8005a00:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8005a02:	429a      	cmp	r2, r3
 8005a04:	d016      	beq.n	8005a34 <vTaskPriorityDisinherit+0x3c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8005a06:	1d05      	adds	r5, r0, #4
 8005a08:	4628      	mov	r0, r5
 8005a0a:	f000 f84b 	bl	8005aa4 <uxListRemove>
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				prvAddTaskToReadyList( pxTCB );
 8005a0e:	4a0a      	ldr	r2, [pc, #40]	; (8005a38 <vTaskPriorityDisinherit+0x40>)
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8005a10:	6c63      	ldr	r3, [r4, #68]	; 0x44
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				prvAddTaskToReadyList( pxTCB );
 8005a12:	6811      	ldr	r1, [r2, #0]

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005a14:	f1c3 0005 	rsb	r0, r3, #5
				prvAddTaskToReadyList( pxTCB );
 8005a18:	428b      	cmp	r3, r1
 8005a1a:	bf88      	it	hi
 8005a1c:	6013      	strhi	r3, [r2, #0]
 8005a1e:	4a07      	ldr	r2, [pc, #28]	; (8005a3c <vTaskPriorityDisinherit+0x44>)

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005a20:	61a0      	str	r0, [r4, #24]
				prvAddTaskToReadyList( pxTCB );
 8005a22:	2014      	movs	r0, #20
 8005a24:	fb00 2003 	mla	r0, r0, r3, r2
 8005a28:	4629      	mov	r1, r5
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8005a2a:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				prvAddTaskToReadyList( pxTCB );
			}
		}
	}
 8005a2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				prvAddTaskToReadyList( pxTCB );
 8005a30:	f000 b814 	b.w	8005a5c <vListInsertEnd>
 8005a34:	bd38      	pop	{r3, r4, r5, pc}
 8005a36:	bf00      	nop
 8005a38:	20001218 	.word	0x20001218
 8005a3c:	20001170 	.word	0x20001170

08005a40 <vListInitialise>:
void vListInitialise( xList * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005a40:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005a44:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8005a48:	2100      	movs	r1, #0
void vListInitialise( xList * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005a4a:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005a4c:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005a4e:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005a50:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8005a52:	6001      	str	r1, [r0, #0]
 8005a54:	4770      	bx	lr

08005a56 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8005a56:	2300      	movs	r3, #0
 8005a58:	6103      	str	r3, [r0, #16]
 8005a5a:	4770      	bx	lr

08005a5c <vListInsertEnd>:
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
 8005a5c:	6843      	ldr	r3, [r0, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005a5e:	6108      	str	r0, [r1, #16]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8005a60:	689a      	ldr	r2, [r3, #8]
	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex;
 8005a62:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8005a64:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8005a66:	689a      	ldr	r2, [r3, #8]
	pxIndex->pxPrevious = pxNewListItem;
 8005a68:	6099      	str	r1, [r3, #8]
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8005a6a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005a6c:	6801      	ldr	r1, [r0, #0]
 8005a6e:	1c4b      	adds	r3, r1, #1
 8005a70:	6003      	str	r3, [r0, #0]
 8005a72:	4770      	bx	lr

08005a74 <vListInsert>:
{
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8005a74:	680a      	ldr	r2, [r1, #0]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
 8005a76:	b530      	push	{r4, r5, lr}
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8005a78:	1c53      	adds	r3, r2, #1
 8005a7a:	d101      	bne.n	8005a80 <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8005a7c:	6903      	ldr	r3, [r0, #16]
 8005a7e:	e007      	b.n	8005a90 <vListInsert+0x1c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005a80:	f100 0308 	add.w	r3, r0, #8
 8005a84:	685c      	ldr	r4, [r3, #4]
 8005a86:	6825      	ldr	r5, [r4, #0]
 8005a88:	4295      	cmp	r5, r2
 8005a8a:	d801      	bhi.n	8005a90 <vListInsert+0x1c>
 8005a8c:	4623      	mov	r3, r4
 8005a8e:	e7f9      	b.n	8005a84 <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005a90:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005a92:	6108      	str	r0, [r1, #16]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005a94:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8005a96:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;
 8005a98:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8005a9a:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005a9c:	6801      	ldr	r1, [r0, #0]
 8005a9e:	1c4b      	adds	r3, r1, #1
 8005aa0:	6003      	str	r3, [r0, #0]
 8005aa2:	bd30      	pop	{r4, r5, pc}

08005aa4 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8005aa4:	6843      	ldr	r3, [r0, #4]
 8005aa6:	6882      	ldr	r2, [r0, #8]
 8005aa8:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8005aaa:	6882      	ldr	r2, [r0, #8]
 8005aac:	6053      	str	r3, [r2, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8005aae:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8005ab0:	6859      	ldr	r1, [r3, #4]
 8005ab2:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8005ab4:	bf08      	it	eq
 8005ab6:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8005ab8:	2200      	movs	r2, #0
 8005aba:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8005abc:	6818      	ldr	r0, [r3, #0]
 8005abe:	3801      	subs	r0, #1
 8005ac0:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8005ac2:	4770      	bx	lr

08005ac4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
 8005ac4:	b510      	push	{r4, lr}
 8005ac6:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8005ac8:	f000 fbd8 	bl	800627c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8005acc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005ace:	2b00      	cmp	r3, #0
 8005ad0:	dd0c      	ble.n	8005aec <prvUnlockQueue+0x28>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005ad2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005ad4:	b150      	cbz	r0, 8005aec <prvUnlockQueue+0x28>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005ad6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005ada:	f7ff fed5 	bl	8005888 <xTaskRemoveFromEventList>
 8005ade:	b108      	cbz	r0, 8005ae4 <prvUnlockQueue+0x20>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8005ae0:	f7ff ff3a 	bl	8005958 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8005ae4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005ae6:	1e58      	subs	r0, r3, #1
 8005ae8:	64a0      	str	r0, [r4, #72]	; 0x48
 8005aea:	e7ef      	b.n	8005acc <prvUnlockQueue+0x8>
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8005aec:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8005af0:	64a1      	str	r1, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8005af2:	f000 fbd9 	bl	80062a8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8005af6:	f000 fbc1 	bl	800627c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8005afa:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8005afc:	2a00      	cmp	r2, #0
 8005afe:	dd0c      	ble.n	8005b1a <prvUnlockQueue+0x56>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005b00:	6923      	ldr	r3, [r4, #16]
 8005b02:	b153      	cbz	r3, 8005b1a <prvUnlockQueue+0x56>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005b04:	f104 0010 	add.w	r0, r4, #16
 8005b08:	f7ff febe 	bl	8005888 <xTaskRemoveFromEventList>
 8005b0c:	b108      	cbz	r0, 8005b12 <prvUnlockQueue+0x4e>
				{
					vTaskMissedYield();
 8005b0e:	f7ff ff23 	bl	8005958 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 8005b12:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8005b14:	1e4a      	subs	r2, r1, #1
 8005b16:	6462      	str	r2, [r4, #68]	; 0x44
 8005b18:	e7ef      	b.n	8005afa <prvUnlockQueue+0x36>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8005b1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005b1e:	6460      	str	r0, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8005b20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8005b24:	f000 bbc0 	b.w	80062a8 <vPortExitCritical>

08005b28 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
 8005b28:	b570      	push	{r4, r5, r6, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005b2a:	6804      	ldr	r4, [r0, #0]
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
 8005b2c:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005b2e:	b16c      	cbz	r4, 8005b4c <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8005b30:	68c5      	ldr	r5, [r0, #12]
 8005b32:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8005b34:	6846      	ldr	r6, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8005b36:	18ad      	adds	r5, r5, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8005b38:	42b5      	cmp	r5, r6

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8005b3a:	60c5      	str	r5, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8005b3c:	bf28      	it	cs
 8005b3e:	60c4      	strcs	r4, [r0, #12]
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8005b40:	4608      	mov	r0, r1
 8005b42:	68d9      	ldr	r1, [r3, #12]
	}
}
 8005b44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8005b48:	f000 bc38 	b.w	80063bc <memcpy>
 8005b4c:	bd70      	pop	{r4, r5, r6, pc}

08005b4e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005b4e:	b538      	push	{r3, r4, r5, lr}
 8005b50:	4615      	mov	r5, r2
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005b52:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005b54:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005b56:	b932      	cbnz	r2, 8005b66 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005b58:	6805      	ldr	r5, [r0, #0]
 8005b5a:	bb3d      	cbnz	r5, 8005bac <prvCopyDataToQueue+0x5e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8005b5c:	6840      	ldr	r0, [r0, #4]
 8005b5e:	f7ff ff4b 	bl	80059f8 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8005b62:	6065      	str	r5, [r4, #4]
 8005b64:	e022      	b.n	8005bac <prvCopyDataToQueue+0x5e>
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8005b66:	b965      	cbnz	r5, 8005b82 <prvCopyDataToQueue+0x34>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8005b68:	6880      	ldr	r0, [r0, #8]
 8005b6a:	f000 fc27 	bl	80063bc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005b6e:	68a0      	ldr	r0, [r4, #8]
 8005b70:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005b72:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005b74:	18c1      	adds	r1, r0, r3
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005b76:	4291      	cmp	r1, r2
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005b78:	60a1      	str	r1, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005b7a:	d317      	bcc.n	8005bac <prvCopyDataToQueue+0x5e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8005b7c:	6820      	ldr	r0, [r4, #0]
 8005b7e:	60a0      	str	r0, [r4, #8]
 8005b80:	e014      	b.n	8005bac <prvCopyDataToQueue+0x5e>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005b82:	68c0      	ldr	r0, [r0, #12]
 8005b84:	f000 fc1a 	bl	80063bc <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005b88:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005b8a:	68e2      	ldr	r2, [r4, #12]
 8005b8c:	4258      	negs	r0, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005b8e:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005b90:	1813      	adds	r3, r2, r0
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005b92:	428b      	cmp	r3, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005b94:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005b96:	d202      	bcs.n	8005b9e <prvCopyDataToQueue+0x50>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8005b98:	6862      	ldr	r2, [r4, #4]
 8005b9a:	1810      	adds	r0, r2, r0
 8005b9c:	60e0      	str	r0, [r4, #12]
		}

		if( xPosition == queueOVERWRITE )
 8005b9e:	2d02      	cmp	r5, #2
 8005ba0:	d104      	bne.n	8005bac <prvCopyDataToQueue+0x5e>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8005ba2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005ba4:	b113      	cbz	r3, 8005bac <prvCopyDataToQueue+0x5e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 8005ba6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8005ba8:	1e4a      	subs	r2, r1, #1
 8005baa:	63a2      	str	r2, [r4, #56]	; 0x38
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8005bac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005bae:	1c59      	adds	r1, r3, #1
 8005bb0:	63a1      	str	r1, [r4, #56]	; 0x38
 8005bb2:	bd38      	pop	{r3, r4, r5, pc}

08005bb4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
 8005bb4:	b538      	push	{r3, r4, r5, lr}
 8005bb6:	4604      	mov	r4, r0
 8005bb8:	460d      	mov	r5, r1
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 8005bba:	f000 fb5f 	bl	800627c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005bbe:	6823      	ldr	r3, [r4, #0]
 8005bc0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8005bc2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8005bc4:	60a3      	str	r3, [r4, #8]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005bc6:	fb00 3102 	mla	r1, r0, r2, r3
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005bca:	3801      	subs	r0, #1
 8005bcc:	fb02 3300 	mla	r3, r2, r0, r3

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005bd0:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005bd2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005bd6:	2100      	movs	r1, #0
 8005bd8:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005bda:	60e3      	str	r3, [r4, #12]
		pxQueue->xRxLock = queueUNLOCKED;
 8005bdc:	6462      	str	r2, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8005bde:	64a2      	str	r2, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 8005be0:	b955      	cbnz	r5, 8005bf8 <xQueueGenericReset+0x44>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005be2:	6921      	ldr	r1, [r4, #16]
 8005be4:	b181      	cbz	r1, 8005c08 <xQueueGenericReset+0x54>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8005be6:	f104 0010 	add.w	r0, r4, #16
 8005bea:	f7ff fe4d 	bl	8005888 <xTaskRemoveFromEventList>
 8005bee:	2801      	cmp	r0, #1
 8005bf0:	d10a      	bne.n	8005c08 <xQueueGenericReset+0x54>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8005bf2:	f000 fb2f 	bl	8006254 <vPortYield>
 8005bf6:	e007      	b.n	8005c08 <xQueueGenericReset+0x54>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8005bf8:	f104 0010 	add.w	r0, r4, #16
 8005bfc:	f7ff ff20 	bl	8005a40 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8005c00:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005c04:	f7ff ff1c 	bl	8005a40 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8005c08:	f000 fb4e 	bl	80062a8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8005c0c:	2001      	movs	r0, #1
 8005c0e:	bd38      	pop	{r3, r4, r5, pc}

08005c10 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
 8005c10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005c12:	460f      	mov	r7, r1
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 8005c14:	4605      	mov	r5, r0
 8005c16:	b908      	cbnz	r0, 8005c1c <xQueueGenericCreate+0xc>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
 8005c18:	2000      	movs	r0, #0
 8005c1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8005c1c:	204c      	movs	r0, #76	; 0x4c
 8005c1e:	f000 fba1 	bl	8006364 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8005c22:	4604      	mov	r4, r0
 8005c24:	2800      	cmp	r0, #0
 8005c26:	d0f7      	beq.n	8005c18 <xQueueGenericCreate+0x8>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005c28:	fb05 f007 	mul.w	r0, r5, r7

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 8005c2c:	3001      	adds	r0, #1
 8005c2e:	f000 fb99 	bl	8006364 <pvPortMalloc>
 8005c32:	4606      	mov	r6, r0
 8005c34:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
 8005c36:	b138      	cbz	r0, 8005c48 <xQueueGenericCreate+0x38>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 8005c38:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8005c3a:	6427      	str	r7, [r4, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8005c3c:	4620      	mov	r0, r4
 8005c3e:	2101      	movs	r1, #1
 8005c40:	f7ff ffb8 	bl	8005bb4 <xQueueGenericReset>
 8005c44:	4620      	mov	r0, r4
 8005c46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 8005c48:	4620      	mov	r0, r4
 8005c4a:	f000 fbb5 	bl	80063b8 <vPortFree>
 8005c4e:	e7e3      	b.n	8005c18 <xQueueGenericCreate+0x8>

08005c50 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8005c50:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8005c54:	4604      	mov	r4, r0
 8005c56:	4688      	mov	r8, r1
 8005c58:	9201      	str	r2, [sp, #4]
 8005c5a:	461d      	mov	r5, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8005c5c:	2600      	movs	r6, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8005c5e:	f000 fb0d 	bl	800627c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8005c62:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8005c64:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005c66:	429a      	cmp	r2, r3
 8005c68:	d301      	bcc.n	8005c6e <xQueueGenericSend+0x1e>
 8005c6a:	2d02      	cmp	r5, #2
 8005c6c:	d112      	bne.n	8005c94 <xQueueGenericSend+0x44>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8005c6e:	4620      	mov	r0, r4
 8005c70:	4641      	mov	r1, r8
 8005c72:	462a      	mov	r2, r5
 8005c74:	f7ff ff6b 	bl	8005b4e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005c78:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005c7a:	b138      	cbz	r0, 8005c8c <xQueueGenericSend+0x3c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8005c7c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005c80:	f7ff fe02 	bl	8005888 <xTaskRemoveFromEventList>
 8005c84:	2801      	cmp	r0, #1
 8005c86:	d101      	bne.n	8005c8c <xQueueGenericSend+0x3c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 8005c88:	f000 fae4 	bl	8006254 <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8005c8c:	f000 fb0c 	bl	80062a8 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 8005c90:	2001      	movs	r0, #1
 8005c92:	e043      	b.n	8005d1c <xQueueGenericSend+0xcc>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8005c94:	9f01      	ldr	r7, [sp, #4]
 8005c96:	b917      	cbnz	r7, 8005c9e <xQueueGenericSend+0x4e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8005c98:	f000 fb06 	bl	80062a8 <vPortExitCritical>
 8005c9c:	e03d      	b.n	8005d1a <xQueueGenericSend+0xca>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 8005c9e:	b916      	cbnz	r6, 8005ca6 <xQueueGenericSend+0x56>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8005ca0:	a802      	add	r0, sp, #8
 8005ca2:	f7ff fe27 	bl	80058f4 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
 8005ca6:	f000 faff 	bl	80062a8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8005caa:	f7ff fc3f 	bl	800552c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8005cae:	f000 fae5 	bl	800627c <vPortEnterCritical>
 8005cb2:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8005cb4:	1c43      	adds	r3, r0, #1
 8005cb6:	d101      	bne.n	8005cbc <xQueueGenericSend+0x6c>
 8005cb8:	2100      	movs	r1, #0
 8005cba:	6461      	str	r1, [r4, #68]	; 0x44
 8005cbc:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8005cbe:	1c53      	adds	r3, r2, #1
 8005cc0:	d101      	bne.n	8005cc6 <xQueueGenericSend+0x76>
 8005cc2:	2300      	movs	r3, #0
 8005cc4:	64a3      	str	r3, [r4, #72]	; 0x48
 8005cc6:	f000 faef 	bl	80062a8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8005cca:	a802      	add	r0, sp, #8
 8005ccc:	a901      	add	r1, sp, #4
 8005cce:	f7ff fe1d 	bl	800590c <xTaskCheckForTimeOut>
 8005cd2:	b9e8      	cbnz	r0, 8005d10 <xQueueGenericSend+0xc0>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8005cd4:	f000 fad2 	bl	800627c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8005cd8:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8005cda:	6be6      	ldr	r6, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8005cdc:	f000 fae4 	bl	80062a8 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8005ce0:	42b7      	cmp	r7, r6
 8005ce2:	d10f      	bne.n	8005d04 <xQueueGenericSend+0xb4>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8005ce4:	f104 0010 	add.w	r0, r4, #16
 8005ce8:	9901      	ldr	r1, [sp, #4]
 8005cea:	f7ff fd95 	bl	8005818 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8005cee:	4620      	mov	r0, r4
 8005cf0:	f7ff fee8 	bl	8005ac4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8005cf4:	f7ff fcb2 	bl	800565c <xTaskResumeAll>
 8005cf8:	b108      	cbz	r0, 8005cfe <xQueueGenericSend+0xae>
 8005cfa:	2601      	movs	r6, #1
 8005cfc:	e7af      	b.n	8005c5e <xQueueGenericSend+0xe>
				{
					portYIELD_WITHIN_API();
 8005cfe:	f000 faa9 	bl	8006254 <vPortYield>
 8005d02:	e7fa      	b.n	8005cfa <xQueueGenericSend+0xaa>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8005d04:	4620      	mov	r0, r4
 8005d06:	f7ff fedd 	bl	8005ac4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8005d0a:	f7ff fca7 	bl	800565c <xTaskResumeAll>
 8005d0e:	e7f4      	b.n	8005cfa <xQueueGenericSend+0xaa>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8005d10:	4620      	mov	r0, r4
 8005d12:	f7ff fed7 	bl	8005ac4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8005d16:	f7ff fca1 	bl	800565c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8005d1a:	2000      	movs	r0, #0
		}
	}
}
 8005d1c:	b004      	add	sp, #16
 8005d1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005d22 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 8005d22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005d26:	4604      	mov	r4, r0
 8005d28:	4615      	mov	r5, r2
 8005d2a:	461e      	mov	r6, r3
 8005d2c:	4688      	mov	r8, r1
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8005d2e:	f000 fa9d 	bl	800626c <ulPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8005d32:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8005d34:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8005d36:	4607      	mov	r7, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8005d38:	429a      	cmp	r2, r3
 8005d3a:	d301      	bcc.n	8005d40 <xQueueGenericSendFromISR+0x1e>
 8005d3c:	2e02      	cmp	r6, #2
 8005d3e:	d117      	bne.n	8005d70 <xQueueGenericSendFromISR+0x4e>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8005d40:	4620      	mov	r0, r4
 8005d42:	4641      	mov	r1, r8
 8005d44:	4632      	mov	r2, r6
 8005d46:	f7ff ff02 	bl	8005b4e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8005d4a:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8005d4c:	1c43      	adds	r3, r0, #1
 8005d4e:	d10a      	bne.n	8005d66 <xQueueGenericSendFromISR+0x44>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005d50:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005d52:	b15b      	cbz	r3, 8005d6c <xQueueGenericSendFromISR+0x4a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005d54:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005d58:	f7ff fd96 	bl	8005888 <xTaskRemoveFromEventList>
 8005d5c:	b130      	cbz	r0, 8005d6c <xQueueGenericSendFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8005d5e:	b12d      	cbz	r5, 8005d6c <xQueueGenericSendFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8005d60:	2401      	movs	r4, #1
 8005d62:	602c      	str	r4, [r5, #0]
 8005d64:	e005      	b.n	8005d72 <xQueueGenericSendFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8005d66:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8005d68:	1c4a      	adds	r2, r1, #1
 8005d6a:	64a2      	str	r2, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 8005d6c:	2401      	movs	r4, #1
 8005d6e:	e000      	b.n	8005d72 <xQueueGenericSendFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8005d70:	2400      	movs	r4, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8005d72:	4638      	mov	r0, r7
 8005d74:	f000 fa94 	bl	80062a0 <vPortClearInterruptMask>

	return xReturn;
}
 8005d78:	4620      	mov	r0, r4
 8005d7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005d7e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 8005d7e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8005d82:	4604      	mov	r4, r0
 8005d84:	460f      	mov	r7, r1
 8005d86:	9201      	str	r2, [sp, #4]
 8005d88:	4698      	mov	r8, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8005d8a:	2500      	movs	r5, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8005d8c:	f000 fa76 	bl	800627c <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8005d90:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005d92:	b33b      	cbz	r3, 8005de4 <xQueueGenericReceive+0x66>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8005d94:	4620      	mov	r0, r4
 8005d96:	4639      	mov	r1, r7
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8005d98:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8005d9a:	f7ff fec5 	bl	8005b28 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8005d9e:	f1b8 0f00 	cmp.w	r8, #0
 8005da2:	d112      	bne.n	8005dca <xQueueGenericReceive+0x4c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 8005da4:	6ba2      	ldr	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005da6:	6820      	ldr	r0, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 8005da8:	1e53      	subs	r3, r2, #1
 8005daa:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005dac:	b910      	cbnz	r0, 8005db4 <xQueueGenericReceive+0x36>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
 8005dae:	f7ff fdd9 	bl	8005964 <xTaskGetCurrentTaskHandle>
 8005db2:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005db4:	6921      	ldr	r1, [r4, #16]
 8005db6:	b189      	cbz	r1, 8005ddc <xQueueGenericReceive+0x5e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8005db8:	f104 0010 	add.w	r0, r4, #16
 8005dbc:	f7ff fd64 	bl	8005888 <xTaskRemoveFromEventList>
 8005dc0:	2801      	cmp	r0, #1
 8005dc2:	d10b      	bne.n	8005ddc <xQueueGenericReceive+0x5e>
						{
							queueYIELD_IF_USING_PREEMPTION();
 8005dc4:	f000 fa46 	bl	8006254 <vPortYield>
 8005dc8:	e008      	b.n	8005ddc <xQueueGenericReceive+0x5e>
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005dca:	6a61      	ldr	r1, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8005dcc:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005dce:	b129      	cbz	r1, 8005ddc <xQueueGenericReceive+0x5e>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005dd0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005dd4:	f7ff fd58 	bl	8005888 <xTaskRemoveFromEventList>
 8005dd8:	2800      	cmp	r0, #0
 8005dda:	d1f3      	bne.n	8005dc4 <xQueueGenericReceive+0x46>
							queueYIELD_IF_USING_PREEMPTION();
						}
					}
				}

				taskEXIT_CRITICAL();
 8005ddc:	f000 fa64 	bl	80062a8 <vPortExitCritical>
				return pdPASS;
 8005de0:	2001      	movs	r0, #1
 8005de2:	e04a      	b.n	8005e7a <xQueueGenericReceive+0xfc>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8005de4:	9e01      	ldr	r6, [sp, #4]
 8005de6:	b916      	cbnz	r6, 8005dee <xQueueGenericReceive+0x70>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8005de8:	f000 fa5e 	bl	80062a8 <vPortExitCritical>
 8005dec:	e044      	b.n	8005e78 <xQueueGenericReceive+0xfa>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 8005dee:	b915      	cbnz	r5, 8005df6 <xQueueGenericReceive+0x78>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8005df0:	a802      	add	r0, sp, #8
 8005df2:	f7ff fd7f 	bl	80058f4 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
 8005df6:	f000 fa57 	bl	80062a8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8005dfa:	f7ff fb97 	bl	800552c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8005dfe:	f000 fa3d 	bl	800627c <vPortEnterCritical>
 8005e02:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8005e04:	1c43      	adds	r3, r0, #1
 8005e06:	d101      	bne.n	8005e0c <xQueueGenericReceive+0x8e>
 8005e08:	2100      	movs	r1, #0
 8005e0a:	6461      	str	r1, [r4, #68]	; 0x44
 8005e0c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8005e0e:	1c53      	adds	r3, r2, #1
 8005e10:	d101      	bne.n	8005e16 <xQueueGenericReceive+0x98>
 8005e12:	2300      	movs	r3, #0
 8005e14:	64a3      	str	r3, [r4, #72]	; 0x48
 8005e16:	f000 fa47 	bl	80062a8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8005e1a:	a802      	add	r0, sp, #8
 8005e1c:	a901      	add	r1, sp, #4
 8005e1e:	f7ff fd75 	bl	800590c <xTaskCheckForTimeOut>
 8005e22:	bb20      	cbnz	r0, 8005e6e <xQueueGenericReceive+0xf0>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8005e24:	f000 fa2a 	bl	800627c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
 8005e28:	6ba5      	ldr	r5, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8005e2a:	f000 fa3d 	bl	80062a8 <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8005e2e:	b9c5      	cbnz	r5, 8005e62 <xQueueGenericReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005e30:	6820      	ldr	r0, [r4, #0]
 8005e32:	b930      	cbnz	r0, 8005e42 <xQueueGenericReceive+0xc4>
					{
						portENTER_CRITICAL();
 8005e34:	f000 fa22 	bl	800627c <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8005e38:	6860      	ldr	r0, [r4, #4]
 8005e3a:	f7ff fda7 	bl	800598c <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 8005e3e:	f000 fa33 	bl	80062a8 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8005e42:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005e46:	9901      	ldr	r1, [sp, #4]
 8005e48:	f7ff fce6 	bl	8005818 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8005e4c:	4620      	mov	r0, r4
 8005e4e:	f7ff fe39 	bl	8005ac4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8005e52:	f7ff fc03 	bl	800565c <xTaskResumeAll>
 8005e56:	b108      	cbz	r0, 8005e5c <xQueueGenericReceive+0xde>
 8005e58:	2501      	movs	r5, #1
 8005e5a:	e797      	b.n	8005d8c <xQueueGenericReceive+0xe>
				{
					portYIELD_WITHIN_API();
 8005e5c:	f000 f9fa 	bl	8006254 <vPortYield>
 8005e60:	e7fa      	b.n	8005e58 <xQueueGenericReceive+0xda>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8005e62:	4620      	mov	r0, r4
 8005e64:	f7ff fe2e 	bl	8005ac4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8005e68:	f7ff fbf8 	bl	800565c <xTaskResumeAll>
 8005e6c:	e7f4      	b.n	8005e58 <xQueueGenericReceive+0xda>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8005e6e:	4620      	mov	r0, r4
 8005e70:	f7ff fe28 	bl	8005ac4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8005e74:	f7ff fbf2 	bl	800565c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 8005e78:	2000      	movs	r0, #0
		}
	}
}
 8005e7a:	b004      	add	sp, #16
 8005e7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005e80 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
 8005e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005e82:	4604      	mov	r4, r0
 8005e84:	460f      	mov	r7, r1
 8005e86:	4615      	mov	r5, r2
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8005e88:	f000 f9f0 	bl	800626c <ulPortSetInterruptMask>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8005e8c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8005e8e:	4606      	mov	r6, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8005e90:	b1cb      	cbz	r3, 8005ec6 <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8005e92:	4620      	mov	r0, r4
 8005e94:	4639      	mov	r1, r7
 8005e96:	f7ff fe47 	bl	8005b28 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 8005e9a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8005e9c:	1e41      	subs	r1, r0, #1
 8005e9e:	63a1      	str	r1, [r4, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 8005ea0:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8005ea2:	1c53      	adds	r3, r2, #1
 8005ea4:	d10a      	bne.n	8005ebc <xQueueReceiveFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005ea6:	6921      	ldr	r1, [r4, #16]
 8005ea8:	b159      	cbz	r1, 8005ec2 <xQueueReceiveFromISR+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005eaa:	f104 0010 	add.w	r0, r4, #16
 8005eae:	f7ff fceb 	bl	8005888 <xTaskRemoveFromEventList>
 8005eb2:	b130      	cbz	r0, 8005ec2 <xQueueReceiveFromISR+0x42>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 8005eb4:	b12d      	cbz	r5, 8005ec2 <xQueueReceiveFromISR+0x42>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8005eb6:	2401      	movs	r4, #1
 8005eb8:	602c      	str	r4, [r5, #0]
 8005eba:	e005      	b.n	8005ec8 <xQueueReceiveFromISR+0x48>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 8005ebc:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005ebe:	1c58      	adds	r0, r3, #1
 8005ec0:	6460      	str	r0, [r4, #68]	; 0x44
			}

			xReturn = pdPASS;
 8005ec2:	2401      	movs	r4, #1
 8005ec4:	e000      	b.n	8005ec8 <xQueueReceiveFromISR+0x48>
		}
		else
		{
			xReturn = pdFAIL;
 8005ec6:	461c      	mov	r4, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8005ec8:	4630      	mov	r0, r6
 8005eca:	f000 f9e9 	bl	80062a0 <vPortClearInterruptMask>

	return xReturn;
}
 8005ece:	4620      	mov	r0, r4
 8005ed0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005ed2 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
{
 8005ed2:	b510      	push	{r4, lr}
 8005ed4:	4604      	mov	r4, r0
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 8005ed6:	f000 f9d1 	bl	800627c <vPortEnterCritical>
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 8005eda:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 8005edc:	f000 f9e4 	bl	80062a8 <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8005ee0:	4620      	mov	r0, r4
 8005ee2:	bd10      	pop	{r4, pc}

08005ee4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
{
 8005ee4:	b510      	push	{r4, lr}
 8005ee6:	4604      	mov	r4, r0
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 8005ee8:	f000 f9c8 	bl	800627c <vPortEnterCritical>
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 8005eec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005eee:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8005ef0:	1ac4      	subs	r4, r0, r3
	taskEXIT_CRITICAL();
 8005ef2:	f000 f9d9 	bl	80062a8 <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8005ef6:	4620      	mov	r0, r4
 8005ef8:	bd10      	pop	{r4, pc}

08005efa <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
 8005efa:	b538      	push	{r3, r4, r5, lr}
 8005efc:	4604      	mov	r4, r0
 8005efe:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 8005f00:	f000 f9bc 	bl	800627c <vPortEnterCritical>
 8005f04:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005f06:	3301      	adds	r3, #1
 8005f08:	d101      	bne.n	8005f0e <vQueueWaitForMessageRestricted+0x14>
 8005f0a:	2000      	movs	r0, #0
 8005f0c:	6460      	str	r0, [r4, #68]	; 0x44
 8005f0e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8005f10:	1c4b      	adds	r3, r1, #1
 8005f12:	d101      	bne.n	8005f18 <vQueueWaitForMessageRestricted+0x1e>
 8005f14:	2200      	movs	r2, #0
 8005f16:	64a2      	str	r2, [r4, #72]	; 0x48
 8005f18:	f000 f9c6 	bl	80062a8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 8005f1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005f1e:	b923      	cbnz	r3, 8005f2a <vQueueWaitForMessageRestricted+0x30>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8005f20:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005f24:	4629      	mov	r1, r5
 8005f26:	f7ff fc99 	bl	800585c <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
 8005f2a:	4620      	mov	r0, r4
	}
 8005f2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
		}
		prvUnlockQueue( pxQueue );
 8005f30:	f7ff bdc8 	b.w	8005ac4 <prvUnlockQueue>

08005f34 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8005f34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8005f36:	4c0d      	ldr	r4, [pc, #52]	; (8005f6c <prvCheckForValidListAndQueue+0x38>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8005f38:	f000 f9a0 	bl	800627c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8005f3c:	6825      	ldr	r5, [r4, #0]
 8005f3e:	b98d      	cbnz	r5, 8005f64 <prvCheckForValidListAndQueue+0x30>
		{
			vListInitialise( &xActiveTimerList1 );
 8005f40:	4f0b      	ldr	r7, [pc, #44]	; (8005f70 <prvCheckForValidListAndQueue+0x3c>)
			vListInitialise( &xActiveTimerList2 );
 8005f42:	4e0c      	ldr	r6, [pc, #48]	; (8005f74 <prvCheckForValidListAndQueue+0x40>)
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8005f44:	4638      	mov	r0, r7
 8005f46:	f7ff fd7b 	bl	8005a40 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8005f4a:	4630      	mov	r0, r6
 8005f4c:	f7ff fd78 	bl	8005a40 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
 8005f50:	4809      	ldr	r0, [pc, #36]	; (8005f78 <prvCheckForValidListAndQueue+0x44>)
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8005f52:	4b0a      	ldr	r3, [pc, #40]	; (8005f7c <prvCheckForValidListAndQueue+0x48>)
			pxOverflowTimerList = &xActiveTimerList2;
 8005f54:	6006      	str	r6, [r0, #0]
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8005f56:	210c      	movs	r1, #12
 8005f58:	200a      	movs	r0, #10
 8005f5a:	462a      	mov	r2, r5
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8005f5c:	601f      	str	r7, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8005f5e:	f7ff fe57 	bl	8005c10 <xQueueGenericCreate>
 8005f62:	6020      	str	r0, [r4, #0]
		}
	}
	taskEXIT_CRITICAL();
}
 8005f64:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
 8005f68:	f000 b99e 	b.w	80062a8 <vPortExitCritical>
 8005f6c:	2000124c 	.word	0x2000124c
 8005f70:	20001224 	.word	0x20001224
 8005f74:	20001238 	.word	0x20001238
 8005f78:	20001250 	.word	0x20001250
 8005f7c:	20001220 	.word	0x20001220

08005f80 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 8005f80:	b510      	push	{r4, lr}
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 8005f82:	4291      	cmp	r1, r2
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 8005f84:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8005f86:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8005f88:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
 8005f8a:	d805      	bhi.n	8005f98 <prvInsertTimerInActiveList+0x18>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8005f8c:	6981      	ldr	r1, [r0, #24]
 8005f8e:	1ad2      	subs	r2, r2, r3
 8005f90:	428a      	cmp	r2, r1
 8005f92:	d20c      	bcs.n	8005fae <prvInsertTimerInActiveList+0x2e>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8005f94:	4b07      	ldr	r3, [pc, #28]	; (8005fb4 <prvInsertTimerInActiveList+0x34>)
 8005f96:	e004      	b.n	8005fa2 <prvInsertTimerInActiveList+0x22>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8005f98:	429a      	cmp	r2, r3
 8005f9a:	d201      	bcs.n	8005fa0 <prvInsertTimerInActiveList+0x20>
 8005f9c:	4299      	cmp	r1, r3
 8005f9e:	d206      	bcs.n	8005fae <prvInsertTimerInActiveList+0x2e>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8005fa0:	4b05      	ldr	r3, [pc, #20]	; (8005fb8 <prvInsertTimerInActiveList+0x38>)
 8005fa2:	6818      	ldr	r0, [r3, #0]
 8005fa4:	1d21      	adds	r1, r4, #4
 8005fa6:	f7ff fd65 	bl	8005a74 <vListInsert>
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
 8005faa:	2000      	movs	r0, #0
 8005fac:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8005fae:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 8005fb0:	bd10      	pop	{r4, pc}
 8005fb2:	bf00      	nop
 8005fb4:	20001250 	.word	0x20001250
 8005fb8:	20001220 	.word	0x20001220

08005fbc <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
 8005fbc:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 8005fbe:	f7ff ffb9 	bl	8005f34 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 8005fc2:	4b08      	ldr	r3, [pc, #32]	; (8005fe4 <xTimerCreateTimerTask+0x28>)
 8005fc4:	6818      	ldr	r0, [r3, #0]
 8005fc6:	2300      	movs	r3, #0
 8005fc8:	b148      	cbz	r0, 8005fde <xTimerCreateTimerTask+0x22>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 8005fca:	2201      	movs	r2, #1
 8005fcc:	e88d 000c 	stmia.w	sp, {r2, r3}
 8005fd0:	9302      	str	r3, [sp, #8]
 8005fd2:	9303      	str	r3, [sp, #12]
 8005fd4:	4804      	ldr	r0, [pc, #16]	; (8005fe8 <xTimerCreateTimerTask+0x2c>)
 8005fd6:	4905      	ldr	r1, [pc, #20]	; (8005fec <xTimerCreateTimerTask+0x30>)
 8005fd8:	2280      	movs	r2, #128	; 0x80
 8005fda:	f7ff f981 	bl	80052e0 <xTaskGenericCreate>
		#endif
	}

	configASSERT( xReturn );
	return xReturn;
}
 8005fde:	b005      	add	sp, #20
 8005fe0:	bd00      	pop	{pc}
 8005fe2:	bf00      	nop
 8005fe4:	2000124c 	.word	0x2000124c
 8005fe8:	080060cd 	.word	0x080060cd
 8005fec:	080075a8 	.word	0x080075a8

08005ff0 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
 8005ff0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005ff4:	4680      	mov	r8, r0
 8005ff6:	4617      	mov	r7, r2
 8005ff8:	461e      	mov	r6, r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 8005ffa:	460d      	mov	r5, r1
 8005ffc:	b909      	cbnz	r1, 8006002 <xTimerCreate+0x12>
	{
		pxNewTimer = NULL;
 8005ffe:	2400      	movs	r4, #0
 8006000:	e011      	b.n	8006026 <xTimerCreate+0x36>
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 8006002:	2028      	movs	r0, #40	; 0x28
 8006004:	f000 f9ae 	bl	8006364 <pvPortMalloc>
		if( pxNewTimer != NULL )
 8006008:	4604      	mov	r4, r0
 800600a:	2800      	cmp	r0, #0
 800600c:	d0f7      	beq.n	8005ffe <xTimerCreate+0xe>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
 800600e:	f7ff ff91 	bl	8005f34 <prvCheckForValidListAndQueue>
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8006012:	9b06      	ldr	r3, [sp, #24]
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8006014:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8006018:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 800601a:	61e7      	str	r7, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 800601c:	6226      	str	r6, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800601e:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8006020:	1d20      	adds	r0, r4, #4
 8006022:	f7ff fd18 	bl	8005a56 <vListInitialiseItem>

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( xTimerHandle ) pxNewTimer;
}
 8006026:	4620      	mov	r0, r4
 8006028:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800602c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 800602c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800602e:	4d0f      	ldr	r5, [pc, #60]	; (800606c <xTimerGenericCommand+0x40>)
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8006030:	4606      	mov	r6, r0
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8006032:	6828      	ldr	r0, [r5, #0]
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8006034:	461c      	mov	r4, r3
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8006036:	b1b0      	cbz	r0, 8006066 <xTimerGenericCommand+0x3a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8006038:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
 800603a:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
 800603c:	9603      	str	r6, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
 800603e:	b96b      	cbnz	r3, 800605c <xTimerGenericCommand+0x30>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8006040:	f7ff fc96 	bl	8005970 <xTaskGetSchedulerState>
 8006044:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8006046:	bf18      	it	ne
 8006048:	4622      	movne	r2, r4

		if( pxHigherPriorityTaskWoken == NULL )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 800604a:	6828      	ldr	r0, [r5, #0]
 800604c:	a901      	add	r1, sp, #4
 800604e:	bf06      	itte	eq
 8006050:	9a08      	ldreq	r2, [sp, #32]
 8006052:	4623      	moveq	r3, r4
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8006054:	4613      	movne	r3, r2
 8006056:	f7ff fdfb 	bl	8005c50 <xQueueGenericSend>
 800605a:	e004      	b.n	8006066 <xTimerGenericCommand+0x3a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800605c:	461a      	mov	r2, r3
 800605e:	a901      	add	r1, sp, #4
 8006060:	2300      	movs	r3, #0
 8006062:	f7ff fe5e 	bl	8005d22 <xQueueGenericSendFromISR>

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
 8006066:	b004      	add	sp, #16
 8006068:	bd70      	pop	{r4, r5, r6, pc}
 800606a:	bf00      	nop
 800606c:	2000124c 	.word	0x2000124c

08006070 <prvSwitchTimerLists.isra.1>:
		}
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
 8006070:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8006072:	4e14      	ldr	r6, [pc, #80]	; (80060c4 <prvSwitchTimerLists.isra.1+0x54>)
 8006074:	6833      	ldr	r3, [r6, #0]
 8006076:	681a      	ldr	r2, [r3, #0]
 8006078:	b1fa      	cbz	r2, 80060ba <prvSwitchTimerLists.isra.1+0x4a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800607a:	68dc      	ldr	r4, [r3, #12]
 800607c:	6825      	ldr	r5, [r4, #0]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800607e:	68e4      	ldr	r4, [r4, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8006080:	1d27      	adds	r7, r4, #4
 8006082:	4638      	mov	r0, r7
 8006084:	f7ff fd0e 	bl	8005aa4 <uxListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 8006088:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800608a:	4620      	mov	r0, r4
 800608c:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800608e:	69e2      	ldr	r2, [r4, #28]
 8006090:	2a01      	cmp	r2, #1
 8006092:	d1ee      	bne.n	8006072 <prvSwitchTimerLists.isra.1+0x2>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8006094:	69a0      	ldr	r0, [r4, #24]
 8006096:	1829      	adds	r1, r5, r0
			if( xReloadTime > xNextExpireTime )
 8006098:	42a9      	cmp	r1, r5
 800609a:	d906      	bls.n	80060aa <prvSwitchTimerLists.isra.1+0x3a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800609c:	6061      	str	r1, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800609e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80060a0:	6830      	ldr	r0, [r6, #0]
 80060a2:	4639      	mov	r1, r7
 80060a4:	f7ff fce6 	bl	8005a74 <vListInsert>
 80060a8:	e7e3      	b.n	8006072 <prvSwitchTimerLists.isra.1+0x2>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 80060aa:	2100      	movs	r1, #0
 80060ac:	9100      	str	r1, [sp, #0]
 80060ae:	4620      	mov	r0, r4
 80060b0:	462a      	mov	r2, r5
 80060b2:	460b      	mov	r3, r1
 80060b4:	f7ff ffba 	bl	800602c <xTimerGenericCommand>
 80060b8:	e7db      	b.n	8006072 <prvSwitchTimerLists.isra.1+0x2>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 80060ba:	4803      	ldr	r0, [pc, #12]	; (80060c8 <prvSwitchTimerLists.isra.1+0x58>)
 80060bc:	6801      	ldr	r1, [r0, #0]
	pxOverflowTimerList = pxTemp;
 80060be:	6003      	str	r3, [r0, #0]
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 80060c0:	6031      	str	r1, [r6, #0]
	pxOverflowTimerList = pxTemp;
}
 80060c2:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
 80060c4:	20001220 	.word	0x20001220
 80060c8:	20001250 	.word	0x20001250

080060cc <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 80060cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80060ce:	b087      	sub	sp, #28
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80060d0:	4b49      	ldr	r3, [pc, #292]	; (80061f8 <prvTimerTask+0x12c>)
 80060d2:	6818      	ldr	r0, [r3, #0]
 80060d4:	6807      	ldr	r7, [r0, #0]
 80060d6:	f1d7 0701 	rsbs	r7, r7, #1
 80060da:	bf38      	it	cc
 80060dc:	2700      	movcc	r7, #0
	if( *pxListWasEmpty == pdFALSE )
 80060de:	b917      	cbnz	r7, 80060e6 <prvTimerTask+0x1a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80060e0:	68c1      	ldr	r1, [r0, #12]
 80060e2:	680d      	ldr	r5, [r1, #0]
 80060e4:	e000      	b.n	80060e8 <prvTimerTask+0x1c>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
 80060e6:	2500      	movs	r5, #0
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
 80060e8:	f7ff fa20 	bl	800552c <vTaskSuspendAll>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 80060ec:	f7ff fa26 	bl	800553c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 80060f0:	4c42      	ldr	r4, [pc, #264]	; (80061fc <prvTimerTask+0x130>)
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 80060f2:	4606      	mov	r6, r0

	if( xTimeNow < xLastTime )
 80060f4:	6822      	ldr	r2, [r4, #0]
 80060f6:	4290      	cmp	r0, r2
 80060f8:	d203      	bcs.n	8006102 <prvTimerTask+0x36>
	{
		prvSwitchTimerLists( xLastTime );
 80060fa:	f7ff ffb9 	bl	8006070 <prvSwitchTimerLists.isra.1>
		*pxTimerListsWereSwitched = pdTRUE;
 80060fe:	2301      	movs	r3, #1
 8006100:	e000      	b.n	8006104 <prvTimerTask+0x38>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 8006102:	2300      	movs	r3, #0
	}

	xLastTime = xTimeNow;
 8006104:	6026      	str	r6, [r4, #0]
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
 8006106:	2b00      	cmp	r3, #0
 8006108:	d12d      	bne.n	8006166 <prvTimerTask+0x9a>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800610a:	bb0f      	cbnz	r7, 8006150 <prvTimerTask+0x84>
 800610c:	42b5      	cmp	r5, r6
 800610e:	d81f      	bhi.n	8006150 <prvTimerTask+0x84>
			{
				( void ) xTaskResumeAll();
 8006110:	f7ff faa4 	bl	800565c <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8006114:	4938      	ldr	r1, [pc, #224]	; (80061f8 <prvTimerTask+0x12c>)
 8006116:	680c      	ldr	r4, [r1, #0]
 8006118:	68e2      	ldr	r2, [r4, #12]
 800611a:	68d4      	ldr	r4, [r2, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800611c:	1d20      	adds	r0, r4, #4
 800611e:	f7ff fcc1 	bl	8005aa4 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 8006122:	69e3      	ldr	r3, [r4, #28]
 8006124:	2b01      	cmp	r3, #1
 8006126:	d10f      	bne.n	8006148 <prvTimerTask+0x7c>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8006128:	69a1      	ldr	r1, [r4, #24]
 800612a:	4620      	mov	r0, r4
 800612c:	1869      	adds	r1, r5, r1
 800612e:	4632      	mov	r2, r6
 8006130:	462b      	mov	r3, r5
 8006132:	f7ff ff25 	bl	8005f80 <prvInsertTimerInActiveList>
 8006136:	2801      	cmp	r0, #1
 8006138:	d106      	bne.n	8006148 <prvTimerTask+0x7c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 800613a:	9700      	str	r7, [sp, #0]
 800613c:	4620      	mov	r0, r4
 800613e:	4639      	mov	r1, r7
 8006140:	462a      	mov	r2, r5
 8006142:	463b      	mov	r3, r7
 8006144:	f7ff ff72 	bl	800602c <xTimerGenericCommand>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 8006148:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800614a:	4620      	mov	r0, r4
 800614c:	47b8      	blx	r7
 800614e:	e023      	b.n	8006198 <prvTimerTask+0xcc>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 8006150:	482b      	ldr	r0, [pc, #172]	; (8006200 <prvTimerTask+0x134>)
 8006152:	1ba9      	subs	r1, r5, r6
 8006154:	6800      	ldr	r0, [r0, #0]
 8006156:	f7ff fed0 	bl	8005efa <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 800615a:	f7ff fa7f 	bl	800565c <xTaskResumeAll>
 800615e:	b9d8      	cbnz	r0, 8006198 <prvTimerTask+0xcc>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 8006160:	f000 f878 	bl	8006254 <vPortYield>
 8006164:	e018      	b.n	8006198 <prvTimerTask+0xcc>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 8006166:	f7ff fa79 	bl	800565c <xTaskResumeAll>
 800616a:	e015      	b.n	8006198 <prvTimerTask+0xcc>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
	{
		pxTimer = xMessage.pxTimer;
 800616c:	9c05      	ldr	r4, [sp, #20]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 800616e:	6966      	ldr	r6, [r4, #20]
 8006170:	b116      	cbz	r6, 8006178 <prvTimerTask+0xac>
		{
			/* The timer is in a list, remove it. */
			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8006172:	1d20      	adds	r0, r4, #4
 8006174:	f7ff fc96 	bl	8005aa4 <uxListRemove>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8006178:	f7ff f9e0 	bl	800553c <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 800617c:	4d1f      	ldr	r5, [pc, #124]	; (80061fc <prvTimerTask+0x130>)
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800617e:	4607      	mov	r7, r0

	if( xTimeNow < xLastTime )
 8006180:	6828      	ldr	r0, [r5, #0]
 8006182:	4287      	cmp	r7, r0
 8006184:	d201      	bcs.n	800618a <prvTimerTask+0xbe>
	{
		prvSwitchTimerLists( xLastTime );
 8006186:	f7ff ff73 	bl	8006070 <prvSwitchTimerLists.isra.1>
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 800618a:	9e03      	ldr	r6, [sp, #12]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 800618c:	602f      	str	r7, [r5, #0]
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 800618e:	2e02      	cmp	r6, #2
 8006190:	d025      	beq.n	80061de <prvTimerTask+0x112>
 8006192:	2e03      	cmp	r6, #3
 8006194:	d02c      	beq.n	80061f0 <prvTimerTask+0x124>
 8006196:	b14e      	cbz	r6, 80061ac <prvTimerTask+0xe0>
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8006198:	4d19      	ldr	r5, [pc, #100]	; (8006200 <prvTimerTask+0x134>)
 800619a:	2200      	movs	r2, #0
 800619c:	6828      	ldr	r0, [r5, #0]
 800619e:	a903      	add	r1, sp, #12
 80061a0:	4613      	mov	r3, r2
 80061a2:	f7ff fdec 	bl	8005d7e <xQueueGenericReceive>
 80061a6:	2800      	cmp	r0, #0
 80061a8:	d1e0      	bne.n	800616c <prvTimerTask+0xa0>
 80061aa:	e791      	b.n	80060d0 <prvTimerTask+0x4>

		switch( xMessage.xMessageID )
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
 80061ac:	69a2      	ldr	r2, [r4, #24]
 80061ae:	9b04      	ldr	r3, [sp, #16]
 80061b0:	4620      	mov	r0, r4
 80061b2:	1899      	adds	r1, r3, r2
 80061b4:	463a      	mov	r2, r7
 80061b6:	f7ff fee3 	bl	8005f80 <prvInsertTimerInActiveList>
 80061ba:	2801      	cmp	r0, #1
 80061bc:	d1ec      	bne.n	8006198 <prvTimerTask+0xcc>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80061be:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80061c0:	4620      	mov	r0, r4
 80061c2:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 80061c4:	69e1      	ldr	r1, [r4, #28]
 80061c6:	2901      	cmp	r1, #1
 80061c8:	d1e6      	bne.n	8006198 <prvTimerTask+0xcc>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 80061ca:	69a7      	ldr	r7, [r4, #24]
 80061cc:	4620      	mov	r0, r4
 80061ce:	9c04      	ldr	r4, [sp, #16]
 80061d0:	9600      	str	r6, [sp, #0]
 80061d2:	4631      	mov	r1, r6
 80061d4:	193a      	adds	r2, r7, r4
 80061d6:	4633      	mov	r3, r6
 80061d8:	f7ff ff28 	bl	800602c <xTimerGenericCommand>
 80061dc:	e7dc      	b.n	8006198 <prvTimerTask+0xcc>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 80061de:	9d04      	ldr	r5, [sp, #16]
				longer or shorter than the old one.  The command time is 
				therefore set to the current time, and as the period cannot be
				zero the next expiry time can only be in the future, meaning
				(unlike for the xTimerStart() case above) there is no fail case
				that needs to be handled here. */
				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80061e0:	4620      	mov	r0, r4
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 80061e2:	61a5      	str	r5, [r4, #24]
				longer or shorter than the old one.  The command time is 
				therefore set to the current time, and as the period cannot be
				zero the next expiry time can only be in the future, meaning
				(unlike for the xTimerStart() case above) there is no fail case
				that needs to be handled here. */
				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80061e4:	1979      	adds	r1, r7, r5
 80061e6:	463a      	mov	r2, r7
 80061e8:	463b      	mov	r3, r7
 80061ea:	f7ff fec9 	bl	8005f80 <prvInsertTimerInActiveList>
 80061ee:	e7d3      	b.n	8006198 <prvTimerTask+0xcc>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
 80061f0:	4620      	mov	r0, r4
 80061f2:	f000 f8e1 	bl	80063b8 <vPortFree>
 80061f6:	e7cf      	b.n	8006198 <prvTimerTask+0xcc>
 80061f8:	20001220 	.word	0x20001220
 80061fc:	20001254 	.word	0x20001254
 8006200:	2000124c 	.word	0x2000124c

08006204 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8006204:	4803      	ldr	r0, [pc, #12]	; (8006214 <prvPortStartFirstTask+0x10>)
 8006206:	6800      	ldr	r0, [r0, #0]
 8006208:	6800      	ldr	r0, [r0, #0]
 800620a:	f380 8808 	msr	MSP, r0
 800620e:	b662      	cpsie	i
 8006210:	df00      	svc	0
 8006212:	bf00      	nop
 8006214:	e000ed08 	.word	0xe000ed08

08006218 <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8006218:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 800621c:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
 8006220:	4b03      	ldr	r3, [pc, #12]	; (8006230 <pxPortInitialiseStack+0x18>)
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8006222:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
 8006226:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 800622a:	3840      	subs	r0, #64	; 0x40
 800622c:	4770      	bx	lr
 800622e:	bf00      	nop
 8006230:	08006299 	.word	0x08006299

08006234 <vPortSVCHandler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8006234:	4b06      	ldr	r3, [pc, #24]	; (8006250 <pxCurrentTCBConst2>)
 8006236:	6819      	ldr	r1, [r3, #0]
 8006238:	6808      	ldr	r0, [r1, #0]
 800623a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800623e:	f380 8809 	msr	PSP, r0
 8006242:	f04f 0000 	mov.w	r0, #0
 8006246:	f380 8811 	msr	BASEPRI, r0
 800624a:	f04e 0e0d 	orr.w	lr, lr, #13
 800624e:	4770      	bx	lr

08006250 <pxCurrentTCBConst2>:
 8006250:	200011dc 	.word	0x200011dc

08006254 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8006254:	4b04      	ldr	r3, [pc, #16]	; (8006268 <vPortYield+0x14>)
 8006256:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800625a:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800625c:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8006260:	f3bf 8f6f 	isb	sy
 8006264:	4770      	bx	lr
 8006266:	bf00      	nop
 8006268:	e000ed04 	.word	0xe000ed04

0800626c <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
 800626c:	f3ef 8011 	mrs	r0, BASEPRI
 8006270:	f04f 01bf 	mov.w	r1, #191	; 0xbf
 8006274:	f381 8811 	msr	BASEPRI, r1
 8006278:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 800627a:	2000      	movs	r0, #0

0800627c <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800627c:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 800627e:	f7ff fff5 	bl	800626c <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8006282:	4b04      	ldr	r3, [pc, #16]	; (8006294 <vPortEnterCritical+0x18>)
 8006284:	681a      	ldr	r2, [r3, #0]
 8006286:	1c50      	adds	r0, r2, #1
 8006288:	6018      	str	r0, [r3, #0]
	__asm volatile( "dsb" );
 800628a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800628e:	f3bf 8f6f 	isb	sy
 8006292:	bd08      	pop	{r3, pc}
 8006294:	20000008 	.word	0x20000008

08006298 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8006298:	b508      	push	{r3, lr}
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
 800629a:	f7ff ffe7 	bl	800626c <ulPortSetInterruptMask>
 800629e:	e7fe      	b.n	800629e <prvTaskExitError+0x6>

080062a0 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
 80062a0:	f380 8811 	msr	BASEPRI, r0
 80062a4:	4770      	bx	lr
	...

080062a8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 80062a8:	4b03      	ldr	r3, [pc, #12]	; (80062b8 <vPortExitCritical+0x10>)
 80062aa:	6818      	ldr	r0, [r3, #0]
 80062ac:	3801      	subs	r0, #1
 80062ae:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 80062b0:	b908      	cbnz	r0, 80062b6 <vPortExitCritical+0xe>
	{
		portENABLE_INTERRUPTS();
 80062b2:	f7ff bff5 	b.w	80062a0 <vPortClearInterruptMask>
 80062b6:	4770      	bx	lr
 80062b8:	20000008 	.word	0x20000008

080062bc <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80062bc:	f3ef 8009 	mrs	r0, PSP
 80062c0:	4b0c      	ldr	r3, [pc, #48]	; (80062f4 <pxCurrentTCBConst>)
 80062c2:	681a      	ldr	r2, [r3, #0]
 80062c4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80062c8:	6010      	str	r0, [r2, #0]
 80062ca:	e92d 4008 	stmdb	sp!, {r3, lr}
 80062ce:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80062d2:	f380 8811 	msr	BASEPRI, r0
 80062d6:	f7ff fa71 	bl	80057bc <vTaskSwitchContext>
 80062da:	f04f 0000 	mov.w	r0, #0
 80062de:	f380 8811 	msr	BASEPRI, r0
 80062e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80062e6:	6819      	ldr	r1, [r3, #0]
 80062e8:	6808      	ldr	r0, [r1, #0]
 80062ea:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80062ee:	f380 8809 	msr	PSP, r0
 80062f2:	4770      	bx	lr

080062f4 <pxCurrentTCBConst>:
 80062f4:	200011dc 	.word	0x200011dc

080062f8 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80062f8:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 80062fa:	f7ff ffb7 	bl	800626c <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80062fe:	f7ff f929 	bl	8005554 <xTaskIncrementTick>
 8006302:	b118      	cbz	r0, 800630c <xPortSysTickHandler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8006304:	4b04      	ldr	r3, [pc, #16]	; (8006318 <xPortSysTickHandler+0x20>)
 8006306:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800630a:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 800630c:	2000      	movs	r0, #0
}
 800630e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8006312:	f7ff bfc5 	b.w	80062a0 <vPortClearInterruptMask>
 8006316:	bf00      	nop
 8006318:	e000ed04 	.word	0xe000ed04

0800631c <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 800631c:	4b03      	ldr	r3, [pc, #12]	; (800632c <vPortSetupTimerInterrupt+0x10>)
 800631e:	4a04      	ldr	r2, [pc, #16]	; (8006330 <vPortSetupTimerInterrupt+0x14>)
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8006320:	2007      	movs	r0, #7
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 8006322:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8006324:	f843 0c04 	str.w	r0, [r3, #-4]
 8006328:	4770      	bx	lr
 800632a:	bf00      	nop
 800632c:	e000e014 	.word	0xe000e014
 8006330:	000afc7f 	.word	0x000afc7f

08006334 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 8006334:	b508      	push	{r3, lr}
		*pcFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8006336:	4b09      	ldr	r3, [pc, #36]	; (800635c <xPortStartScheduler+0x28>)
 8006338:	681a      	ldr	r2, [r3, #0]
 800633a:	f442 007e 	orr.w	r0, r2, #16646144	; 0xfe0000
 800633e:	6018      	str	r0, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8006340:	6819      	ldr	r1, [r3, #0]
 8006342:	f041 427e 	orr.w	r2, r1, #4261412864	; 0xfe000000
 8006346:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8006348:	f7ff ffe8 	bl	800631c <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800634c:	4b04      	ldr	r3, [pc, #16]	; (8006360 <xPortStartScheduler+0x2c>)
 800634e:	2000      	movs	r0, #0
 8006350:	6018      	str	r0, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8006352:	f7ff ff57 	bl	8006204 <prvPortStartFirstTask>
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
 8006356:	f7ff ff89 	bl	800626c <ulPortSetInterruptMask>
 800635a:	e7fe      	b.n	800635a <xPortStartScheduler+0x26>
 800635c:	e000ed20 	.word	0xe000ed20
 8006360:	20000008 	.word	0x20000008

08006364 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8006364:	b538      	push	{r3, r4, r5, lr}
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8006366:	0743      	lsls	r3, r0, #29
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8006368:	4604      	mov	r4, r0
	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800636a:	bf1c      	itt	ne
 800636c:	f020 0407 	bicne.w	r4, r0, #7
 8006370:	3408      	addne	r4, #8
		}
	#endif

	vTaskSuspendAll();
 8006372:	f7ff f8db 	bl	800552c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8006376:	4b0d      	ldr	r3, [pc, #52]	; (80063ac <pvPortMalloc+0x48>)
 8006378:	681a      	ldr	r2, [r3, #0]
 800637a:	b91a      	cbnz	r2, 8006384 <pvPortMalloc+0x20>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 800637c:	480c      	ldr	r0, [pc, #48]	; (80063b0 <pvPortMalloc+0x4c>)
 800637e:	f020 0107 	bic.w	r1, r0, #7
 8006382:	6019      	str	r1, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8006384:	4a0b      	ldr	r2, [pc, #44]	; (80063b4 <pvPortMalloc+0x50>)
 8006386:	f244 35f7 	movw	r5, #17399	; 0x43f7
 800638a:	6813      	ldr	r3, [r2, #0]
 800638c:	18e4      	adds	r4, r4, r3
 800638e:	42ac      	cmp	r4, r5
 8006390:	d806      	bhi.n	80063a0 <pvPortMalloc+0x3c>
 8006392:	429c      	cmp	r4, r3
 8006394:	d904      	bls.n	80063a0 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8006396:	4805      	ldr	r0, [pc, #20]	; (80063ac <pvPortMalloc+0x48>)
			xNextFreeByte += xWantedSize;
 8006398:	6014      	str	r4, [r2, #0]
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 800639a:	6801      	ldr	r1, [r0, #0]
 800639c:	18cd      	adds	r5, r1, r3
 800639e:	e000      	b.n	80063a2 <pvPortMalloc+0x3e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 80063a0:	2500      	movs	r5, #0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
 80063a2:	f7ff f95b 	bl	800565c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 80063a6:	4628      	mov	r0, r5
 80063a8:	bd38      	pop	{r3, r4, r5, pc}
 80063aa:	bf00      	nop
 80063ac:	2000125c 	.word	0x2000125c
 80063b0:	20001268 	.word	0x20001268
 80063b4:	20001258 	.word	0x20001258

080063b8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 80063b8:	4770      	bx	lr
	...

080063bc <memcpy>:
 80063bc:	2a0f      	cmp	r2, #15
 80063be:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 80063c2:	f240 80a1 	bls.w	8006508 <memcpy+0x14c>
 80063c6:	ea41 0300 	orr.w	r3, r1, r0
 80063ca:	079b      	lsls	r3, r3, #30
 80063cc:	f040 809e 	bne.w	800650c <memcpy+0x150>
 80063d0:	680c      	ldr	r4, [r1, #0]
 80063d2:	f1a2 0510 	sub.w	r5, r2, #16
 80063d6:	6004      	str	r4, [r0, #0]
 80063d8:	684b      	ldr	r3, [r1, #4]
 80063da:	46ac      	mov	ip, r5
 80063dc:	6043      	str	r3, [r0, #4]
 80063de:	688c      	ldr	r4, [r1, #8]
 80063e0:	f1bc 0f0f 	cmp.w	ip, #15
 80063e4:	6084      	str	r4, [r0, #8]
 80063e6:	68cc      	ldr	r4, [r1, #12]
 80063e8:	f3c5 1500 	ubfx	r5, r5, #4, #1
 80063ec:	60c4      	str	r4, [r0, #12]
 80063ee:	f100 0310 	add.w	r3, r0, #16
 80063f2:	f101 0410 	add.w	r4, r1, #16
 80063f6:	d92b      	bls.n	8006450 <memcpy+0x94>
 80063f8:	b175      	cbz	r5, 8006418 <memcpy+0x5c>
 80063fa:	6825      	ldr	r5, [r4, #0]
 80063fc:	f1ac 0c10 	sub.w	ip, ip, #16
 8006400:	601d      	str	r5, [r3, #0]
 8006402:	6865      	ldr	r5, [r4, #4]
 8006404:	605d      	str	r5, [r3, #4]
 8006406:	68a5      	ldr	r5, [r4, #8]
 8006408:	609d      	str	r5, [r3, #8]
 800640a:	68e5      	ldr	r5, [r4, #12]
 800640c:	3410      	adds	r4, #16
 800640e:	60dd      	str	r5, [r3, #12]
 8006410:	3310      	adds	r3, #16
 8006412:	f1bc 0f0f 	cmp.w	ip, #15
 8006416:	d91b      	bls.n	8006450 <memcpy+0x94>
 8006418:	6827      	ldr	r7, [r4, #0]
 800641a:	f104 0610 	add.w	r6, r4, #16
 800641e:	601f      	str	r7, [r3, #0]
 8006420:	6867      	ldr	r7, [r4, #4]
 8006422:	f103 0510 	add.w	r5, r3, #16
 8006426:	605f      	str	r7, [r3, #4]
 8006428:	68a7      	ldr	r7, [r4, #8]
 800642a:	f1ac 0c20 	sub.w	ip, ip, #32
 800642e:	609f      	str	r7, [r3, #8]
 8006430:	68e7      	ldr	r7, [r4, #12]
 8006432:	60df      	str	r7, [r3, #12]
 8006434:	6924      	ldr	r4, [r4, #16]
 8006436:	611c      	str	r4, [r3, #16]
 8006438:	6877      	ldr	r7, [r6, #4]
 800643a:	f106 0410 	add.w	r4, r6, #16
 800643e:	606f      	str	r7, [r5, #4]
 8006440:	68b7      	ldr	r7, [r6, #8]
 8006442:	3320      	adds	r3, #32
 8006444:	60af      	str	r7, [r5, #8]
 8006446:	68f6      	ldr	r6, [r6, #12]
 8006448:	f1bc 0f0f 	cmp.w	ip, #15
 800644c:	60ee      	str	r6, [r5, #12]
 800644e:	d8e3      	bhi.n	8006418 <memcpy+0x5c>
 8006450:	f1a2 0810 	sub.w	r8, r2, #16
 8006454:	f028 030f 	bic.w	r3, r8, #15
 8006458:	f002 040f 	and.w	r4, r2, #15
 800645c:	f103 0c10 	add.w	ip, r3, #16
 8006460:	2c03      	cmp	r4, #3
 8006462:	eb00 030c 	add.w	r3, r0, ip
 8006466:	eb01 080c 	add.w	r8, r1, ip
 800646a:	d951      	bls.n	8006510 <memcpy+0x154>
 800646c:	1f21      	subs	r1, r4, #4
 800646e:	ea4f 0991 	mov.w	r9, r1, lsr #2
 8006472:	4644      	mov	r4, r8
 8006474:	eb08 0c89 	add.w	ip, r8, r9, lsl #2
 8006478:	f854 6b04 	ldr.w	r6, [r4], #4
 800647c:	ebc8 010c 	rsb	r1, r8, ip
 8006480:	f10c 0c04 	add.w	ip, ip, #4
 8006484:	461d      	mov	r5, r3
 8006486:	4564      	cmp	r4, ip
 8006488:	f845 6b04 	str.w	r6, [r5], #4
 800648c:	f3c1 0180 	ubfx	r1, r1, #2, #1
 8006490:	d012      	beq.n	80064b8 <memcpy+0xfc>
 8006492:	b129      	cbz	r1, 80064a0 <memcpy+0xe4>
 8006494:	f854 1b04 	ldr.w	r1, [r4], #4
 8006498:	4564      	cmp	r4, ip
 800649a:	f845 1b04 	str.w	r1, [r5], #4
 800649e:	d00b      	beq.n	80064b8 <memcpy+0xfc>
 80064a0:	4627      	mov	r7, r4
 80064a2:	f857 1b04 	ldr.w	r1, [r7], #4
 80064a6:	462e      	mov	r6, r5
 80064a8:	f846 1b04 	str.w	r1, [r6], #4
 80064ac:	6864      	ldr	r4, [r4, #4]
 80064ae:	606c      	str	r4, [r5, #4]
 80064b0:	1d3c      	adds	r4, r7, #4
 80064b2:	1d35      	adds	r5, r6, #4
 80064b4:	4564      	cmp	r4, ip
 80064b6:	d1f3      	bne.n	80064a0 <memcpy+0xe4>
 80064b8:	f109 0c01 	add.w	ip, r9, #1
 80064bc:	ea4f 098c 	mov.w	r9, ip, lsl #2
 80064c0:	f002 0203 	and.w	r2, r2, #3
 80064c4:	eb08 0109 	add.w	r1, r8, r9
 80064c8:	444b      	add	r3, r9
 80064ca:	b1d2      	cbz	r2, 8006502 <memcpy+0x146>
 80064cc:	780d      	ldrb	r5, [r1, #0]
 80064ce:	189a      	adds	r2, r3, r2
 80064d0:	43dc      	mvns	r4, r3
 80064d2:	f803 5b01 	strb.w	r5, [r3], #1
 80064d6:	1914      	adds	r4, r2, r4
 80064d8:	4293      	cmp	r3, r2
 80064da:	f004 0401 	and.w	r4, r4, #1
 80064de:	d010      	beq.n	8006502 <memcpy+0x146>
 80064e0:	b12c      	cbz	r4, 80064ee <memcpy+0x132>
 80064e2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80064e6:	f803 4b01 	strb.w	r4, [r3], #1
 80064ea:	4293      	cmp	r3, r2
 80064ec:	d009      	beq.n	8006502 <memcpy+0x146>
 80064ee:	784d      	ldrb	r5, [r1, #1]
 80064f0:	461c      	mov	r4, r3
 80064f2:	f804 5b01 	strb.w	r5, [r4], #1
 80064f6:	788d      	ldrb	r5, [r1, #2]
 80064f8:	3102      	adds	r1, #2
 80064fa:	705d      	strb	r5, [r3, #1]
 80064fc:	1c63      	adds	r3, r4, #1
 80064fe:	4293      	cmp	r3, r2
 8006500:	d1f5      	bne.n	80064ee <memcpy+0x132>
 8006502:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8006506:	4770      	bx	lr
 8006508:	4603      	mov	r3, r0
 800650a:	e7de      	b.n	80064ca <memcpy+0x10e>
 800650c:	4603      	mov	r3, r0
 800650e:	e7dd      	b.n	80064cc <memcpy+0x110>
 8006510:	4641      	mov	r1, r8
 8006512:	4622      	mov	r2, r4
 8006514:	e7d9      	b.n	80064ca <memcpy+0x10e>
 8006516:	bf00      	nop

08006518 <memset>:
 8006518:	b4f0      	push	{r4, r5, r6, r7}
 800651a:	0784      	lsls	r4, r0, #30
 800651c:	4603      	mov	r3, r0
 800651e:	f000 808d 	beq.w	800663c <memset+0x124>
 8006522:	1e54      	subs	r4, r2, #1
 8006524:	2a00      	cmp	r2, #0
 8006526:	f000 8087 	beq.w	8006638 <memset+0x120>
 800652a:	07e5      	lsls	r5, r4, #31
 800652c:	b2ce      	uxtb	r6, r1
 800652e:	d411      	bmi.n	8006554 <memset+0x3c>
 8006530:	461a      	mov	r2, r3
 8006532:	f802 6b01 	strb.w	r6, [r2], #1
 8006536:	4613      	mov	r3, r2
 8006538:	4615      	mov	r5, r2
 800653a:	0792      	lsls	r2, r2, #30
 800653c:	d010      	beq.n	8006560 <memset+0x48>
 800653e:	1e62      	subs	r2, r4, #1
 8006540:	2c00      	cmp	r4, #0
 8006542:	d079      	beq.n	8006638 <memset+0x120>
 8006544:	f803 6b01 	strb.w	r6, [r3], #1
 8006548:	4614      	mov	r4, r2
 800654a:	079a      	lsls	r2, r3, #30
 800654c:	461d      	mov	r5, r3
 800654e:	d007      	beq.n	8006560 <memset+0x48>
 8006550:	3c01      	subs	r4, #1
 8006552:	e7ed      	b.n	8006530 <memset+0x18>
 8006554:	4603      	mov	r3, r0
 8006556:	f803 6b01 	strb.w	r6, [r3], #1
 800655a:	079a      	lsls	r2, r3, #30
 800655c:	461d      	mov	r5, r3
 800655e:	d1f7      	bne.n	8006550 <memset+0x38>
 8006560:	2c03      	cmp	r4, #3
 8006562:	d952      	bls.n	800660a <memset+0xf2>
 8006564:	b2ce      	uxtb	r6, r1
 8006566:	ea46 2706 	orr.w	r7, r6, r6, lsl #8
 800656a:	2c0f      	cmp	r4, #15
 800656c:	ea47 4307 	orr.w	r3, r7, r7, lsl #16
 8006570:	d92d      	bls.n	80065ce <memset+0xb6>
 8006572:	f1a4 0210 	sub.w	r2, r4, #16
 8006576:	4617      	mov	r7, r2
 8006578:	2f0f      	cmp	r7, #15
 800657a:	f3c2 1600 	ubfx	r6, r2, #4, #1
 800657e:	602b      	str	r3, [r5, #0]
 8006580:	606b      	str	r3, [r5, #4]
 8006582:	60ab      	str	r3, [r5, #8]
 8006584:	60eb      	str	r3, [r5, #12]
 8006586:	f105 0210 	add.w	r2, r5, #16
 800658a:	d916      	bls.n	80065ba <memset+0xa2>
 800658c:	b13e      	cbz	r6, 800659e <memset+0x86>
 800658e:	3f10      	subs	r7, #16
 8006590:	6013      	str	r3, [r2, #0]
 8006592:	6053      	str	r3, [r2, #4]
 8006594:	6093      	str	r3, [r2, #8]
 8006596:	60d3      	str	r3, [r2, #12]
 8006598:	3210      	adds	r2, #16
 800659a:	2f0f      	cmp	r7, #15
 800659c:	d90d      	bls.n	80065ba <memset+0xa2>
 800659e:	3f20      	subs	r7, #32
 80065a0:	f102 0610 	add.w	r6, r2, #16
 80065a4:	6013      	str	r3, [r2, #0]
 80065a6:	6053      	str	r3, [r2, #4]
 80065a8:	6093      	str	r3, [r2, #8]
 80065aa:	60d3      	str	r3, [r2, #12]
 80065ac:	6113      	str	r3, [r2, #16]
 80065ae:	6153      	str	r3, [r2, #20]
 80065b0:	6193      	str	r3, [r2, #24]
 80065b2:	61d3      	str	r3, [r2, #28]
 80065b4:	3220      	adds	r2, #32
 80065b6:	2f0f      	cmp	r7, #15
 80065b8:	d8f1      	bhi.n	800659e <memset+0x86>
 80065ba:	f1a4 0210 	sub.w	r2, r4, #16
 80065be:	f022 020f 	bic.w	r2, r2, #15
 80065c2:	f004 040f 	and.w	r4, r4, #15
 80065c6:	3210      	adds	r2, #16
 80065c8:	2c03      	cmp	r4, #3
 80065ca:	4415      	add	r5, r2
 80065cc:	d91d      	bls.n	800660a <memset+0xf2>
 80065ce:	1f27      	subs	r7, r4, #4
 80065d0:	463e      	mov	r6, r7
 80065d2:	462a      	mov	r2, r5
 80065d4:	2e03      	cmp	r6, #3
 80065d6:	f842 3b04 	str.w	r3, [r2], #4
 80065da:	f3c7 0780 	ubfx	r7, r7, #2, #1
 80065de:	d90d      	bls.n	80065fc <memset+0xe4>
 80065e0:	b127      	cbz	r7, 80065ec <memset+0xd4>
 80065e2:	3e04      	subs	r6, #4
 80065e4:	2e03      	cmp	r6, #3
 80065e6:	f842 3b04 	str.w	r3, [r2], #4
 80065ea:	d907      	bls.n	80065fc <memset+0xe4>
 80065ec:	4617      	mov	r7, r2
 80065ee:	f847 3b04 	str.w	r3, [r7], #4
 80065f2:	3e08      	subs	r6, #8
 80065f4:	6053      	str	r3, [r2, #4]
 80065f6:	1d3a      	adds	r2, r7, #4
 80065f8:	2e03      	cmp	r6, #3
 80065fa:	d8f7      	bhi.n	80065ec <memset+0xd4>
 80065fc:	1f23      	subs	r3, r4, #4
 80065fe:	f023 0203 	bic.w	r2, r3, #3
 8006602:	1d13      	adds	r3, r2, #4
 8006604:	f004 0403 	and.w	r4, r4, #3
 8006608:	18ed      	adds	r5, r5, r3
 800660a:	b1ac      	cbz	r4, 8006638 <memset+0x120>
 800660c:	b2c9      	uxtb	r1, r1
 800660e:	43ea      	mvns	r2, r5
 8006610:	192c      	adds	r4, r5, r4
 8006612:	f805 1b01 	strb.w	r1, [r5], #1
 8006616:	18a3      	adds	r3, r4, r2
 8006618:	42a5      	cmp	r5, r4
 800661a:	f003 0201 	and.w	r2, r3, #1
 800661e:	d00b      	beq.n	8006638 <memset+0x120>
 8006620:	b11a      	cbz	r2, 800662a <memset+0x112>
 8006622:	f805 1b01 	strb.w	r1, [r5], #1
 8006626:	42a5      	cmp	r5, r4
 8006628:	d006      	beq.n	8006638 <memset+0x120>
 800662a:	462b      	mov	r3, r5
 800662c:	f803 1b01 	strb.w	r1, [r3], #1
 8006630:	7069      	strb	r1, [r5, #1]
 8006632:	1c5d      	adds	r5, r3, #1
 8006634:	42a5      	cmp	r5, r4
 8006636:	d1f8      	bne.n	800662a <memset+0x112>
 8006638:	bcf0      	pop	{r4, r5, r6, r7}
 800663a:	4770      	bx	lr
 800663c:	4605      	mov	r5, r0
 800663e:	4614      	mov	r4, r2
 8006640:	e78e      	b.n	8006560 <memset+0x48>
 8006642:	bf00      	nop

08006644 <adc_power_on>:
@param[in] adc Unsigned int32. ADC block register address base @ref adc_reg_base
*/

void adc_power_on(uint32_t adc)
{
	if (!(ADC_CR2(adc) & ADC_CR2_ADON)) {
 8006644:	6883      	ldr	r3, [r0, #8]
 8006646:	07db      	lsls	r3, r3, #31
 8006648:	d403      	bmi.n	8006652 <adc_power_on+0xe>
		ADC_CR2(adc) |= ADC_CR2_ADON;
 800664a:	6883      	ldr	r3, [r0, #8]
 800664c:	f043 0301 	orr.w	r3, r3, #1
 8006650:	6083      	str	r3, [r0, #8]
 8006652:	4770      	bx	lr

08006654 <adc_enable_external_trigger_regular>:

void adc_enable_external_trigger_regular(uint32_t adc, uint32_t trigger)
{
	uint32_t reg32;

	reg32 = (ADC_CR2(adc) & ~(ADC_CR2_EXTSEL_MASK));
 8006654:	6883      	ldr	r3, [r0, #8]
 8006656:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
	reg32 |= (trigger);
 800665a:	4319      	orrs	r1, r3
	ADC_CR2(adc) = reg32;
 800665c:	6081      	str	r1, [r0, #8]
	ADC_CR2(adc) |= ADC_CR2_EXTTRIG;
 800665e:	6883      	ldr	r3, [r0, #8]
 8006660:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8006664:	6083      	str	r3, [r0, #8]
 8006666:	4770      	bx	lr

08006668 <adc_reset_calibration>:
adc_reg_base.
*/

void adc_reset_calibration(uint32_t adc)
{
	ADC_CR2(adc) |= ADC_CR2_RSTCAL;
 8006668:	6883      	ldr	r3, [r0, #8]
 800666a:	f100 0208 	add.w	r2, r0, #8
 800666e:	f043 0308 	orr.w	r3, r3, #8
 8006672:	6083      	str	r3, [r0, #8]
	while (ADC_CR2(adc) & ADC_CR2_RSTCAL);
 8006674:	6813      	ldr	r3, [r2, #0]
 8006676:	071b      	lsls	r3, r3, #28
 8006678:	d4fc      	bmi.n	8006674 <adc_reset_calibration+0xc>
}
 800667a:	4770      	bx	lr

0800667c <adc_calibration>:
adc_reg_base.
*/

void adc_calibration(uint32_t adc)
{
	ADC_CR2(adc) |= ADC_CR2_CAL;
 800667c:	6883      	ldr	r3, [r0, #8]
 800667e:	f100 0208 	add.w	r2, r0, #8
 8006682:	f043 0304 	orr.w	r3, r3, #4
 8006686:	6083      	str	r3, [r0, #8]
	while (ADC_CR2(adc) & ADC_CR2_CAL);
 8006688:	6813      	ldr	r3, [r2, #0]
 800668a:	075b      	lsls	r3, r3, #29
 800668c:	d4fc      	bmi.n	8006688 <adc_calibration+0xc>
}
 800668e:	4770      	bx	lr

08006690 <adc_set_sample_time_on_all_channels>:
@param[in] time Unsigned int8. Sampling time selection from @ref adc_sample_rg.
 *  * NOTE Common with f2 and f37x and f4
*/

void adc_set_sample_time_on_all_channels(uint32_t adc, uint8_t time)
{
 8006690:	b510      	push	{r4, lr}
 8006692:	2200      	movs	r2, #0
	uint8_t i;
	uint32_t reg32 = 0;
 8006694:	4613      	mov	r3, r2

	for (i = 0; i <= 9; i++) {
		reg32 |= (time << (i * 3));
 8006696:	fa01 f402 	lsl.w	r4, r1, r2
 800669a:	3203      	adds	r2, #3
void adc_set_sample_time_on_all_channels(uint32_t adc, uint8_t time)
{
	uint8_t i;
	uint32_t reg32 = 0;

	for (i = 0; i <= 9; i++) {
 800669c:	2a1e      	cmp	r2, #30
		reg32 |= (time << (i * 3));
 800669e:	ea43 0304 	orr.w	r3, r3, r4
void adc_set_sample_time_on_all_channels(uint32_t adc, uint8_t time)
{
	uint8_t i;
	uint32_t reg32 = 0;

	for (i = 0; i <= 9; i++) {
 80066a2:	d1f8      	bne.n	8006696 <adc_set_sample_time_on_all_channels+0x6>
		reg32 |= (time << (i * 3));
	}
	ADC_SMPR2(adc) = reg32;
 80066a4:	6103      	str	r3, [r0, #16]
 80066a6:	2200      	movs	r2, #0

	for (i = 10; i <= 17; i++) {
		reg32 |= (time << ((i - 10) * 3));
 80066a8:	fa01 f402 	lsl.w	r4, r1, r2
 80066ac:	3203      	adds	r2, #3
	for (i = 0; i <= 9; i++) {
		reg32 |= (time << (i * 3));
	}
	ADC_SMPR2(adc) = reg32;

	for (i = 10; i <= 17; i++) {
 80066ae:	2a18      	cmp	r2, #24
		reg32 |= (time << ((i - 10) * 3));
 80066b0:	ea43 0304 	orr.w	r3, r3, r4
	for (i = 0; i <= 9; i++) {
		reg32 |= (time << (i * 3));
	}
	ADC_SMPR2(adc) = reg32;

	for (i = 10; i <= 17; i++) {
 80066b4:	d1f8      	bne.n	80066a8 <adc_set_sample_time_on_all_channels+0x18>
		reg32 |= (time << ((i - 10) * 3));
	}
	ADC_SMPR1(adc) = reg32;
 80066b6:	60c3      	str	r3, [r0, #12]
 80066b8:	bd10      	pop	{r4, pc}

080066ba <adc_off>:
adc_reg_base.
*/

void adc_off(uint32_t adc)
{
	ADC_CR2(adc) &= ~ADC_CR2_ADON;
 80066ba:	6883      	ldr	r3, [r0, #8]
 80066bc:	f023 0301 	bic.w	r3, r3, #1
 80066c0:	6083      	str	r3, [r0, #8]
 80066c2:	4770      	bx	lr

080066c4 <adc_enable_scan_mode>:
@param[in] adc Unsigned int32. ADC block register address base @ref adc_reg_base
*/

void adc_enable_scan_mode(uint32_t adc)
{
	ADC_CR1(adc) |= ADC_CR1_SCAN;
 80066c4:	6843      	ldr	r3, [r0, #4]
 80066c6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80066ca:	6043      	str	r3, [r0, #4]
 80066cc:	4770      	bx	lr

080066ce <adc_enable_eoc_interrupt>:
@param[in] adc Unsigned int32. ADC block register address base @ref adc_reg_base
*/

void adc_enable_eoc_interrupt(uint32_t adc)
{
	ADC_CR1(adc) |= ADC_CR1_EOCIE;
 80066ce:	6843      	ldr	r3, [r0, #4]
 80066d0:	f043 0320 	orr.w	r3, r3, #32
 80066d4:	6043      	str	r3, [r0, #4]
 80066d6:	4770      	bx	lr

080066d8 <adc_set_right_aligned>:
adc_reg_base.
*/

void adc_set_right_aligned(uint32_t adc)
{
	ADC_CR2(adc) &= ~ADC_CR2_ALIGN;
 80066d8:	6883      	ldr	r3, [r0, #8]
 80066da:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80066de:	6083      	str	r3, [r0, #8]
 80066e0:	4770      	bx	lr

080066e2 <adc_set_single_conversion_mode>:
adc_reg_base.
*/

void adc_set_single_conversion_mode(uint32_t adc)
{
	ADC_CR2(adc) &= ~ADC_CR2_CONT;
 80066e2:	6883      	ldr	r3, [r0, #8]
 80066e4:	f023 0302 	bic.w	r3, r3, #2
 80066e8:	6083      	str	r3, [r0, #8]
 80066ea:	4770      	bx	lr

080066ec <adc_set_regular_sequence>:
	uint32_t third6 = 0;
	uint32_t second6 = 0;
	uint32_t first6 = 0;
	uint8_t i = 0;

	if (length > ADC_SQR_MAX_CHANNELS_REGULAR) {
 80066ec:	2910      	cmp	r1, #16
@param[in] length Unsigned int8. Number of channels in the group.
@param[in] channel Unsigned int8[]. Set of channels in sequence, integers 0..31.
 */

void adc_set_regular_sequence(uint32_t adc, uint8_t length, uint8_t channel[])
{
 80066ee:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t third6 = 0;
	uint32_t second6 = 0;
	uint32_t first6 = 0;
	uint8_t i = 0;

	if (length > ADC_SQR_MAX_CHANNELS_REGULAR) {
 80066f2:	d83d      	bhi.n	8006770 <adc_set_regular_sequence+0x84>
 80066f4:	2300      	movs	r3, #0
 80066f6:	f06f 043b 	mvn.w	r4, #59	; 0x3b
 80066fa:	461d      	mov	r5, r3
 80066fc:	461e      	mov	r6, r3
 80066fe:	461f      	mov	r7, r3
 8006700:	fa5f fc83 	uxtb.w	ip, r3
 8006704:	f10c 0801 	add.w	r8, ip, #1
 8006708:	fa5f f888 	uxtb.w	r8, r8
		return;
	}

	for (i = 1; i <= length; i++) {
 800670c:	4588      	cmp	r8, r1
 800670e:	d829      	bhi.n	8006764 <adc_set_regular_sequence+0x78>
		if (i <= 6) {
 8006710:	f1b8 0f06 	cmp.w	r8, #6
 8006714:	d807      	bhi.n	8006726 <adc_set_regular_sequence+0x3a>
			first6 |= (channel[i - 1] << ((i - 1) * 5));
 8006716:	f812 9003 	ldrb.w	r9, [r2, r3]
 800671a:	eb03 0883 	add.w	r8, r3, r3, lsl #2
 800671e:	fa09 f808 	lsl.w	r8, r9, r8
 8006722:	ea45 0508 	orr.w	r5, r5, r8
 8006726:	f1ac 0806 	sub.w	r8, ip, #6
		}
		if ((i > 6) & (i <= 12)) {
 800672a:	fa5f f888 	uxtb.w	r8, r8
 800672e:	f1b8 0f05 	cmp.w	r8, #5
 8006732:	d807      	bhi.n	8006744 <adc_set_regular_sequence+0x58>
			second6 |= (channel[i - 1] << ((i - 6 - 1) * 5));
 8006734:	f812 9003 	ldrb.w	r9, [r2, r3]
 8006738:	f104 081e 	add.w	r8, r4, #30
 800673c:	fa09 f808 	lsl.w	r8, r9, r8
 8006740:	ea46 0608 	orr.w	r6, r6, r8
 8006744:	f1ac 0c0c 	sub.w	ip, ip, #12
		}
		if ((i > 12) & (i <= 18)) {
 8006748:	fa5f fc8c 	uxtb.w	ip, ip
 800674c:	f1bc 0f05 	cmp.w	ip, #5
 8006750:	d805      	bhi.n	800675e <adc_set_regular_sequence+0x72>
			third6 |= (channel[i - 1] << ((i - 12 - 1) * 5));
 8006752:	f812 c003 	ldrb.w	ip, [r2, r3]
 8006756:	fa0c fc04 	lsl.w	ip, ip, r4
 800675a:	ea47 070c 	orr.w	r7, r7, ip
 800675e:	3301      	adds	r3, #1
 8006760:	3405      	adds	r4, #5
 8006762:	e7cd      	b.n	8006700 <adc_set_regular_sequence+0x14>
	ADC_SQR2(adc) = fourth6;
	ADC_SQR3(adc) = third6;
	ADC_SQR4(adc) = second6;
	ADC_SQR5(adc) = first6;
#else
	ADC_SQR1(adc) = third6 | ((length - 1) << ADC_SQR1_L_LSB);
 8006764:	3901      	subs	r1, #1
 8006766:	ea47 5701 	orr.w	r7, r7, r1, lsl #20
 800676a:	62c7      	str	r7, [r0, #44]	; 0x2c
	ADC_SQR2(adc) = second6;
 800676c:	6306      	str	r6, [r0, #48]	; 0x30
	ADC_SQR3(adc) = first6;
 800676e:	6345      	str	r5, [r0, #52]	; 0x34
 8006770:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006774 <adc_start_conversion_regular>:
*/

void adc_start_conversion_regular(uint32_t adc)
{
	/* Start conversion on regular channels. */
	ADC_CR2(adc) |= ADC_CR2_SWSTART;
 8006774:	6883      	ldr	r3, [r0, #8]
 8006776:	f100 0208 	add.w	r2, r0, #8
 800677a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800677e:	6083      	str	r3, [r0, #8]

	/* Wait until the ADC starts the conversion. */
	while (ADC_CR2(adc) & ADC_CR2_SWSTART);
 8006780:	6813      	ldr	r3, [r2, #0]
 8006782:	025b      	lsls	r3, r3, #9
 8006784:	d4fc      	bmi.n	8006780 <adc_start_conversion_regular+0xc>
}
 8006786:	4770      	bx	lr

08006788 <adc_enable_dma>:
@param[in] adc Unsigned int32. ADC block register address base @ref adc_reg_base
*/

void adc_enable_dma(uint32_t adc)
{
	ADC_CR2(adc) |= ADC_CR2_DMA;
 8006788:	6883      	ldr	r3, [r0, #8]
 800678a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800678e:	6083      	str	r3, [r0, #8]
 8006790:	4770      	bx	lr
	...

08006794 <flash_get_status_flags>:
error, bit 5: end of operation.
*/

uint32_t flash_get_status_flags(void)
{
	uint32_t flags = (FLASH_SR & (FLASH_SR_PGERR |
 8006794:	4b06      	ldr	r3, [pc, #24]	; (80067b0 <flash_get_status_flags+0x1c>)
 8006796:	6818      	ldr	r0, [r3, #0]
			FLASH_SR_EOP |
			FLASH_SR_WRPRTERR |
			FLASH_SR_BSY));
	if (MEMORY_SIZE_REG > 512)
 8006798:	4b06      	ldr	r3, [pc, #24]	; (80067b4 <flash_get_status_flags+0x20>)
 800679a:	681b      	ldr	r3, [r3, #0]
 800679c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
		flags |= (FLASH_SR2 & (FLASH_SR_PGERR |
 80067a0:	bf82      	ittt	hi
 80067a2:	4b05      	ldrhi	r3, [pc, #20]	; (80067b8 <flash_get_status_flags+0x24>)
 80067a4:	681b      	ldrhi	r3, [r3, #0]
 80067a6:	4318      	orrhi	r0, r3
 80067a8:	f000 0035 	and.w	r0, r0, #53	; 0x35
			FLASH_SR_EOP |
			FLASH_SR_WRPRTERR |
			FLASH_SR_BSY));
    return flags;
}
 80067ac:	4770      	bx	lr
 80067ae:	bf00      	nop
 80067b0:	4002200c 	.word	0x4002200c
 80067b4:	1ffff7e0 	.word	0x1ffff7e0
 80067b8:	4002204c 	.word	0x4002204c

080067bc <flash_program_half_word>:
@param[in] uint32_t address. Full address of flash half word to be programmed.
@param[in] uint16_t data.
*/

void flash_program_half_word(uint32_t address, uint16_t data)
{
 80067bc:	b538      	push	{r3, r4, r5, lr}
 80067be:	4604      	mov	r4, r0
 80067c0:	460d      	mov	r5, r1
	flash_wait_for_last_operation();
 80067c2:	f000 fdd5 	bl	8007370 <flash_wait_for_last_operation>

	if ((MEMORY_SIZE_REG > 512) && (address >= FLASH_BASE+0x00080000))
 80067c6:	4b11      	ldr	r3, [pc, #68]	; (800680c <flash_program_half_word+0x50>)
 80067c8:	681b      	ldr	r3, [r3, #0]
 80067ca:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80067ce:	d904      	bls.n	80067da <flash_program_half_word+0x1e>
 80067d0:	4b0f      	ldr	r3, [pc, #60]	; (8006810 <flash_program_half_word+0x54>)
 80067d2:	429c      	cmp	r4, r3
 80067d4:	d901      	bls.n	80067da <flash_program_half_word+0x1e>
		FLASH_CR2 |= FLASH_CR_PG;
 80067d6:	4b0f      	ldr	r3, [pc, #60]	; (8006814 <flash_program_half_word+0x58>)
 80067d8:	e000      	b.n	80067dc <flash_program_half_word+0x20>
	else FLASH_CR |= FLASH_CR_PG;
 80067da:	4b0f      	ldr	r3, [pc, #60]	; (8006818 <flash_program_half_word+0x5c>)
 80067dc:	681a      	ldr	r2, [r3, #0]
 80067de:	f042 0201 	orr.w	r2, r2, #1
 80067e2:	601a      	str	r2, [r3, #0]

	MMIO16(address) = data;
 80067e4:	8025      	strh	r5, [r4, #0]

	flash_wait_for_last_operation();
 80067e6:	f000 fdc3 	bl	8007370 <flash_wait_for_last_operation>

	if ((MEMORY_SIZE_REG > 512) && (address >= FLASH_BASE+0x00080000))
 80067ea:	4b08      	ldr	r3, [pc, #32]	; (800680c <flash_program_half_word+0x50>)
 80067ec:	681b      	ldr	r3, [r3, #0]
 80067ee:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80067f2:	d904      	bls.n	80067fe <flash_program_half_word+0x42>
 80067f4:	4b06      	ldr	r3, [pc, #24]	; (8006810 <flash_program_half_word+0x54>)
 80067f6:	429c      	cmp	r4, r3
 80067f8:	d901      	bls.n	80067fe <flash_program_half_word+0x42>
		FLASH_CR2 &= ~FLASH_CR_PG;
 80067fa:	4b06      	ldr	r3, [pc, #24]	; (8006814 <flash_program_half_word+0x58>)
 80067fc:	e000      	b.n	8006800 <flash_program_half_word+0x44>
	else FLASH_CR &= ~FLASH_CR_PG;
 80067fe:	4b06      	ldr	r3, [pc, #24]	; (8006818 <flash_program_half_word+0x5c>)
 8006800:	681a      	ldr	r2, [r3, #0]
 8006802:	f022 0201 	bic.w	r2, r2, #1
 8006806:	601a      	str	r2, [r3, #0]
 8006808:	bd38      	pop	{r3, r4, r5, pc}
 800680a:	bf00      	nop
 800680c:	1ffff7e0 	.word	0x1ffff7e0
 8006810:	0807ffff 	.word	0x0807ffff
 8006814:	40022050 	.word	0x40022050
 8006818:	40022010 	.word	0x40022010

0800681c <flash_erase_page>:

@param[in] uint32_t page_address. Full address of flash page to be erased.
*/

void flash_erase_page(uint32_t page_address)
{
 800681c:	b510      	push	{r4, lr}
 800681e:	4604      	mov	r4, r0
	flash_wait_for_last_operation();
 8006820:	f000 fda6 	bl	8007370 <flash_wait_for_last_operation>

	if ((MEMORY_SIZE_REG > 512) && (page_address >= FLASH_BASE+0x00080000)) {
 8006824:	4b15      	ldr	r3, [pc, #84]	; (800687c <flash_erase_page+0x60>)
 8006826:	681b      	ldr	r3, [r3, #0]
 8006828:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800682c:	d909      	bls.n	8006842 <flash_erase_page+0x26>
 800682e:	4b14      	ldr	r3, [pc, #80]	; (8006880 <flash_erase_page+0x64>)
 8006830:	429c      	cmp	r4, r3
 8006832:	d906      	bls.n	8006842 <flash_erase_page+0x26>
		FLASH_CR2 |= FLASH_CR_PER;
 8006834:	4b13      	ldr	r3, [pc, #76]	; (8006884 <flash_erase_page+0x68>)
 8006836:	681a      	ldr	r2, [r3, #0]
 8006838:	f042 0202 	orr.w	r2, r2, #2
 800683c:	601a      	str	r2, [r3, #0]
		FLASH_AR2 = page_address;
 800683e:	4a12      	ldr	r2, [pc, #72]	; (8006888 <flash_erase_page+0x6c>)
 8006840:	e005      	b.n	800684e <flash_erase_page+0x32>
		FLASH_CR2 |= FLASH_CR_STRT;
	} else  {
		FLASH_CR |= FLASH_CR_PER;
 8006842:	4b12      	ldr	r3, [pc, #72]	; (800688c <flash_erase_page+0x70>)
 8006844:	681a      	ldr	r2, [r3, #0]
 8006846:	f042 0202 	orr.w	r2, r2, #2
 800684a:	601a      	str	r2, [r3, #0]
		FLASH_AR = page_address;
 800684c:	4a10      	ldr	r2, [pc, #64]	; (8006890 <flash_erase_page+0x74>)
 800684e:	6014      	str	r4, [r2, #0]
		FLASH_CR |= FLASH_CR_STRT;
 8006850:	681a      	ldr	r2, [r3, #0]
 8006852:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8006856:	601a      	str	r2, [r3, #0]
	}

	flash_wait_for_last_operation();
 8006858:	f000 fd8a 	bl	8007370 <flash_wait_for_last_operation>

	if ((MEMORY_SIZE_REG > 512) && (page_address >= FLASH_BASE+0x00080000))
 800685c:	4b07      	ldr	r3, [pc, #28]	; (800687c <flash_erase_page+0x60>)
 800685e:	681b      	ldr	r3, [r3, #0]
 8006860:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8006864:	d904      	bls.n	8006870 <flash_erase_page+0x54>
 8006866:	4b06      	ldr	r3, [pc, #24]	; (8006880 <flash_erase_page+0x64>)
 8006868:	429c      	cmp	r4, r3
 800686a:	d901      	bls.n	8006870 <flash_erase_page+0x54>
		FLASH_CR2 &= ~FLASH_CR_PER;
 800686c:	4b05      	ldr	r3, [pc, #20]	; (8006884 <flash_erase_page+0x68>)
 800686e:	e000      	b.n	8006872 <flash_erase_page+0x56>
	else
		FLASH_CR &= ~FLASH_CR_PER;
 8006870:	4b06      	ldr	r3, [pc, #24]	; (800688c <flash_erase_page+0x70>)
 8006872:	681a      	ldr	r2, [r3, #0]
 8006874:	f022 0202 	bic.w	r2, r2, #2
 8006878:	601a      	str	r2, [r3, #0]
 800687a:	bd10      	pop	{r4, pc}
 800687c:	1ffff7e0 	.word	0x1ffff7e0
 8006880:	0807ffff 	.word	0x0807ffff
 8006884:	40022050 	.word	0x40022050
 8006888:	40022054 	.word	0x40022054
 800688c:	40022010 	.word	0x40022010
 8006890:	40022014 	.word	0x40022014

08006894 <gpio_set_mode>:
	     If multiple pins are to be set, use logical OR '|' to separate
	     them.
*/

void gpio_set_mode(uint32_t gpioport, uint8_t mode, uint8_t cnf, uint16_t gpios)
{
 8006894:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	/*
	 * We want to set the config only for the pins mentioned in gpios,
	 * but keeping the others, so read out the actual config first.
	 */
	crl = GPIO_CRL(gpioport);
 8006898:	6806      	ldr	r6, [r0, #0]
	crh = GPIO_CRH(gpioport);
 800689a:	6845      	ldr	r5, [r0, #4]
 800689c:	f64f 7ce0 	movw	ip, #65504	; 0xffe0
 80068a0:	2400      	movs	r4, #0

	/* Iterate over all bits, use i as the bitnumber. */
	for (i = 0; i < 16; i++) {
		/* Only set the config if the bit is set in gpios. */
		if (!((1 << i) & gpios)) {
 80068a2:	fa43 f704 	asr.w	r7, r3, r4
 80068a6:	07ff      	lsls	r7, r7, #31
 80068a8:	d521      	bpl.n	80068ee <gpio_set_mode+0x5a>
 80068aa:	fa1f f884 	uxth.w	r8, r4
			continue;
		}

		/* Calculate bit offset. */
		offset = (i < 8) ? (i * 4) : ((i - 8) * 4);
 80068ae:	f1b8 0f07 	cmp.w	r8, #7
 80068b2:	d804      	bhi.n	80068be <gpio_set_mode+0x2a>
 80068b4:	ea4f 0788 	mov.w	r7, r8, lsl #2
 80068b8:	b2bf      	uxth	r7, r7
 80068ba:	46b1      	mov	r9, r6
 80068bc:	e001      	b.n	80068c2 <gpio_set_mode+0x2e>
 80068be:	4667      	mov	r7, ip
 80068c0:	46a9      	mov	r9, r5

		/* Use tmp32 to either modify crl or crh. */
		tmp32 = (i < 8) ? crl : crh;

		/* Modify bits are needed. */
		tmp32 &= ~(0xf << offset);	/* Clear the bits first. */
 80068c2:	f04f 0a0f 	mov.w	sl, #15
 80068c6:	fa0a fa07 	lsl.w	sl, sl, r7
 80068ca:	ea29 090a 	bic.w	r9, r9, sl
		tmp32 |= (mode << offset) | (cnf << (offset + 2));
 80068ce:	f107 0a02 	add.w	sl, r7, #2
 80068d2:	fa02 fa0a 	lsl.w	sl, r2, sl
 80068d6:	fa01 f707 	lsl.w	r7, r1, r7
 80068da:	ea4a 0707 	orr.w	r7, sl, r7
 80068de:	ea47 0709 	orr.w	r7, r7, r9

		/* Write tmp32 into crl or crh, leave the other unchanged. */
		crl = (i < 8) ? tmp32 : crl;
 80068e2:	f1b8 0f07 	cmp.w	r8, #7
 80068e6:	bf98      	it	ls
 80068e8:	463e      	movls	r6, r7
 80068ea:	bf88      	it	hi
 80068ec:	463d      	movhi	r5, r7
 80068ee:	3401      	adds	r4, #1
 80068f0:	f10c 0c04 	add.w	ip, ip, #4
	 */
	crl = GPIO_CRL(gpioport);
	crh = GPIO_CRH(gpioport);

	/* Iterate over all bits, use i as the bitnumber. */
	for (i = 0; i < 16; i++) {
 80068f4:	2c10      	cmp	r4, #16
 80068f6:	fa1f fc8c 	uxth.w	ip, ip
 80068fa:	d1d2      	bne.n	80068a2 <gpio_set_mode+0xe>
		/* Write tmp32 into crl or crh, leave the other unchanged. */
		crl = (i < 8) ? tmp32 : crl;
		crh = (i >= 8) ? tmp32 : crh;
	}

	GPIO_CRL(gpioport) = crl;
 80068fc:	6006      	str	r6, [r0, #0]
	GPIO_CRH(gpioport) = crh;
 80068fe:	6045      	str	r5, [r0, #4]
 8006900:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006904 <gpio_primary_remap>:
@ref afio_remap_tim1, @ref afio_remap_usart3. For connectivity line devices
only @ref afio_remap_cld are also available.
*/
void gpio_primary_remap(uint32_t swjdisable, uint32_t maps)
{
	AFIO_MAPR |= (swjdisable & AFIO_MAPR_SWJ_MASK) | (maps & 0x1FFFFF);
 8006904:	4b04      	ldr	r3, [pc, #16]	; (8006918 <gpio_primary_remap+0x14>)
 8006906:	f3c1 0114 	ubfx	r1, r1, #0, #21
 800690a:	681a      	ldr	r2, [r3, #0]
 800690c:	f000 60e0 	and.w	r0, r0, #117440512	; 0x7000000
 8006910:	430a      	orrs	r2, r1
 8006912:	4302      	orrs	r2, r0
 8006914:	601a      	str	r2, [r3, #0]
 8006916:	4770      	bx	lr
 8006918:	40010004 	.word	0x40010004

0800691c <rcc_osc_on.part.0>:

void rcc_osc_on(enum rcc_osc osc)
{
	switch (osc) {
	case PLL:
		RCC_CR |= RCC_CR_PLLON;
 800691c:	4b02      	ldr	r3, [pc, #8]	; (8006928 <rcc_osc_on.part.0+0xc>)
 800691e:	681a      	ldr	r2, [r3, #0]
 8006920:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8006924:	601a      	str	r2, [r3, #0]
 8006926:	4770      	bx	lr
 8006928:	40021000 	.word	0x40021000

0800692c <rcc_wait_for_osc_ready>:
@param[in] osc enum ::osc_t. Oscillator ID
*/

void rcc_wait_for_osc_ready(enum rcc_osc osc)
{
	switch (osc) {
 800692c:	2806      	cmp	r0, #6
 800692e:	d827      	bhi.n	8006980 <rcc_wait_for_osc_ready+0x54>
 8006930:	e8df f000 	tbb	[pc, r0]
 8006934:	130e0904 	.word	0x130e0904
 8006938:	1d18      	.short	0x1d18
 800693a:	22          	.byte	0x22
 800693b:	00          	.byte	0x00
	case PLL:
		while ((RCC_CR & RCC_CR_PLLRDY) == 0);
 800693c:	4b11      	ldr	r3, [pc, #68]	; (8006984 <rcc_wait_for_osc_ready+0x58>)
 800693e:	681b      	ldr	r3, [r3, #0]
 8006940:	0199      	lsls	r1, r3, #6
 8006942:	d5fb      	bpl.n	800693c <rcc_wait_for_osc_ready+0x10>
 8006944:	4770      	bx	lr
		break;
	case PLL2:
		while ((RCC_CR & RCC_CR_PLL2RDY) == 0);
 8006946:	4b0f      	ldr	r3, [pc, #60]	; (8006984 <rcc_wait_for_osc_ready+0x58>)
 8006948:	681b      	ldr	r3, [r3, #0]
 800694a:	011a      	lsls	r2, r3, #4
 800694c:	d5fb      	bpl.n	8006946 <rcc_wait_for_osc_ready+0x1a>
 800694e:	4770      	bx	lr
		break;
	case PLL3:
		while ((RCC_CR & RCC_CR_PLL3RDY) == 0);
 8006950:	4b0c      	ldr	r3, [pc, #48]	; (8006984 <rcc_wait_for_osc_ready+0x58>)
 8006952:	681b      	ldr	r3, [r3, #0]
 8006954:	009b      	lsls	r3, r3, #2
 8006956:	d5fb      	bpl.n	8006950 <rcc_wait_for_osc_ready+0x24>
 8006958:	4770      	bx	lr
		break;
	case HSE:
		while ((RCC_CR & RCC_CR_HSERDY) == 0);
 800695a:	4b0a      	ldr	r3, [pc, #40]	; (8006984 <rcc_wait_for_osc_ready+0x58>)
 800695c:	681b      	ldr	r3, [r3, #0]
 800695e:	0398      	lsls	r0, r3, #14
 8006960:	d5fb      	bpl.n	800695a <rcc_wait_for_osc_ready+0x2e>
 8006962:	4770      	bx	lr
		break;
	case HSI:
		while ((RCC_CR & RCC_CR_HSIRDY) == 0);
 8006964:	4b07      	ldr	r3, [pc, #28]	; (8006984 <rcc_wait_for_osc_ready+0x58>)
 8006966:	681b      	ldr	r3, [r3, #0]
 8006968:	0799      	lsls	r1, r3, #30
 800696a:	d5fb      	bpl.n	8006964 <rcc_wait_for_osc_ready+0x38>
 800696c:	4770      	bx	lr
		break;
	case LSE:
		while ((RCC_BDCR & RCC_BDCR_LSERDY) == 0);
 800696e:	4b06      	ldr	r3, [pc, #24]	; (8006988 <rcc_wait_for_osc_ready+0x5c>)
 8006970:	681b      	ldr	r3, [r3, #0]
 8006972:	079a      	lsls	r2, r3, #30
 8006974:	d5fb      	bpl.n	800696e <rcc_wait_for_osc_ready+0x42>
 8006976:	4770      	bx	lr
		break;
	case LSI:
		while ((RCC_CSR & RCC_CSR_LSIRDY) == 0);
 8006978:	4b04      	ldr	r3, [pc, #16]	; (800698c <rcc_wait_for_osc_ready+0x60>)
 800697a:	681b      	ldr	r3, [r3, #0]
 800697c:	079b      	lsls	r3, r3, #30
 800697e:	d5fb      	bpl.n	8006978 <rcc_wait_for_osc_ready+0x4c>
 8006980:	4770      	bx	lr
 8006982:	bf00      	nop
 8006984:	40021000 	.word	0x40021000
 8006988:	40021020 	.word	0x40021020
 800698c:	40021024 	.word	0x40021024

08006990 <rcc_osc_on>:
@param[in] osc enum ::osc_t. Oscillator ID
*/

void rcc_osc_on(enum rcc_osc osc)
{
	switch (osc) {
 8006990:	2806      	cmp	r0, #6
 8006992:	d81f      	bhi.n	80069d4 <rcc_osc_on+0x44>
 8006994:	e8df f000 	tbb	[pc, r0]
 8006998:	100b0604 	.word	0x100b0604
 800699c:	1715      	.short	0x1715
 800699e:	19          	.byte	0x19
 800699f:	00          	.byte	0x00
 80069a0:	f7ff bfbc 	b.w	800691c <rcc_osc_on.part.0>
	case PLL:
		RCC_CR |= RCC_CR_PLLON;
		break;
	case PLL2:
		RCC_CR |= RCC_CR_PLL2ON;
 80069a4:	4b0c      	ldr	r3, [pc, #48]	; (80069d8 <rcc_osc_on+0x48>)
 80069a6:	681a      	ldr	r2, [r3, #0]
 80069a8:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80069ac:	e011      	b.n	80069d2 <rcc_osc_on+0x42>
		break;
	case PLL3:
		RCC_CR |= RCC_CR_PLL3ON;
 80069ae:	4b0a      	ldr	r3, [pc, #40]	; (80069d8 <rcc_osc_on+0x48>)
 80069b0:	681a      	ldr	r2, [r3, #0]
 80069b2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80069b6:	e00c      	b.n	80069d2 <rcc_osc_on+0x42>
		break;
	case HSE:
		RCC_CR |= RCC_CR_HSEON;
 80069b8:	4b07      	ldr	r3, [pc, #28]	; (80069d8 <rcc_osc_on+0x48>)
 80069ba:	681a      	ldr	r2, [r3, #0]
 80069bc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80069c0:	e007      	b.n	80069d2 <rcc_osc_on+0x42>
		break;
	case HSI:
		RCC_CR |= RCC_CR_HSION;
 80069c2:	4b05      	ldr	r3, [pc, #20]	; (80069d8 <rcc_osc_on+0x48>)
 80069c4:	e002      	b.n	80069cc <rcc_osc_on+0x3c>
		break;
	case LSE:
		RCC_BDCR |= RCC_BDCR_LSEON;
 80069c6:	4b05      	ldr	r3, [pc, #20]	; (80069dc <rcc_osc_on+0x4c>)
 80069c8:	e000      	b.n	80069cc <rcc_osc_on+0x3c>
		break;
	case LSI:
		RCC_CSR |= RCC_CSR_LSION;
 80069ca:	4b05      	ldr	r3, [pc, #20]	; (80069e0 <rcc_osc_on+0x50>)
 80069cc:	681a      	ldr	r2, [r3, #0]
 80069ce:	f042 0201 	orr.w	r2, r2, #1
 80069d2:	601a      	str	r2, [r3, #0]
 80069d4:	4770      	bx	lr
 80069d6:	bf00      	nop
 80069d8:	40021000 	.word	0x40021000
 80069dc:	40021020 	.word	0x40021020
 80069e0:	40021024 	.word	0x40021024

080069e4 <rcc_set_sysclk_source>:
@param[in] clk Unsigned int32. System Clock Selection @ref rcc_cfgr_scs
*/

void rcc_set_sysclk_source(uint32_t clk)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_SW) |
 80069e4:	4b03      	ldr	r3, [pc, #12]	; (80069f4 <rcc_set_sysclk_source+0x10>)
 80069e6:	681a      	ldr	r2, [r3, #0]
 80069e8:	f022 0203 	bic.w	r2, r2, #3
 80069ec:	4310      	orrs	r0, r2
 80069ee:	6018      	str	r0, [r3, #0]
 80069f0:	4770      	bx	lr
 80069f2:	bf00      	nop
 80069f4:	40021004 	.word	0x40021004

080069f8 <rcc_set_pll_multiplication_factor>:
@param[in] mul Unsigned int32. PLL multiplication factor @ref rcc_cfgr_pmf
*/

void rcc_set_pll_multiplication_factor(uint32_t mul)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PLLMUL) |
 80069f8:	4b03      	ldr	r3, [pc, #12]	; (8006a08 <rcc_set_pll_multiplication_factor+0x10>)
 80069fa:	681a      	ldr	r2, [r3, #0]
 80069fc:	f422 1270 	bic.w	r2, r2, #3932160	; 0x3c0000
 8006a00:	ea42 4080 	orr.w	r0, r2, r0, lsl #18
 8006a04:	6018      	str	r0, [r3, #0]
 8006a06:	4770      	bx	lr
 8006a08:	40021004 	.word	0x40021004

08006a0c <rcc_set_pll_source>:
@param[in] pllsrc Unsigned int32. PLL clock source @ref rcc_cfgr_pcs
*/

void rcc_set_pll_source(uint32_t pllsrc)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PLLSRC) |
 8006a0c:	4b03      	ldr	r3, [pc, #12]	; (8006a1c <rcc_set_pll_source+0x10>)
 8006a0e:	681a      	ldr	r2, [r3, #0]
 8006a10:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006a14:	ea42 4000 	orr.w	r0, r2, r0, lsl #16
 8006a18:	6018      	str	r0, [r3, #0]
 8006a1a:	4770      	bx	lr
 8006a1c:	40021004 	.word	0x40021004

08006a20 <rcc_set_pllxtpre>:
@param[in] pllxtpre Unsigned int32. HSE division factor @ref rcc_cfgr_hsepre
*/

void rcc_set_pllxtpre(uint32_t pllxtpre)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PLLXTPRE) |
 8006a20:	4b03      	ldr	r3, [pc, #12]	; (8006a30 <rcc_set_pllxtpre+0x10>)
 8006a22:	681a      	ldr	r2, [r3, #0]
 8006a24:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 8006a28:	ea42 4040 	orr.w	r0, r2, r0, lsl #17
 8006a2c:	6018      	str	r0, [r3, #0]
 8006a2e:	4770      	bx	lr
 8006a30:	40021004 	.word	0x40021004

08006a34 <rcc_set_adcpre>:
@param[in] adcpre uint32_t. Prescale divider taken from @ref rcc_cfgr_adcpre
*/

void rcc_set_adcpre(uint32_t adcpre)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_ADCPRE) |
 8006a34:	4b03      	ldr	r3, [pc, #12]	; (8006a44 <rcc_set_adcpre+0x10>)
 8006a36:	681a      	ldr	r2, [r3, #0]
 8006a38:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8006a3c:	ea42 3080 	orr.w	r0, r2, r0, lsl #14
 8006a40:	6018      	str	r0, [r3, #0]
 8006a42:	4770      	bx	lr
 8006a44:	40021004 	.word	0x40021004

08006a48 <rcc_set_ppre2>:
@param[in] ppre2 Unsigned int32. APB2 prescale factor @ref rcc_cfgr_apb2pre
*/

void rcc_set_ppre2(uint32_t ppre2)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PPRE2) |
 8006a48:	4b03      	ldr	r3, [pc, #12]	; (8006a58 <rcc_set_ppre2+0x10>)
 8006a4a:	681a      	ldr	r2, [r3, #0]
 8006a4c:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
 8006a50:	ea42 20c0 	orr.w	r0, r2, r0, lsl #11
 8006a54:	6018      	str	r0, [r3, #0]
 8006a56:	4770      	bx	lr
 8006a58:	40021004 	.word	0x40021004

08006a5c <rcc_set_ppre1>:
@param[in] ppre1 Unsigned int32. APB1 prescale factor @ref rcc_cfgr_apb1pre
*/

void rcc_set_ppre1(uint32_t ppre1)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_PPRE1) |
 8006a5c:	4b03      	ldr	r3, [pc, #12]	; (8006a6c <rcc_set_ppre1+0x10>)
 8006a5e:	681a      	ldr	r2, [r3, #0]
 8006a60:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8006a64:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 8006a68:	6018      	str	r0, [r3, #0]
 8006a6a:	4770      	bx	lr
 8006a6c:	40021004 	.word	0x40021004

08006a70 <rcc_set_hpre>:
@param[in] hpre Unsigned int32. AHB prescale factor @ref rcc_cfgr_ahbpre
*/

void rcc_set_hpre(uint32_t hpre)
{
	RCC_CFGR = (RCC_CFGR & ~RCC_CFGR_HPRE) |
 8006a70:	4b03      	ldr	r3, [pc, #12]	; (8006a80 <rcc_set_hpre+0x10>)
 8006a72:	681a      	ldr	r2, [r3, #0]
 8006a74:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8006a78:	ea42 1000 	orr.w	r0, r2, r0, lsl #4
 8006a7c:	6018      	str	r0, [r3, #0]
 8006a7e:	4770      	bx	lr
 8006a80:	40021004 	.word	0x40021004

08006a84 <rcc_clock_setup_in_hse_8mhz_out_72mhz>:
/** @brief RCC Set System Clock PLL at 72MHz from HSE at 8MHz

*/

void rcc_clock_setup_in_hse_8mhz_out_72mhz(void)
{
 8006a84:	b508      	push	{r3, lr}
	/* Enable internal high-speed oscillator. */
	rcc_osc_on(HSI);
 8006a86:	2004      	movs	r0, #4
 8006a88:	f7ff ff82 	bl	8006990 <rcc_osc_on>
	rcc_wait_for_osc_ready(HSI);
 8006a8c:	2004      	movs	r0, #4
 8006a8e:	f7ff ff4d 	bl	800692c <rcc_wait_for_osc_ready>

	/* Select HSI as SYSCLK source. */
	rcc_set_sysclk_source(RCC_CFGR_SW_SYSCLKSEL_HSICLK);
 8006a92:	2000      	movs	r0, #0
 8006a94:	f7ff ffa6 	bl	80069e4 <rcc_set_sysclk_source>

	/* Enable external high-speed oscillator 8MHz. */
	rcc_osc_on(HSE);
 8006a98:	2003      	movs	r0, #3
 8006a9a:	f7ff ff79 	bl	8006990 <rcc_osc_on>
	rcc_wait_for_osc_ready(HSE);
 8006a9e:	2003      	movs	r0, #3
 8006aa0:	f7ff ff44 	bl	800692c <rcc_wait_for_osc_ready>
	rcc_set_sysclk_source(RCC_CFGR_SW_SYSCLKSEL_HSECLK);
 8006aa4:	2001      	movs	r0, #1
 8006aa6:	f7ff ff9d 	bl	80069e4 <rcc_set_sysclk_source>

	/*
	 * Set prescalers for AHB, ADC, ABP1, ABP2.
	 * Do this before touching the PLL (TODO: why?).
	 */
	rcc_set_hpre(RCC_CFGR_HPRE_SYSCLK_NODIV);    /* Set. 72MHz Max. 72MHz */
 8006aaa:	2000      	movs	r0, #0
 8006aac:	f7ff ffe0 	bl	8006a70 <rcc_set_hpre>
	rcc_set_adcpre(RCC_CFGR_ADCPRE_PCLK2_DIV8);  /* Set.  9MHz Max. 14MHz */
 8006ab0:	2003      	movs	r0, #3
 8006ab2:	f7ff ffbf 	bl	8006a34 <rcc_set_adcpre>
	rcc_set_ppre1(RCC_CFGR_PPRE1_HCLK_DIV2);     /* Set. 36MHz Max. 36MHz */
 8006ab6:	2004      	movs	r0, #4
 8006ab8:	f7ff ffd0 	bl	8006a5c <rcc_set_ppre1>
	rcc_set_ppre2(RCC_CFGR_PPRE2_HCLK_NODIV);    /* Set. 72MHz Max. 72MHz */
 8006abc:	2000      	movs	r0, #0
 8006abe:	f7ff ffc3 	bl	8006a48 <rcc_set_ppre2>
	 * Sysclk runs with 72MHz -> 2 waitstates.
	 * 0WS from 0-24MHz
	 * 1WS from 24-48MHz
	 * 2WS from 48-72MHz
	 */
	flash_set_ws(FLASH_ACR_LATENCY_2WS);
 8006ac2:	2002      	movs	r0, #2
 8006ac4:	f000 fc38 	bl	8007338 <flash_set_ws>

	/*
	 * Set the PLL multiplication factor to 9.
	 * 8MHz (external) * 9 (multiplier) = 72MHz
	 */
	rcc_set_pll_multiplication_factor(RCC_CFGR_PLLMUL_PLL_CLK_MUL9);
 8006ac8:	2007      	movs	r0, #7
 8006aca:	f7ff ff95 	bl	80069f8 <rcc_set_pll_multiplication_factor>

	/* Select HSE as PLL source. */
	rcc_set_pll_source(RCC_CFGR_PLLSRC_HSE_CLK);
 8006ace:	2001      	movs	r0, #1
 8006ad0:	f7ff ff9c 	bl	8006a0c <rcc_set_pll_source>

	/*
	 * External frequency undivided before entering PLL
	 * (only valid/needed for HSE).
	 */
	rcc_set_pllxtpre(RCC_CFGR_PLLXTPRE_HSE_CLK);
 8006ad4:	2000      	movs	r0, #0
 8006ad6:	f7ff ffa3 	bl	8006a20 <rcc_set_pllxtpre>
 8006ada:	f7ff ff1f 	bl	800691c <rcc_osc_on.part.0>

	/* Enable PLL oscillator and wait for it to stabilize. */
	rcc_osc_on(PLL);
	rcc_wait_for_osc_ready(PLL);
 8006ade:	2000      	movs	r0, #0
 8006ae0:	f7ff ff24 	bl	800692c <rcc_wait_for_osc_ready>

	/* Select PLL as SYSCLK source. */
	rcc_set_sysclk_source(RCC_CFGR_SW_SYSCLKSEL_PLLCLK);
 8006ae4:	2002      	movs	r0, #2
 8006ae6:	f7ff ff7d 	bl	80069e4 <rcc_set_sysclk_source>

	/* Set the peripheral clock frequencies used */
	rcc_ppre1_frequency = 36000000;
 8006aea:	4a03      	ldr	r2, [pc, #12]	; (8006af8 <rcc_clock_setup_in_hse_8mhz_out_72mhz+0x74>)
 8006aec:	4b03      	ldr	r3, [pc, #12]	; (8006afc <rcc_clock_setup_in_hse_8mhz_out_72mhz+0x78>)
 8006aee:	601a      	str	r2, [r3, #0]
	rcc_ppre2_frequency = 72000000;
 8006af0:	4a03      	ldr	r2, [pc, #12]	; (8006b00 <rcc_clock_setup_in_hse_8mhz_out_72mhz+0x7c>)
 8006af2:	4b04      	ldr	r3, [pc, #16]	; (8006b04 <rcc_clock_setup_in_hse_8mhz_out_72mhz+0x80>)
 8006af4:	601a      	str	r2, [r3, #0]
 8006af6:	bd08      	pop	{r3, pc}
 8006af8:	02255100 	.word	0x02255100
 8006afc:	2000000c 	.word	0x2000000c
 8006b00:	044aa200 	.word	0x044aa200
 8006b04:	20000010 	.word	0x20000010

08006b08 <rcc_backupdomain_reset>:
*/

void rcc_backupdomain_reset(void)
{
	/* Set the backup domain software reset. */
	RCC_BDCR |= RCC_BDCR_BDRST;
 8006b08:	4b04      	ldr	r3, [pc, #16]	; (8006b1c <rcc_backupdomain_reset+0x14>)
 8006b0a:	681a      	ldr	r2, [r3, #0]
 8006b0c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006b10:	601a      	str	r2, [r3, #0]

	/* Clear the backup domain software reset. */
	RCC_BDCR &= ~RCC_BDCR_BDRST;
 8006b12:	681a      	ldr	r2, [r3, #0]
 8006b14:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006b18:	601a      	str	r2, [r3, #0]
 8006b1a:	4770      	bx	lr
 8006b1c:	40021020 	.word	0x40021020

08006b20 <rtc_awake_from_off>:
void rtc_awake_from_off(enum rcc_osc clock_source)
{
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006b20:	4b30      	ldr	r3, [pc, #192]	; (8006be4 <rtc_awake_from_off+0xc4>)
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/rtc.h>
#include <libopencm3/stm32/pwr.h>

void rtc_awake_from_off(enum rcc_osc clock_source)
{
 8006b22:	b510      	push	{r4, lr}
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006b24:	681a      	ldr	r2, [r3, #0]
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/rtc.h>
#include <libopencm3/stm32/pwr.h>

void rtc_awake_from_off(enum rcc_osc clock_source)
{
 8006b26:	4604      	mov	r4, r0
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006b28:	f042 52c0 	orr.w	r2, r2, #402653184	; 0x18000000
 8006b2c:	601a      	str	r2, [r3, #0]

	/* Enable access to the backup registers and the RTC. */
	PWR_CR |= PWR_CR_DBP;
 8006b2e:	4b2e      	ldr	r3, [pc, #184]	; (8006be8 <rtc_awake_from_off+0xc8>)
 8006b30:	681a      	ldr	r2, [r3, #0]
 8006b32:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006b36:	601a      	str	r2, [r3, #0]

	/*
	 * Reset the backup domain, clears everything RTC related.
	 * If not wanted use the rtc_awake_from_standby() function.
	 */
	rcc_backupdomain_reset();
 8006b38:	f7ff ffe6 	bl	8006b08 <rcc_backupdomain_reset>

	switch (clock_source) {
 8006b3c:	2c06      	cmp	r4, #6
 8006b3e:	d83e      	bhi.n	8006bbe <rtc_awake_from_off+0x9e>
 8006b40:	e8df f004 	tbb	[pc, r4]
 8006b44:	27383838 	.word	0x27383838
 8006b48:	0438      	.short	0x0438
 8006b4a:	16          	.byte	0x16
 8006b4b:	00          	.byte	0x00
	case LSE:
		/* Turn the LSE on and wait while it stabilises. */
		RCC_BDCR |= RCC_BDCR_LSEON;
 8006b4c:	4b27      	ldr	r3, [pc, #156]	; (8006bec <rtc_awake_from_off+0xcc>)
 8006b4e:	681a      	ldr	r2, [r3, #0]
 8006b50:	4619      	mov	r1, r3
 8006b52:	f042 0201 	orr.w	r2, r2, #1
 8006b56:	601a      	str	r2, [r3, #0]
		while ((reg32 = (RCC_BDCR & RCC_BDCR_LSERDY)) == 0);
 8006b58:	680a      	ldr	r2, [r1, #0]
 8006b5a:	4b24      	ldr	r3, [pc, #144]	; (8006bec <rtc_awake_from_off+0xcc>)
 8006b5c:	0792      	lsls	r2, r2, #30
 8006b5e:	d5fb      	bpl.n	8006b58 <rtc_awake_from_off+0x38>

		/* Choose LSE as the RTC clock source. */
		RCC_BDCR &= ~((1 << 8) | (1 << 9));
 8006b60:	681a      	ldr	r2, [r3, #0]
 8006b62:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006b66:	601a      	str	r2, [r3, #0]
		RCC_BDCR |= (1 << 8);
 8006b68:	681a      	ldr	r2, [r3, #0]
 8006b6a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006b6e:	e025      	b.n	8006bbc <rtc_awake_from_off+0x9c>
		break;
	case LSI:
		/* Turn the LSI on and wait while it stabilises. */
		RCC_CSR |= RCC_CSR_LSION;
 8006b70:	4b1f      	ldr	r3, [pc, #124]	; (8006bf0 <rtc_awake_from_off+0xd0>)
 8006b72:	681a      	ldr	r2, [r3, #0]
 8006b74:	f042 0201 	orr.w	r2, r2, #1
 8006b78:	601a      	str	r2, [r3, #0]
		while ((reg32 = (RCC_CSR & RCC_CSR_LSIRDY)) == 0);
 8006b7a:	681a      	ldr	r2, [r3, #0]
 8006b7c:	0794      	lsls	r4, r2, #30
 8006b7e:	d5fc      	bpl.n	8006b7a <rtc_awake_from_off+0x5a>

		/* Choose LSI as the RTC clock source. */
		RCC_BDCR &= ~((1 << 8) | (1 << 9));
 8006b80:	4b1a      	ldr	r3, [pc, #104]	; (8006bec <rtc_awake_from_off+0xcc>)
 8006b82:	681a      	ldr	r2, [r3, #0]
 8006b84:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006b88:	601a      	str	r2, [r3, #0]
		RCC_BDCR |= (1 << 9);
 8006b8a:	681a      	ldr	r2, [r3, #0]
 8006b8c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006b90:	e014      	b.n	8006bbc <rtc_awake_from_off+0x9c>
		break;
	case HSE:
		/* Turn the HSE on and wait while it stabilises. */
		RCC_CR |= RCC_CR_HSEON;
 8006b92:	4b18      	ldr	r3, [pc, #96]	; (8006bf4 <rtc_awake_from_off+0xd4>)
 8006b94:	681a      	ldr	r2, [r3, #0]
 8006b96:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8006b9a:	601a      	str	r2, [r3, #0]
		while ((reg32 = (RCC_CR & RCC_CR_HSERDY)) == 0);
 8006b9c:	681a      	ldr	r2, [r3, #0]
 8006b9e:	0390      	lsls	r0, r2, #14
 8006ba0:	d5fc      	bpl.n	8006b9c <rtc_awake_from_off+0x7c>

		/* Choose HSE as the RTC clock source. */
		RCC_BDCR &= ~((1 << 8) | (1 << 9));
 8006ba2:	4b12      	ldr	r3, [pc, #72]	; (8006bec <rtc_awake_from_off+0xcc>)
 8006ba4:	681a      	ldr	r2, [r3, #0]
 8006ba6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006baa:	601a      	str	r2, [r3, #0]
		RCC_BDCR |= (1 << 9) | (1 << 8);
 8006bac:	681a      	ldr	r2, [r3, #0]
 8006bae:	f442 7240 	orr.w	r2, r2, #768	; 0x300
 8006bb2:	e003      	b.n	8006bbc <rtc_awake_from_off+0x9c>
	case PLL2:
	case PLL3:
	case HSI:
		/* Unusable clock source, here to prevent warnings. */
		/* Turn off clock sources to RTC. */
		RCC_BDCR &= ~((1 << 8) | (1 << 9));
 8006bb4:	4b0d      	ldr	r3, [pc, #52]	; (8006bec <rtc_awake_from_off+0xcc>)
 8006bb6:	681a      	ldr	r2, [r3, #0]
 8006bb8:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8006bbc:	601a      	str	r2, [r3, #0]
		break;
	}

	/* Enable the RTC. */
	RCC_BDCR |= RCC_BDCR_RTCEN;
 8006bbe:	4b0b      	ldr	r3, [pc, #44]	; (8006bec <rtc_awake_from_off+0xcc>)
 8006bc0:	681a      	ldr	r2, [r3, #0]
 8006bc2:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006bc6:	601a      	str	r2, [r3, #0]

	/* Wait for the RSF bit in RTC_CRL to be set by hardware. */
	RTC_CRL &= ~RTC_CRL_RSF;
 8006bc8:	f5a3 33f4 	sub.w	r3, r3, #124928	; 0x1e800
 8006bcc:	3b1c      	subs	r3, #28
 8006bce:	681a      	ldr	r2, [r3, #0]
 8006bd0:	f022 0208 	bic.w	r2, r2, #8
 8006bd4:	601a      	str	r2, [r3, #0]
	while ((reg32 = (RTC_CRL & RTC_CRL_RSF)) == 0);
 8006bd6:	681a      	ldr	r2, [r3, #0]
 8006bd8:	0711      	lsls	r1, r2, #28
 8006bda:	d5fc      	bpl.n	8006bd6 <rtc_awake_from_off+0xb6>

	/* Wait for the last write operation to finish. */
	/* TODO: Necessary? */
	while ((reg32 = (RTC_CRL & RTC_CRL_RTOFF)) == 0);
 8006bdc:	681a      	ldr	r2, [r3, #0]
 8006bde:	0692      	lsls	r2, r2, #26
 8006be0:	d5fc      	bpl.n	8006bdc <rtc_awake_from_off+0xbc>
}
 8006be2:	bd10      	pop	{r4, pc}
 8006be4:	4002101c 	.word	0x4002101c
 8006be8:	40007000 	.word	0x40007000
 8006bec:	40021020 	.word	0x40021020
 8006bf0:	40021024 	.word	0x40021024
 8006bf4:	40021000 	.word	0x40021000

08006bf8 <rtc_enter_config_mode>:
void rtc_enter_config_mode(void)
{
	uint32_t reg32;

	/* Wait until the RTOFF bit is 1 (no RTC register writes ongoing). */
	while ((reg32 = (RTC_CRL & RTC_CRL_RTOFF)) == 0);
 8006bf8:	4b04      	ldr	r3, [pc, #16]	; (8006c0c <rtc_enter_config_mode+0x14>)
 8006bfa:	681a      	ldr	r2, [r3, #0]
 8006bfc:	0692      	lsls	r2, r2, #26
 8006bfe:	d5fb      	bpl.n	8006bf8 <rtc_enter_config_mode>

	/* Enter configuration mode. */
	RTC_CRL |= RTC_CRL_CNF;
 8006c00:	681a      	ldr	r2, [r3, #0]
 8006c02:	f042 0210 	orr.w	r2, r2, #16
 8006c06:	601a      	str	r2, [r3, #0]
 8006c08:	4770      	bx	lr
 8006c0a:	bf00      	nop
 8006c0c:	40002804 	.word	0x40002804

08006c10 <rtc_exit_config_mode>:
void rtc_exit_config_mode(void)
{
	uint32_t reg32;

	/* Exit configuration mode. */
	RTC_CRL &= ~RTC_CRL_CNF;
 8006c10:	4b04      	ldr	r3, [pc, #16]	; (8006c24 <rtc_exit_config_mode+0x14>)
 8006c12:	681a      	ldr	r2, [r3, #0]
 8006c14:	f022 0210 	bic.w	r2, r2, #16
 8006c18:	601a      	str	r2, [r3, #0]

	/* Wait until the RTOFF bit is 1 (our RTC register write finished). */
	while ((reg32 = (RTC_CRL & RTC_CRL_RTOFF)) == 0);
 8006c1a:	681a      	ldr	r2, [r3, #0]
 8006c1c:	0692      	lsls	r2, r2, #26
 8006c1e:	d5fc      	bpl.n	8006c1a <rtc_exit_config_mode+0xa>
}
 8006c20:	4770      	bx	lr
 8006c22:	bf00      	nop
 8006c24:	40002804 	.word	0x40002804

08006c28 <rtc_set_prescale_val>:
	RTC_CRH &= ~RTC_CRH_ALRIE;
	rtc_exit_config_mode();
}

void rtc_set_prescale_val(uint32_t prescale_val)
{
 8006c28:	b510      	push	{r4, lr}
 8006c2a:	4604      	mov	r4, r0
	rtc_enter_config_mode();
 8006c2c:	f7ff ffe4 	bl	8006bf8 <rtc_enter_config_mode>
	RTC_PRLL = prescale_val & 0x0000ffff;         /* PRL[15:0] */
 8006c30:	4b05      	ldr	r3, [pc, #20]	; (8006c48 <rtc_set_prescale_val+0x20>)
 8006c32:	b2a2      	uxth	r2, r4
	RTC_PRLH = (prescale_val & 0x000f0000) >> 16; /* PRL[19:16] */
 8006c34:	f3c4 4403 	ubfx	r4, r4, #16, #4
}

void rtc_set_prescale_val(uint32_t prescale_val)
{
	rtc_enter_config_mode();
	RTC_PRLL = prescale_val & 0x0000ffff;         /* PRL[15:0] */
 8006c38:	601a      	str	r2, [r3, #0]
	RTC_PRLH = (prescale_val & 0x000f0000) >> 16; /* PRL[19:16] */
 8006c3a:	f843 4c04 	str.w	r4, [r3, #-4]
	rtc_exit_config_mode();
}
 8006c3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void rtc_set_prescale_val(uint32_t prescale_val)
{
	rtc_enter_config_mode();
	RTC_PRLL = prescale_val & 0x0000ffff;         /* PRL[15:0] */
	RTC_PRLH = (prescale_val & 0x000f0000) >> 16; /* PRL[19:16] */
	rtc_exit_config_mode();
 8006c42:	f7ff bfe5 	b.w	8006c10 <rtc_exit_config_mode>
 8006c46:	bf00      	nop
 8006c48:	4000280c 	.word	0x4000280c

08006c4c <rtc_get_counter_val>:
}

uint32_t rtc_get_counter_val(void)
{
	return (RTC_CNTH << 16) | RTC_CNTL;
 8006c4c:	4b03      	ldr	r3, [pc, #12]	; (8006c5c <rtc_get_counter_val+0x10>)
 8006c4e:	6818      	ldr	r0, [r3, #0]
 8006c50:	3304      	adds	r3, #4
 8006c52:	681b      	ldr	r3, [r3, #0]
}
 8006c54:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8006c58:	4770      	bx	lr
 8006c5a:	bf00      	nop
 8006c5c:	40002818 	.word	0x40002818

08006c60 <rtc_set_counter_val>:
{
	return (RTC_ALRH << 16) | RTC_ALRL;
}

void rtc_set_counter_val(uint32_t counter_val)
{
 8006c60:	b510      	push	{r4, lr}
 8006c62:	4604      	mov	r4, r0
	rtc_enter_config_mode();
 8006c64:	f7ff ffc8 	bl	8006bf8 <rtc_enter_config_mode>
	RTC_CNTH = (counter_val & 0xffff0000) >> 16; /* CNT[31:16] */
 8006c68:	4b04      	ldr	r3, [pc, #16]	; (8006c7c <rtc_set_counter_val+0x1c>)
 8006c6a:	0c22      	lsrs	r2, r4, #16
	RTC_CNTL = counter_val & 0x0000ffff;         /* CNT[15:0] */
 8006c6c:	b2a4      	uxth	r4, r4
}

void rtc_set_counter_val(uint32_t counter_val)
{
	rtc_enter_config_mode();
	RTC_CNTH = (counter_val & 0xffff0000) >> 16; /* CNT[31:16] */
 8006c6e:	601a      	str	r2, [r3, #0]
	RTC_CNTL = counter_val & 0x0000ffff;         /* CNT[15:0] */
 8006c70:	605c      	str	r4, [r3, #4]
	rtc_exit_config_mode();
}
 8006c72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void rtc_set_counter_val(uint32_t counter_val)
{
	rtc_enter_config_mode();
	RTC_CNTH = (counter_val & 0xffff0000) >> 16; /* CNT[31:16] */
	RTC_CNTL = counter_val & 0x0000ffff;         /* CNT[15:0] */
	rtc_exit_config_mode();
 8006c76:	f7ff bfcb 	b.w	8006c10 <rtc_exit_config_mode>
 8006c7a:	bf00      	nop
 8006c7c:	40002818 	.word	0x40002818

08006c80 <rtc_awake_from_standby>:
void rtc_awake_from_standby(void)
{
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006c80:	4b0b      	ldr	r3, [pc, #44]	; (8006cb0 <rtc_awake_from_standby+0x30>)
 8006c82:	681a      	ldr	r2, [r3, #0]
 8006c84:	f042 52c0 	orr.w	r2, r2, #402653184	; 0x18000000
 8006c88:	601a      	str	r2, [r3, #0]

	/* Enable access to the backup registers and the RTC. */
	PWR_CR |= PWR_CR_DBP;
 8006c8a:	4b0a      	ldr	r3, [pc, #40]	; (8006cb4 <rtc_awake_from_standby+0x34>)
 8006c8c:	681a      	ldr	r2, [r3, #0]
 8006c8e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006c92:	601a      	str	r2, [r3, #0]

	/* Wait for the RSF bit in RTC_CRL to be set by hardware. */
	RTC_CRL &= ~RTC_CRL_RSF;
 8006c94:	f5a3 438f 	sub.w	r3, r3, #18304	; 0x4780
 8006c98:	3b7c      	subs	r3, #124	; 0x7c
 8006c9a:	681a      	ldr	r2, [r3, #0]
 8006c9c:	f022 0208 	bic.w	r2, r2, #8
 8006ca0:	601a      	str	r2, [r3, #0]
	while ((reg32 = (RTC_CRL & RTC_CRL_RSF)) == 0);
 8006ca2:	681a      	ldr	r2, [r3, #0]
 8006ca4:	0711      	lsls	r1, r2, #28
 8006ca6:	d5fc      	bpl.n	8006ca2 <rtc_awake_from_standby+0x22>

	/* Wait for the last write operation to finish. */
	/* TODO: Necessary? */
	while ((reg32 = (RTC_CRL & RTC_CRL_RTOFF)) == 0);
 8006ca8:	681a      	ldr	r2, [r3, #0]
 8006caa:	0692      	lsls	r2, r2, #26
 8006cac:	d5fc      	bpl.n	8006ca8 <rtc_awake_from_standby+0x28>
}
 8006cae:	4770      	bx	lr
 8006cb0:	4002101c 	.word	0x4002101c
 8006cb4:	40007000 	.word	0x40007000

08006cb8 <rtc_auto_awake>:
void rtc_auto_awake(enum rcc_osc clock_source, uint32_t prescale_val)
{
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006cb8:	4b0e      	ldr	r3, [pc, #56]	; (8006cf4 <rtc_auto_awake+0x3c>)
	/* TODO: Necessary? */
	while ((reg32 = (RTC_CRL & RTC_CRL_RTOFF)) == 0);
}

void rtc_auto_awake(enum rcc_osc clock_source, uint32_t prescale_val)
{
 8006cba:	b510      	push	{r4, lr}
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006cbc:	681a      	ldr	r2, [r3, #0]
	/* TODO: Necessary? */
	while ((reg32 = (RTC_CRL & RTC_CRL_RTOFF)) == 0);
}

void rtc_auto_awake(enum rcc_osc clock_source, uint32_t prescale_val)
{
 8006cbe:	460c      	mov	r4, r1
	uint32_t reg32;

	/* Enable power and backup interface clocks. */
	RCC_APB1ENR |= (RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN);
 8006cc0:	f042 52c0 	orr.w	r2, r2, #402653184	; 0x18000000
 8006cc4:	601a      	str	r2, [r3, #0]

	/* Enable access to the backup registers and the RTC. */
	/* TODO: Not sure if this is necessary to just read the flag. */
	PWR_CR |= PWR_CR_DBP;
 8006cc6:	4b0c      	ldr	r3, [pc, #48]	; (8006cf8 <rtc_auto_awake+0x40>)
 8006cc8:	681a      	ldr	r2, [r3, #0]
 8006cca:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006cce:	601a      	str	r2, [r3, #0]

	reg32 = RCC_BDCR & RCC_BDCR_RTCEN;
 8006cd0:	f503 33d0 	add.w	r3, r3, #106496	; 0x1a000
 8006cd4:	3320      	adds	r3, #32
 8006cd6:	681b      	ldr	r3, [r3, #0]

	if (reg32 != 0) {
 8006cd8:	041b      	lsls	r3, r3, #16
 8006cda:	d503      	bpl.n	8006ce4 <rtc_auto_awake+0x2c>
		rtc_awake_from_standby();
	} else {
		rtc_awake_from_off(clock_source);
		rtc_set_prescale_val(prescale_val);
	}
}
 8006cdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	PWR_CR |= PWR_CR_DBP;

	reg32 = RCC_BDCR & RCC_BDCR_RTCEN;

	if (reg32 != 0) {
		rtc_awake_from_standby();
 8006ce0:	f7ff bfce 	b.w	8006c80 <rtc_awake_from_standby>
	} else {
		rtc_awake_from_off(clock_source);
 8006ce4:	f7ff ff1c 	bl	8006b20 <rtc_awake_from_off>
		rtc_set_prescale_val(prescale_val);
 8006ce8:	4620      	mov	r0, r4
	}
}
 8006cea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	if (reg32 != 0) {
		rtc_awake_from_standby();
	} else {
		rtc_awake_from_off(clock_source);
		rtc_set_prescale_val(prescale_val);
 8006cee:	f7ff bf9b 	b.w	8006c28 <rtc_set_prescale_val>
 8006cf2:	bf00      	nop
 8006cf4:	4002101c 	.word	0x4002101c
 8006cf8:	40007000 	.word	0x40007000

08006cfc <dma_channel_reset>:
*/

void dma_channel_reset(uint32_t dma, uint8_t channel)
{
	/* Disable channel and reset config bits. */
	DMA_CCR(dma, channel) = 0;
 8006cfc:	3901      	subs	r1, #1
 8006cfe:	2314      	movs	r3, #20
 8006d00:	fb03 0301 	mla	r3, r3, r1, r0
 8006d04:	2200      	movs	r2, #0
 8006d06:	609a      	str	r2, [r3, #8]
	/* Reset peripheral address. */
	DMA_CPAR(dma, channel) = 0;
	/* Reset memory address. */
	DMA_CMAR(dma, channel) = 0;
	/* Reset interrupt flags. */
	DMA_IFCR(dma) |= DMA_IFCR_CIF(channel);
 8006d08:	0089      	lsls	r1, r1, #2
void dma_channel_reset(uint32_t dma, uint8_t channel)
{
	/* Disable channel and reset config bits. */
	DMA_CCR(dma, channel) = 0;
	/* Reset data transfer number. */
	DMA_CNDTR(dma, channel) = 0;
 8006d0a:	60da      	str	r2, [r3, #12]
	/* Reset peripheral address. */
	DMA_CPAR(dma, channel) = 0;
 8006d0c:	611a      	str	r2, [r3, #16]
	/* Reset memory address. */
	DMA_CMAR(dma, channel) = 0;
 8006d0e:	615a      	str	r2, [r3, #20]
	/* Reset interrupt flags. */
	DMA_IFCR(dma) |= DMA_IFCR_CIF(channel);
 8006d10:	220f      	movs	r2, #15
 8006d12:	fa02 f101 	lsl.w	r1, r2, r1
 8006d16:	6843      	ldr	r3, [r0, #4]
 8006d18:	4319      	orrs	r1, r3
 8006d1a:	6041      	str	r1, [r0, #4]
 8006d1c:	4770      	bx	lr

08006d1e <dma_set_priority>:
@param[in] prio unsigned int32. Priority level @ref dma_ch_pri.
*/

void dma_set_priority(uint32_t dma, uint8_t channel, uint32_t prio)
{
	DMA_CCR(dma, channel) &= ~(DMA_CCR_PL_MASK);
 8006d1e:	2314      	movs	r3, #20
 8006d20:	3901      	subs	r1, #1
 8006d22:	4359      	muls	r1, r3
 8006d24:	3008      	adds	r0, #8
 8006d26:	5843      	ldr	r3, [r0, r1]
 8006d28:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8006d2c:	5043      	str	r3, [r0, r1]
	DMA_CCR(dma, channel) |= prio;
 8006d2e:	5843      	ldr	r3, [r0, r1]
 8006d30:	431a      	orrs	r2, r3
 8006d32:	5042      	str	r2, [r0, r1]
 8006d34:	4770      	bx	lr

08006d36 <dma_set_memory_size>:
*/

void dma_set_memory_size(uint32_t dma, uint8_t channel, uint32_t mem_size)
{

	DMA_CCR(dma, channel) &= ~(DMA_CCR_MSIZE_MASK);
 8006d36:	2314      	movs	r3, #20
 8006d38:	3901      	subs	r1, #1
 8006d3a:	4359      	muls	r1, r3
 8006d3c:	3008      	adds	r0, #8
 8006d3e:	5843      	ldr	r3, [r0, r1]
 8006d40:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8006d44:	5043      	str	r3, [r0, r1]
	DMA_CCR(dma, channel) |= mem_size;
 8006d46:	5843      	ldr	r3, [r0, r1]
 8006d48:	431a      	orrs	r2, r3
 8006d4a:	5042      	str	r2, [r0, r1]
 8006d4c:	4770      	bx	lr

08006d4e <dma_set_peripheral_size>:
*/

void dma_set_peripheral_size(uint32_t dma, uint8_t channel,
			     uint32_t peripheral_size)
{
	DMA_CCR(dma, channel) &= ~(DMA_CCR_PSIZE_MASK);
 8006d4e:	2314      	movs	r3, #20
 8006d50:	3901      	subs	r1, #1
 8006d52:	4359      	muls	r1, r3
 8006d54:	3008      	adds	r0, #8
 8006d56:	5843      	ldr	r3, [r0, r1]
 8006d58:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006d5c:	5043      	str	r3, [r0, r1]
	DMA_CCR(dma, channel) |= peripheral_size;
 8006d5e:	5843      	ldr	r3, [r0, r1]
 8006d60:	431a      	orrs	r2, r3
 8006d62:	5042      	str	r2, [r0, r1]
 8006d64:	4770      	bx	lr

08006d66 <dma_enable_memory_increment_mode>:
@param[in] channel unsigned int8. Channel number: 1-7 for DMA1 or 1-5 for DMA2
*/

void dma_enable_memory_increment_mode(uint32_t dma, uint8_t channel)
{
	DMA_CCR(dma, channel) |= DMA_CCR_MINC;
 8006d66:	2314      	movs	r3, #20
 8006d68:	3901      	subs	r1, #1
 8006d6a:	4359      	muls	r1, r3
 8006d6c:	3008      	adds	r0, #8
 8006d6e:	5843      	ldr	r3, [r0, r1]
 8006d70:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006d74:	5043      	str	r3, [r0, r1]
 8006d76:	4770      	bx	lr

08006d78 <dma_set_read_from_peripheral>:
@param[in] channel unsigned int8. Channel number: 1-7 for DMA1 or 1-5 for DMA2
*/

void dma_set_read_from_peripheral(uint32_t dma, uint8_t channel)
{
	DMA_CCR(dma, channel) &= ~DMA_CCR_DIR;
 8006d78:	2314      	movs	r3, #20
 8006d7a:	3901      	subs	r1, #1
 8006d7c:	4359      	muls	r1, r3
 8006d7e:	3008      	adds	r0, #8
 8006d80:	5843      	ldr	r3, [r0, r1]
 8006d82:	f023 0310 	bic.w	r3, r3, #16
 8006d86:	5043      	str	r3, [r0, r1]
 8006d88:	4770      	bx	lr

08006d8a <dma_enable_channel>:
@param[in] channel unsigned int8. Channel number: 1-7 for DMA1 or 1-5 for DMA2
*/

void dma_enable_channel(uint32_t dma, uint8_t channel)
{
	DMA_CCR(dma, channel) |= DMA_CCR_EN;
 8006d8a:	2314      	movs	r3, #20
 8006d8c:	3901      	subs	r1, #1
 8006d8e:	4359      	muls	r1, r3
 8006d90:	3008      	adds	r0, #8
 8006d92:	5843      	ldr	r3, [r0, r1]
 8006d94:	f043 0301 	orr.w	r3, r3, #1
 8006d98:	5043      	str	r3, [r0, r1]
 8006d9a:	4770      	bx	lr

08006d9c <dma_set_peripheral_address>:
@param[in] address unsigned int32. Peripheral Address.
*/

void dma_set_peripheral_address(uint32_t dma, uint8_t channel, uint32_t address)
{
	if (!(DMA_CCR(dma, channel) & DMA_CCR_EN)) {
 8006d9c:	2314      	movs	r3, #20
 8006d9e:	3901      	subs	r1, #1
 8006da0:	fb03 0001 	mla	r0, r3, r1, r0
 8006da4:	6883      	ldr	r3, [r0, #8]
 8006da6:	07db      	lsls	r3, r3, #31
		DMA_CPAR(dma, channel) = (uint32_t) address;
 8006da8:	bf58      	it	pl
 8006daa:	6102      	strpl	r2, [r0, #16]
 8006dac:	4770      	bx	lr

08006dae <dma_set_memory_address>:
@param[in] address unsigned int32. Memory Initial Address.
*/

void dma_set_memory_address(uint32_t dma, uint8_t channel, uint32_t address)
{
	if (!(DMA_CCR(dma, channel) & DMA_CCR_EN)) {
 8006dae:	2314      	movs	r3, #20
 8006db0:	3901      	subs	r1, #1
 8006db2:	fb03 0001 	mla	r0, r3, r1, r0
 8006db6:	6883      	ldr	r3, [r0, #8]
 8006db8:	07db      	lsls	r3, r3, #31
		DMA_CMAR(dma, channel) = (uint32_t) address;
 8006dba:	bf58      	it	pl
 8006dbc:	6142      	strpl	r2, [r0, #20]
 8006dbe:	4770      	bx	lr

08006dc0 <dma_set_number_of_data>:
maximum).
*/

void dma_set_number_of_data(uint32_t dma, uint8_t channel, uint16_t number)
{
	DMA_CNDTR(dma, channel) = number;
 8006dc0:	3901      	subs	r1, #1
 8006dc2:	2314      	movs	r3, #20
 8006dc4:	4359      	muls	r1, r3
 8006dc6:	300c      	adds	r0, #12
 8006dc8:	5042      	str	r2, [r0, r1]
 8006dca:	4770      	bx	lr

08006dcc <gpio_set>:
	     If multiple pins are to be changed, use logical OR '|' to separate
	     them.
*/
void gpio_set(uint32_t gpioport, uint16_t gpios)
{
	GPIO_BSRR(gpioport) = gpios;
 8006dcc:	6101      	str	r1, [r0, #16]
 8006dce:	4770      	bx	lr

08006dd0 <gpio_clear>:
	     If multiple pins are to be changed, use logical OR '|' to separate
	     them.
*/
void  gpio_clear(uint32_t gpioport, uint16_t gpios)
{
	GPIO_BSRR(gpioport) = (gpios << 16);
 8006dd0:	0409      	lsls	r1, r1, #16
 8006dd2:	6101      	str	r1, [r0, #16]
 8006dd4:	4770      	bx	lr

08006dd6 <gpio_port_read>:
@param[in] gpioport Unsigned int32. Port identifier @ref gpio_port_id
@return Unsigned int16. The value held in the specified GPIO port.
*/
uint16_t gpio_port_read(uint32_t gpioport)
{
	return (uint16_t)GPIO_IDR(gpioport);
 8006dd6:	6880      	ldr	r0, [r0, #8]
}
 8006dd8:	b280      	uxth	r0, r0
 8006dda:	4770      	bx	lr

08006ddc <gpio_port_write>:
@param[in] gpioport Unsigned int32. Port identifier @ref gpio_port_id
@param[in] data Unsigned int16. The value to be written to the GPIO port.
*/
void gpio_port_write(uint32_t gpioport, uint16_t data)
{
	GPIO_ODR(gpioport) = data;
 8006ddc:	60c1      	str	r1, [r0, #12]
 8006dde:	4770      	bx	lr

08006de0 <iwdg_start>:

*/

void iwdg_start(void)
{
	IWDG_KR = IWDG_KR_START;
 8006de0:	4b02      	ldr	r3, [pc, #8]	; (8006dec <iwdg_start+0xc>)
 8006de2:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8006de6:	601a      	str	r2, [r3, #0]
 8006de8:	4770      	bx	lr
 8006dea:	bf00      	nop
 8006dec:	40003000 	.word	0x40003000

08006df0 <iwdg_reload_busy>:
loading a new count value.
*/

bool iwdg_reload_busy(void)
{
	return IWDG_SR & IWDG_SR_RVU;
 8006df0:	4b02      	ldr	r3, [pc, #8]	; (8006dfc <iwdg_reload_busy+0xc>)
 8006df2:	6818      	ldr	r0, [r3, #0]
}
 8006df4:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8006df8:	4770      	bx	lr
 8006dfa:	bf00      	nop
 8006dfc:	4000300c 	.word	0x4000300c

08006e00 <iwdg_prescaler_busy>:
loading a new period value.
*/

bool iwdg_prescaler_busy(void)
{
	return IWDG_SR & IWDG_SR_PVU;
 8006e00:	4b02      	ldr	r3, [pc, #8]	; (8006e0c <iwdg_prescaler_busy+0xc>)
 8006e02:	6818      	ldr	r0, [r3, #0]
}
 8006e04:	f000 0001 	and.w	r0, r0, #1
 8006e08:	4770      	bx	lr
 8006e0a:	bf00      	nop
 8006e0c:	4000300c 	.word	0x4000300c

08006e10 <iwdg_set_period_ms>:
void iwdg_set_period_ms(uint32_t period)
{
	uint32_t count, prescale, reload, exponent;

	/* Set the count to represent ticks of the 32kHz LSI clock */
	count = (period << 5);
 8006e10:	0140      	lsls	r0, r0, #5
@param[in] period uint32_t Period in milliseconds (< 32760) from a watchdog
reset until a system reset is issued.
*/

void iwdg_set_period_ms(uint32_t period)
{
 8006e12:	b538      	push	{r3, r4, r5, lr}

	/* Set the count to represent ticks of the 32kHz LSI clock */
	count = (period << 5);

	/* Strip off the first 12 bits to get the prescale value required */
	prescale = (count >> 12);
 8006e14:	0b03      	lsrs	r3, r0, #12
	if (prescale > 256) {
 8006e16:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006e1a:	d81f      	bhi.n	8006e5c <iwdg_set_period_ms+0x4c>
		exponent = IWDG_PR_DIV256; reload = COUNT_MASK;
	} else if (prescale > 128) {
 8006e1c:	2b80      	cmp	r3, #128	; 0x80
 8006e1e:	d902      	bls.n	8006e26 <iwdg_set_period_ms+0x16>
		exponent = IWDG_PR_DIV256; reload = (count >> 8);
 8006e20:	0a04      	lsrs	r4, r0, #8
 8006e22:	2506      	movs	r5, #6
 8006e24:	e01d      	b.n	8006e62 <iwdg_set_period_ms+0x52>
	} else if (prescale > 64) {
 8006e26:	2b40      	cmp	r3, #64	; 0x40
 8006e28:	d902      	bls.n	8006e30 <iwdg_set_period_ms+0x20>
		exponent = IWDG_PR_DIV128; reload = (count >> 7);
 8006e2a:	09c4      	lsrs	r4, r0, #7
 8006e2c:	2505      	movs	r5, #5
 8006e2e:	e018      	b.n	8006e62 <iwdg_set_period_ms+0x52>
	} else if (prescale > 32) {
 8006e30:	2b20      	cmp	r3, #32
 8006e32:	d902      	bls.n	8006e3a <iwdg_set_period_ms+0x2a>
		exponent = IWDG_PR_DIV64;  reload = (count >> 6);
 8006e34:	0984      	lsrs	r4, r0, #6
 8006e36:	2504      	movs	r5, #4
 8006e38:	e013      	b.n	8006e62 <iwdg_set_period_ms+0x52>
	} else if (prescale > 16) {
 8006e3a:	2b10      	cmp	r3, #16
 8006e3c:	d902      	bls.n	8006e44 <iwdg_set_period_ms+0x34>
		exponent = IWDG_PR_DIV32;  reload = (count >> 5);
 8006e3e:	0944      	lsrs	r4, r0, #5
 8006e40:	2503      	movs	r5, #3
 8006e42:	e00e      	b.n	8006e62 <iwdg_set_period_ms+0x52>
	} else if (prescale > 8) {
 8006e44:	2b08      	cmp	r3, #8
 8006e46:	d902      	bls.n	8006e4e <iwdg_set_period_ms+0x3e>
		exponent = IWDG_PR_DIV16;  reload = (count >> 4);
 8006e48:	0904      	lsrs	r4, r0, #4
 8006e4a:	2502      	movs	r5, #2
 8006e4c:	e009      	b.n	8006e62 <iwdg_set_period_ms+0x52>
	} else if (prescale > 4) {
 8006e4e:	2b04      	cmp	r3, #4
		exponent = IWDG_PR_DIV8;   reload = (count >> 3);
 8006e50:	bf87      	ittee	hi
 8006e52:	08c4      	lsrhi	r4, r0, #3
 8006e54:	2501      	movhi	r5, #1
	} else {
		exponent = IWDG_PR_DIV4;   reload = (count >> 2);
 8006e56:	0884      	lsrls	r4, r0, #2
 8006e58:	2500      	movls	r5, #0
 8006e5a:	e002      	b.n	8006e62 <iwdg_set_period_ms+0x52>
	count = (period << 5);

	/* Strip off the first 12 bits to get the prescale value required */
	prescale = (count >> 12);
	if (prescale > 256) {
		exponent = IWDG_PR_DIV256; reload = COUNT_MASK;
 8006e5c:	2506      	movs	r5, #6
 8006e5e:	f640 74ff 	movw	r4, #4095	; 0xfff
	/* Avoid the undefined situation of a zero count */
	if (count == 0) {
		count = 1;
	}

	while (iwdg_prescaler_busy());
 8006e62:	f7ff ffcd 	bl	8006e00 <iwdg_prescaler_busy>
 8006e66:	2800      	cmp	r0, #0
 8006e68:	d1fb      	bne.n	8006e62 <iwdg_set_period_ms+0x52>
	IWDG_KR = IWDG_KR_UNLOCK;
 8006e6a:	4b09      	ldr	r3, [pc, #36]	; (8006e90 <iwdg_set_period_ms+0x80>)
 8006e6c:	f245 5255 	movw	r2, #21845	; 0x5555
 8006e70:	601a      	str	r2, [r3, #0]
	IWDG_PR = exponent;
 8006e72:	4a08      	ldr	r2, [pc, #32]	; (8006e94 <iwdg_set_period_ms+0x84>)
 8006e74:	6015      	str	r5, [r2, #0]
 8006e76:	461d      	mov	r5, r3
	while (iwdg_reload_busy());
 8006e78:	f7ff ffba 	bl	8006df0 <iwdg_reload_busy>
 8006e7c:	2800      	cmp	r0, #0
 8006e7e:	d1fb      	bne.n	8006e78 <iwdg_set_period_ms+0x68>
	IWDG_KR = IWDG_KR_UNLOCK;
 8006e80:	f245 5355 	movw	r3, #21845	; 0x5555
 8006e84:	602b      	str	r3, [r5, #0]
	IWDG_RLR = (reload & COUNT_MASK);
 8006e86:	4b04      	ldr	r3, [pc, #16]	; (8006e98 <iwdg_set_period_ms+0x88>)
 8006e88:	f3c4 040b 	ubfx	r4, r4, #0, #12
 8006e8c:	601c      	str	r4, [r3, #0]
 8006e8e:	bd38      	pop	{r3, r4, r5, pc}
 8006e90:	40003000 	.word	0x40003000
 8006e94:	40003004 	.word	0x40003004
 8006e98:	40003008 	.word	0x40003008

08006e9c <iwdg_reset>:
register.
*/

void iwdg_reset(void)
{
	IWDG_KR = IWDG_KR_RESET;
 8006e9c:	4b02      	ldr	r3, [pc, #8]	; (8006ea8 <iwdg_reset+0xc>)
 8006e9e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8006ea2:	601a      	str	r2, [r3, #0]
 8006ea4:	4770      	bx	lr
 8006ea6:	bf00      	nop
 8006ea8:	40003000 	.word	0x40003000

08006eac <spi_reset>:
@param[in] spi_peripheral Unsigned int32. SPI peripheral identifier @ref
spi_reg_base.
*/

void spi_reset(uint32_t spi_peripheral)
{	switch (spi_peripheral) {
 8006eac:	4b0a      	ldr	r3, [pc, #40]	; (8006ed8 <spi_reset+0x2c>)
 8006eae:	4298      	cmp	r0, r3
 8006eb0:	d00d      	beq.n	8006ece <spi_reset+0x22>
 8006eb2:	f503 4374 	add.w	r3, r3, #62464	; 0xf400
 8006eb6:	4298      	cmp	r0, r3
 8006eb8:	d006      	beq.n	8006ec8 <spi_reset+0x1c>
 8006eba:	f5a3 4378 	sub.w	r3, r3, #63488	; 0xf800
 8006ebe:	4298      	cmp	r0, r3
 8006ec0:	d109      	bne.n	8006ed6 <spi_reset+0x2a>
		rcc_periph_reset_pulse(RST_SPI1);
		break;
#endif
#if defined(SPI2_I2S_BASE)
	case SPI2_I2S_BASE:
		rcc_periph_reset_pulse(RST_SPI2);
 8006ec2:	f240 200e 	movw	r0, #526	; 0x20e
 8006ec6:	e004      	b.n	8006ed2 <spi_reset+0x26>

void spi_reset(uint32_t spi_peripheral)
{	switch (spi_peripheral) {
#if defined(SPI1_BASE)
	case SPI1_BASE:
		rcc_periph_reset_pulse(RST_SPI1);
 8006ec8:	f44f 70c6 	mov.w	r0, #396	; 0x18c
 8006ecc:	e001      	b.n	8006ed2 <spi_reset+0x26>
		rcc_periph_reset_pulse(RST_SPI2);
		break;
#endif
#if defined(SPI3_I2S_BASE)
	case SPI3_I2S_BASE:
		rcc_periph_reset_pulse(RST_SPI3);
 8006ece:	f240 200f 	movw	r0, #527	; 0x20f
 8006ed2:	f000 ba1f 	b.w	8007314 <rcc_periph_reset_pulse>
 8006ed6:	4770      	bx	lr
 8006ed8:	40003c00 	.word	0x40003c00

08006edc <spi_enable>:
@param[in] spi Unsigned int32. SPI peripheral identifier @ref spi_reg_base.
*/

void spi_enable(uint32_t spi)
{
	SPI_CR1(spi) |= SPI_CR1_SPE; /* Enable SPI. */
 8006edc:	6803      	ldr	r3, [r0, #0]
 8006ede:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006ee2:	6003      	str	r3, [r0, #0]
 8006ee4:	4770      	bx	lr

08006ee6 <spi_disable>:

void spi_disable(uint32_t spi)
{
	uint32_t reg32;

	reg32 = SPI_CR1(spi);
 8006ee6:	6803      	ldr	r3, [r0, #0]
	reg32 &= ~(SPI_CR1_SPE); /* Disable SPI. */
 8006ee8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
	SPI_CR1(spi) = reg32;
 8006eec:	6003      	str	r3, [r0, #0]
 8006eee:	4770      	bx	lr

08006ef0 <spi_xfer>:
*/

void spi_write(uint32_t spi, uint16_t data)
{
	/* Write data (8 or 16 bits, depending on DFF) into DR. */
	SPI_DR(spi) = data;
 8006ef0:	60c1      	str	r1, [r0, #12]
uint16_t spi_xfer(uint32_t spi, uint16_t data)
{
	spi_write(spi, data);

	/* Wait for transfer finished. */
	while (!(SPI_SR(spi) & SPI_SR_RXNE));
 8006ef2:	6883      	ldr	r3, [r0, #8]
 8006ef4:	07db      	lsls	r3, r3, #31
 8006ef6:	d5fc      	bpl.n	8006ef2 <spi_xfer+0x2>

	/* Read the data (8 or 16 bits, depending on DFF bit) from DR. */
	return SPI_DR(spi);
 8006ef8:	68c0      	ldr	r0, [r0, #12]
}
 8006efa:	b280      	uxth	r0, r0
 8006efc:	4770      	bx	lr

08006efe <spi_disable_crc>:
@param[in] spi Unsigned int32. SPI peripheral identifier @ref spi_reg_base.
*/

void spi_disable_crc(uint32_t spi)
{
	SPI_CR1(spi) &= ~SPI_CR1_CRCEN;
 8006efe:	6803      	ldr	r3, [r0, #0]
 8006f00:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8006f04:	6003      	str	r3, [r0, #0]
 8006f06:	4770      	bx	lr

08006f08 <spi_set_full_duplex_mode>:
@param[in] spi Unsigned int32. SPI peripheral identifier @ref spi_reg_base.
*/

void spi_set_full_duplex_mode(uint32_t spi)
{
	SPI_CR1(spi) &= ~SPI_CR1_RXONLY;
 8006f08:	6803      	ldr	r3, [r0, #0]
 8006f0a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8006f0e:	6003      	str	r3, [r0, #0]
 8006f10:	4770      	bx	lr

08006f12 <spi_enable_software_slave_management>:
@param[in] spi Unsigned int32. SPI peripheral identifier @ref spi_reg_base.
*/

void spi_enable_software_slave_management(uint32_t spi)
{
	SPI_CR1(spi) |= SPI_CR1_SSM;
 8006f12:	6803      	ldr	r3, [r0, #0]
 8006f14:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8006f18:	6003      	str	r3, [r0, #0]
 8006f1a:	4770      	bx	lr

08006f1c <spi_set_nss_high>:
@param[in] spi Unsigned int32. SPI peripheral identifier @ref spi_reg_base.
*/

void spi_set_nss_high(uint32_t spi)
{
	SPI_CR1(spi) |= SPI_CR1_SSI;
 8006f1c:	6803      	ldr	r3, [r0, #0]
 8006f1e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006f22:	6003      	str	r3, [r0, #0]
 8006f24:	4770      	bx	lr

08006f26 <spi_set_baudrate_prescaler>:

void spi_set_baudrate_prescaler(uint32_t spi, uint8_t baudrate)
{
	uint32_t reg32;

	if (baudrate > 7) {
 8006f26:	2907      	cmp	r1, #7
 8006f28:	d806      	bhi.n	8006f38 <spi_set_baudrate_prescaler+0x12>
		return;
	}

	reg32 = (SPI_CR1(spi) & 0xffc7); /* Clear bits [5:3]. */
 8006f2a:	6802      	ldr	r2, [r0, #0]
 8006f2c:	f64f 73c7 	movw	r3, #65479	; 0xffc7
 8006f30:	4013      	ands	r3, r2
	reg32 |= (baudrate << 3);
 8006f32:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
	SPI_CR1(spi) = reg32;
 8006f36:	6003      	str	r3, [r0, #0]
 8006f38:	4770      	bx	lr

08006f3a <spi_init_master>:
@returns int. Error code.
*/

int spi_init_master(uint32_t spi, uint32_t br, uint32_t cpol, uint32_t cpha,
		    uint32_t dff, uint32_t lsbfirst)
{
 8006f3a:	b570      	push	{r4, r5, r6, lr}
	uint32_t reg32 = SPI_CR1(spi);

	/* Reset all bits omitting SPE, CRCEN and CRCNEXT bits. */
	reg32 &= SPI_CR1_SPE | SPI_CR1_CRCEN | SPI_CR1_CRCNEXT;

	reg32 |= SPI_CR1_MSTR;	/* Configure SPI as master. */
 8006f3c:	9c05      	ldr	r4, [sp, #20]
*/

int spi_init_master(uint32_t spi, uint32_t br, uint32_t cpol, uint32_t cpha,
		    uint32_t dff, uint32_t lsbfirst)
{
	uint32_t reg32 = SPI_CR1(spi);
 8006f3e:	6805      	ldr	r5, [r0, #0]

	/* Reset all bits omitting SPE, CRCEN and CRCNEXT bits. */
	reg32 &= SPI_CR1_SPE | SPI_CR1_CRCEN | SPI_CR1_CRCNEXT;

	reg32 |= SPI_CR1_MSTR;	/* Configure SPI as master. */
 8006f40:	f044 0604 	orr.w	r6, r4, #4

	reg32 |= br;		/* Set baud rate bits. */
 8006f44:	9c04      	ldr	r4, [sp, #16]
		    uint32_t dff, uint32_t lsbfirst)
{
	uint32_t reg32 = SPI_CR1(spi);

	/* Reset all bits omitting SPE, CRCEN and CRCNEXT bits. */
	reg32 &= SPI_CR1_SPE | SPI_CR1_CRCEN | SPI_CR1_CRCNEXT;
 8006f46:	f405 5541 	and.w	r5, r5, #12352	; 0x3040

	reg32 |= SPI_CR1_MSTR;	/* Configure SPI as master. */

	reg32 |= br;		/* Set baud rate bits. */
 8006f4a:	4334      	orrs	r4, r6
	reg32 |= cpol;		/* Set CPOL value. */
 8006f4c:	4323      	orrs	r3, r4
	reg32 |= cpha;		/* Set CPHA value. */
 8006f4e:	431a      	orrs	r2, r3
	reg32 |= dff;		/* Set data format (8 or 16 bits). */
 8006f50:	4311      	orrs	r1, r2
	reg32 |= lsbfirst;	/* Set frame format (LSB- or MSB-first). */
 8006f52:	430d      	orrs	r5, r1

	/* TODO: NSS pin handling. */

	SPI_CR1(spi) = reg32;
 8006f54:	6005      	str	r5, [r0, #0]

	return 0; /* TODO */
}
 8006f56:	2000      	movs	r0, #0
 8006f58:	bd70      	pop	{r4, r5, r6, pc}
	...

08006f5c <timer_reset>:
			    tim_reg_base (TIM9 .. TIM14 not yet supported here).
*/

void timer_reset(uint32_t timer_peripheral)
{
	switch (timer_peripheral) {
 8006f5c:	4b1c      	ldr	r3, [pc, #112]	; (8006fd0 <timer_reset+0x74>)
 8006f5e:	4298      	cmp	r0, r3
 8006f60:	d028      	beq.n	8006fb4 <timer_reset+0x58>
 8006f62:	d80d      	bhi.n	8006f80 <timer_reset+0x24>
 8006f64:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 8006f68:	4298      	cmp	r0, r3
 8006f6a:	d01d      	beq.n	8006fa8 <timer_reset+0x4c>
 8006f6c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8006f70:	4298      	cmp	r0, r3
 8006f72:	d01c      	beq.n	8006fae <timer_reset+0x52>
 8006f74:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8006f78:	d129      	bne.n	8006fce <timer_reset+0x72>
	case TIM1:
		rcc_periph_reset_pulse(RST_TIM1);
		break;
#endif
	case TIM2:
		rcc_periph_reset_pulse(RST_TIM2);
 8006f7a:	f44f 7000 	mov.w	r0, #512	; 0x200
 8006f7e:	e024      	b.n	8006fca <timer_reset+0x6e>
			    tim_reg_base (TIM9 .. TIM14 not yet supported here).
*/

void timer_reset(uint32_t timer_peripheral)
{
	switch (timer_peripheral) {
 8006f80:	4b14      	ldr	r3, [pc, #80]	; (8006fd4 <timer_reset+0x78>)
 8006f82:	4298      	cmp	r0, r3
 8006f84:	d01c      	beq.n	8006fc0 <timer_reset+0x64>
 8006f86:	d804      	bhi.n	8006f92 <timer_reset+0x36>
 8006f88:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 8006f8c:	4298      	cmp	r0, r3
 8006f8e:	d014      	beq.n	8006fba <timer_reset+0x5e>
 8006f90:	4770      	bx	lr
 8006f92:	4b11      	ldr	r3, [pc, #68]	; (8006fd8 <timer_reset+0x7c>)
 8006f94:	4298      	cmp	r0, r3
 8006f96:	d004      	beq.n	8006fa2 <timer_reset+0x46>
 8006f98:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8006f9c:	4298      	cmp	r0, r3
 8006f9e:	d012      	beq.n	8006fc6 <timer_reset+0x6a>
 8006fa0:	4770      	bx	lr
#if defined(TIM1_BASE)
	case TIM1:
		rcc_periph_reset_pulse(RST_TIM1);
 8006fa2:	f240 108b 	movw	r0, #395	; 0x18b
 8006fa6:	e010      	b.n	8006fca <timer_reset+0x6e>
#endif
	case TIM2:
		rcc_periph_reset_pulse(RST_TIM2);
		break;
	case TIM3:
		rcc_periph_reset_pulse(RST_TIM3);
 8006fa8:	f240 2001 	movw	r0, #513	; 0x201
 8006fac:	e00d      	b.n	8006fca <timer_reset+0x6e>
		break;
#if defined(TIM4_BASE)
	case TIM4:
		rcc_periph_reset_pulse(RST_TIM4);
 8006fae:	f240 2002 	movw	r0, #514	; 0x202
 8006fb2:	e00a      	b.n	8006fca <timer_reset+0x6e>
		break;
#endif
#if defined(TIM5_BASE)
	case TIM5:
		rcc_periph_reset_pulse(RST_TIM5);
 8006fb4:	f240 2003 	movw	r0, #515	; 0x203
 8006fb8:	e007      	b.n	8006fca <timer_reset+0x6e>
		break;
#endif
	case TIM6:
		rcc_periph_reset_pulse(RST_TIM6);
 8006fba:	f44f 7001 	mov.w	r0, #516	; 0x204
 8006fbe:	e004      	b.n	8006fca <timer_reset+0x6e>
		break;
	case TIM7:
		rcc_periph_reset_pulse(RST_TIM7);
 8006fc0:	f240 2005 	movw	r0, #517	; 0x205
 8006fc4:	e001      	b.n	8006fca <timer_reset+0x6e>
		break;
#if defined(TIM8_BASE)
	case TIM8:
		rcc_periph_reset_pulse(RST_TIM8);
 8006fc6:	f240 108d 	movw	r0, #397	; 0x18d
 8006fca:	f000 b9a3 	b.w	8007314 <rcc_periph_reset_pulse>
 8006fce:	4770      	bx	lr
 8006fd0:	40000c00 	.word	0x40000c00
 8006fd4:	40001400 	.word	0x40001400
 8006fd8:	40012c00 	.word	0x40012c00

08006fdc <timer_set_mode>:
tim_x_cr1_dir
*/

void timer_set_mode(uint32_t timer_peripheral, uint32_t clock_div,
		    uint32_t alignment, uint32_t direction)
{
 8006fdc:	b510      	push	{r4, lr}
	uint32_t cr1;

	cr1 = TIM_CR1(timer_peripheral);
 8006fde:	6804      	ldr	r4, [r0, #0]

	cr1 &= ~(TIM_CR1_CKD_CK_INT_MASK | TIM_CR1_CMS_MASK | TIM_CR1_DIR_DOWN);

	cr1 |= clock_div | alignment | direction;
 8006fe0:	4313      	orrs	r3, r2
{
	uint32_t cr1;

	cr1 = TIM_CR1(timer_peripheral);

	cr1 &= ~(TIM_CR1_CKD_CK_INT_MASK | TIM_CR1_CMS_MASK | TIM_CR1_DIR_DOWN);
 8006fe2:	f424 745c 	bic.w	r4, r4, #880	; 0x370

	cr1 |= clock_div | alignment | direction;
 8006fe6:	4319      	orrs	r1, r3
 8006fe8:	430c      	orrs	r4, r1

	TIM_CR1(timer_peripheral) = cr1;
 8006fea:	6004      	str	r4, [r0, #0]
 8006fec:	bd10      	pop	{r4, pc}

08006fee <timer_enable_preload>:
tim_reg_base
*/

void timer_enable_preload(uint32_t timer_peripheral)
{
	TIM_CR1(timer_peripheral) |= TIM_CR1_ARPE;
 8006fee:	6803      	ldr	r3, [r0, #0]
 8006ff0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006ff4:	6003      	str	r3, [r0, #0]
 8006ff6:	4770      	bx	lr

08006ff8 <timer_enable_counter>:
tim_reg_base
*/

void timer_enable_counter(uint32_t timer_peripheral)
{
	TIM_CR1(timer_peripheral) |= TIM_CR1_CEN;
 8006ff8:	6803      	ldr	r3, [r0, #0]
 8006ffa:	f043 0301 	orr.w	r3, r3, #1
 8006ffe:	6003      	str	r3, [r0, #0]
 8007000:	4770      	bx	lr

08007002 <timer_set_period>:
@param[in] period Unsigned int32. Period in counter clock ticks.
*/

void timer_set_period(uint32_t timer_peripheral, uint32_t period)
{
	TIM_ARR(timer_peripheral) = period;
 8007002:	62c1      	str	r1, [r0, #44]	; 0x2c
 8007004:	4770      	bx	lr

08007006 <timer_set_oc_mode>:
*/

void timer_set_oc_mode(uint32_t timer_peripheral, enum tim_oc_id oc_id,
		       enum tim_oc_mode oc_mode)
{
	switch (oc_id) {
 8007006:	2906      	cmp	r1, #6
 8007008:	f200 80bf 	bhi.w	800718a <timer_set_oc_mode+0x184>
 800700c:	e8df f011 	tbh	[pc, r1, lsl #1]
 8007010:	00bd0007 	.word	0x00bd0007
 8007014:	00bd0032 	.word	0x00bd0032
 8007018:	00bd005e 	.word	0x00bd005e
 800701c:	008c      	.short	0x008c
	case TIM_OC1:
		TIM_CCMR1(timer_peripheral) &= ~TIM_CCMR1_CC1S_MASK;
 800701e:	6983      	ldr	r3, [r0, #24]
 8007020:	f023 0303 	bic.w	r3, r3, #3
 8007024:	6183      	str	r3, [r0, #24]
		TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_CC1S_OUT;
 8007026:	6983      	ldr	r3, [r0, #24]
 8007028:	6183      	str	r3, [r0, #24]
		TIM_CCMR1(timer_peripheral) &= ~TIM_CCMR1_OC1M_MASK;
 800702a:	6983      	ldr	r3, [r0, #24]
 800702c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8007030:	6183      	str	r3, [r0, #24]
		switch (oc_mode) {
 8007032:	2a07      	cmp	r2, #7
 8007034:	f200 80a9 	bhi.w	800718a <timer_set_oc_mode+0x184>
 8007038:	e8df f002 	tbb	[pc, r2]
 800703c:	08045a2e 	.word	0x08045a2e
 8007040:	1814100c 	.word	0x1814100c
			break;
		case TIM_OCM_ACTIVE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC1M_ACTIVE;
			break;
		case TIM_OCM_INACTIVE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC1M_INACTIVE;
 8007044:	6983      	ldr	r3, [r0, #24]
 8007046:	f043 0320 	orr.w	r3, r3, #32
 800704a:	e084      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_TOGGLE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC1M_TOGGLE;
 800704c:	6983      	ldr	r3, [r0, #24]
 800704e:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 8007052:	e080      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_FORCE_LOW:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC1M_FORCE_LOW;
 8007054:	6983      	ldr	r3, [r0, #24]
 8007056:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800705a:	e07c      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_FORCE_HIGH:
			TIM_CCMR1(timer_peripheral) |=
 800705c:	6983      	ldr	r3, [r0, #24]
 800705e:	f043 0350 	orr.w	r3, r3, #80	; 0x50
 8007062:	e078      	b.n	8007156 <timer_set_oc_mode+0x150>
			    TIM_CCMR1_OC1M_FORCE_HIGH;
			break;
		case TIM_OCM_PWM1:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC1M_PWM1;
 8007064:	6983      	ldr	r3, [r0, #24]
 8007066:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800706a:	e074      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_PWM2:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC1M_PWM2;
 800706c:	6983      	ldr	r3, [r0, #24]
 800706e:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 8007072:	e070      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		}
		break;
	case TIM_OC2:
		TIM_CCMR1(timer_peripheral) &= ~TIM_CCMR1_CC2S_MASK;
 8007074:	6983      	ldr	r3, [r0, #24]
 8007076:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800707a:	6183      	str	r3, [r0, #24]
		TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_CC2S_OUT;
 800707c:	6983      	ldr	r3, [r0, #24]
 800707e:	6183      	str	r3, [r0, #24]
		TIM_CCMR1(timer_peripheral) &= ~TIM_CCMR1_OC2M_MASK;
 8007080:	6983      	ldr	r3, [r0, #24]
 8007082:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8007086:	6183      	str	r3, [r0, #24]
		switch (oc_mode) {
 8007088:	2a07      	cmp	r2, #7
 800708a:	d87e      	bhi.n	800718a <timer_set_oc_mode+0x184>
 800708c:	e8df f002 	tbb	[pc, r2]
 8007090:	0a066004 	.word	0x0a066004
 8007094:	1a16120e 	.word	0x1a16120e
		case TIM_OCM_FROZEN:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_FROZEN;
 8007098:	6983      	ldr	r3, [r0, #24]
 800709a:	e05c      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_ACTIVE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_ACTIVE;
			break;
		case TIM_OCM_INACTIVE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_INACTIVE;
 800709c:	6983      	ldr	r3, [r0, #24]
 800709e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80070a2:	e058      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_TOGGLE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_TOGGLE;
 80070a4:	6983      	ldr	r3, [r0, #24]
 80070a6:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 80070aa:	e054      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_FORCE_LOW:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_FORCE_LOW;
 80070ac:	6983      	ldr	r3, [r0, #24]
 80070ae:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80070b2:	e050      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_FORCE_HIGH:
			TIM_CCMR1(timer_peripheral) |=
 80070b4:	6983      	ldr	r3, [r0, #24]
 80070b6:	f443 43a0 	orr.w	r3, r3, #20480	; 0x5000
 80070ba:	e04c      	b.n	8007156 <timer_set_oc_mode+0x150>
			    TIM_CCMR1_OC2M_FORCE_HIGH;
			break;
		case TIM_OCM_PWM1:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_PWM1;
 80070bc:	6983      	ldr	r3, [r0, #24]
 80070be:	f443 43c0 	orr.w	r3, r3, #24576	; 0x6000
 80070c2:	e048      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_PWM2:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR1_OC2M_PWM2;
 80070c4:	6983      	ldr	r3, [r0, #24]
 80070c6:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
 80070ca:	e044      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		}
		break;
	case TIM_OC3:
		TIM_CCMR1(timer_peripheral) &= ~TIM_CCMR2_CC3S_MASK;
 80070cc:	6983      	ldr	r3, [r0, #24]
 80070ce:	f023 0303 	bic.w	r3, r3, #3
 80070d2:	6183      	str	r3, [r0, #24]
		TIM_CCMR1(timer_peripheral) |= TIM_CCMR2_CC3S_OUT;
 80070d4:	6983      	ldr	r3, [r0, #24]
 80070d6:	6183      	str	r3, [r0, #24]
		TIM_CCMR2(timer_peripheral) &= ~TIM_CCMR2_OC3M_MASK;
 80070d8:	69c3      	ldr	r3, [r0, #28]
 80070da:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80070de:	61c3      	str	r3, [r0, #28]
		switch (oc_mode) {
 80070e0:	2a07      	cmp	r2, #7
 80070e2:	d852      	bhi.n	800718a <timer_set_oc_mode+0x184>
 80070e4:	e8df f002 	tbb	[pc, r2]
 80070e8:	0c080432 	.word	0x0c080432
 80070ec:	1c181410 	.word	0x1c181410
		case TIM_OCM_FROZEN:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC3M_FROZEN;
			break;
		case TIM_OCM_ACTIVE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR2_OC3M_ACTIVE;
 80070f0:	6983      	ldr	r3, [r0, #24]
 80070f2:	f043 0310 	orr.w	r3, r3, #16
 80070f6:	e02e      	b.n	8007156 <timer_set_oc_mode+0x150>
			break;
		case TIM_OCM_INACTIVE:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC3M_INACTIVE;
 80070f8:	69c3      	ldr	r3, [r0, #28]
 80070fa:	f043 0320 	orr.w	r3, r3, #32
 80070fe:	e043      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_TOGGLE:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC3M_TOGGLE;
 8007100:	69c3      	ldr	r3, [r0, #28]
 8007102:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 8007106:	e03f      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_FORCE_LOW:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC3M_FORCE_LOW;
 8007108:	69c3      	ldr	r3, [r0, #28]
 800710a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800710e:	e03b      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_FORCE_HIGH:
			TIM_CCMR2(timer_peripheral) |=
 8007110:	69c3      	ldr	r3, [r0, #28]
 8007112:	f043 0350 	orr.w	r3, r3, #80	; 0x50
 8007116:	e037      	b.n	8007188 <timer_set_oc_mode+0x182>
			    TIM_CCMR2_OC3M_FORCE_HIGH;
			break;
		case TIM_OCM_PWM1:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC3M_PWM1;
 8007118:	69c3      	ldr	r3, [r0, #28]
 800711a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 800711e:	e033      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_PWM2:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC3M_PWM2;
 8007120:	69c3      	ldr	r3, [r0, #28]
 8007122:	f043 0370 	orr.w	r3, r3, #112	; 0x70
 8007126:	e02f      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		}
		break;
	case TIM_OC4:
		TIM_CCMR1(timer_peripheral) &= ~TIM_CCMR2_CC4S_MASK;
 8007128:	6983      	ldr	r3, [r0, #24]
 800712a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800712e:	6183      	str	r3, [r0, #24]
		TIM_CCMR1(timer_peripheral) |= TIM_CCMR2_CC4S_OUT;
 8007130:	6983      	ldr	r3, [r0, #24]
 8007132:	6183      	str	r3, [r0, #24]
		TIM_CCMR2(timer_peripheral) &= ~TIM_CCMR2_OC4M_MASK;
 8007134:	69c3      	ldr	r3, [r0, #28]
 8007136:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800713a:	61c3      	str	r3, [r0, #28]
		switch (oc_mode) {
 800713c:	2a07      	cmp	r2, #7
 800713e:	d824      	bhi.n	800718a <timer_set_oc_mode+0x184>
 8007140:	e8df f002 	tbb	[pc, r2]
 8007144:	0f0b0604 	.word	0x0f0b0604
 8007148:	1f1b1713 	.word	0x1f1b1713
		case TIM_OCM_FROZEN:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC4M_FROZEN;
 800714c:	69c3      	ldr	r3, [r0, #28]
 800714e:	e01b      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_ACTIVE:
			TIM_CCMR1(timer_peripheral) |= TIM_CCMR2_OC4M_ACTIVE;
 8007150:	6983      	ldr	r3, [r0, #24]
 8007152:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8007156:	6183      	str	r3, [r0, #24]
			break;
 8007158:	4770      	bx	lr
		case TIM_OCM_INACTIVE:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC4M_INACTIVE;
 800715a:	69c3      	ldr	r3, [r0, #28]
 800715c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8007160:	e012      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_TOGGLE:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC4M_TOGGLE;
 8007162:	69c3      	ldr	r3, [r0, #28]
 8007164:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
 8007168:	e00e      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_FORCE_LOW:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC4M_FORCE_LOW;
 800716a:	69c3      	ldr	r3, [r0, #28]
 800716c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8007170:	e00a      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_FORCE_HIGH:
			TIM_CCMR2(timer_peripheral) |=
 8007172:	69c3      	ldr	r3, [r0, #28]
 8007174:	f443 43a0 	orr.w	r3, r3, #20480	; 0x5000
 8007178:	e006      	b.n	8007188 <timer_set_oc_mode+0x182>
			    TIM_CCMR2_OC4M_FORCE_HIGH;
			break;
		case TIM_OCM_PWM1:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC4M_PWM1;
 800717a:	69c3      	ldr	r3, [r0, #28]
 800717c:	f443 43c0 	orr.w	r3, r3, #24576	; 0x6000
 8007180:	e002      	b.n	8007188 <timer_set_oc_mode+0x182>
			break;
		case TIM_OCM_PWM2:
			TIM_CCMR2(timer_peripheral) |= TIM_CCMR2_OC4M_PWM2;
 8007182:	69c3      	ldr	r3, [r0, #28]
 8007184:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
 8007188:	61c3      	str	r3, [r0, #28]
 800718a:	4770      	bx	lr

0800718c <timer_enable_oc_output>:
		timers 1 and 8)
*/

void timer_enable_oc_output(uint32_t timer_peripheral, enum tim_oc_id oc_id)
{
	switch (oc_id) {
 800718c:	2906      	cmp	r1, #6
 800718e:	d815      	bhi.n	80071bc <timer_enable_oc_output+0x30>
 8007190:	e8df f001 	tbb	[pc, r1]
 8007194:	14081404 	.word	0x14081404
 8007198:	140c      	.short	0x140c
 800719a:	10          	.byte	0x10
 800719b:	00          	.byte	0x00
	case TIM_OC1:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC1E;
 800719c:	6a03      	ldr	r3, [r0, #32]
 800719e:	f043 0301 	orr.w	r3, r3, #1
 80071a2:	e00a      	b.n	80071ba <timer_enable_oc_output+0x2e>
		break;
	case TIM_OC2:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC2E;
 80071a4:	6a03      	ldr	r3, [r0, #32]
 80071a6:	f043 0310 	orr.w	r3, r3, #16
 80071aa:	e006      	b.n	80071ba <timer_enable_oc_output+0x2e>
		break;
	case TIM_OC3:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC3E;
 80071ac:	6a03      	ldr	r3, [r0, #32]
 80071ae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80071b2:	e002      	b.n	80071ba <timer_enable_oc_output+0x2e>
		break;
	case TIM_OC4:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC4E;
 80071b4:	6a03      	ldr	r3, [r0, #32]
 80071b6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80071ba:	6203      	str	r3, [r0, #32]
		break;
	}

	/* Acting for TIM1 and TIM8 only from here onwards. */
#if ADVANCED_TIMERS
	if (!TIMER_IS_ADVANCED(timer_peripheral)) {
 80071bc:	4b0c      	ldr	r3, [pc, #48]	; (80071f0 <timer_enable_oc_output+0x64>)
 80071be:	4298      	cmp	r0, r3
 80071c0:	d003      	beq.n	80071ca <timer_enable_oc_output+0x3e>
 80071c2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80071c6:	4298      	cmp	r0, r3
 80071c8:	d111      	bne.n	80071ee <timer_enable_oc_output+0x62>
	}
#else
	return;
#endif

	switch (oc_id) {
 80071ca:	2903      	cmp	r1, #3
 80071cc:	d007      	beq.n	80071de <timer_enable_oc_output+0x52>
 80071ce:	2905      	cmp	r1, #5
 80071d0:	d009      	beq.n	80071e6 <timer_enable_oc_output+0x5a>
 80071d2:	2901      	cmp	r1, #1
 80071d4:	d10b      	bne.n	80071ee <timer_enable_oc_output+0x62>
	case TIM_OC1N:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC1NE;
 80071d6:	6a03      	ldr	r3, [r0, #32]
 80071d8:	f043 0304 	orr.w	r3, r3, #4
 80071dc:	e006      	b.n	80071ec <timer_enable_oc_output+0x60>
		break;
	case TIM_OC2N:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC2NE;
 80071de:	6a03      	ldr	r3, [r0, #32]
 80071e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80071e4:	e002      	b.n	80071ec <timer_enable_oc_output+0x60>
		break;
	case TIM_OC3N:
		TIM_CCER(timer_peripheral) |= TIM_CCER_CC3NE;
 80071e6:	6a03      	ldr	r3, [r0, #32]
 80071e8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80071ec:	6203      	str	r3, [r0, #32]
 80071ee:	4770      	bx	lr
 80071f0:	40012c00 	.word	0x40012c00

080071f4 <timer_set_oc_value>:
*/

void timer_set_oc_value(uint32_t timer_peripheral, enum tim_oc_id oc_id,
			uint32_t value)
{
	switch (oc_id) {
 80071f4:	2906      	cmp	r1, #6
 80071f6:	d80c      	bhi.n	8007212 <timer_set_oc_value+0x1e>
 80071f8:	e8df f001 	tbb	[pc, r1]
 80071fc:	0b060b04 	.word	0x0b060b04
 8007200:	0b08      	.short	0x0b08
 8007202:	0a          	.byte	0x0a
 8007203:	00          	.byte	0x00
	case TIM_OC1:
		TIM_CCR1(timer_peripheral) = value;
 8007204:	6342      	str	r2, [r0, #52]	; 0x34
		break;
 8007206:	4770      	bx	lr
	case TIM_OC2:
		TIM_CCR2(timer_peripheral) = value;
 8007208:	6382      	str	r2, [r0, #56]	; 0x38
		break;
 800720a:	4770      	bx	lr
	case TIM_OC3:
		TIM_CCR3(timer_peripheral) = value;
 800720c:	63c2      	str	r2, [r0, #60]	; 0x3c
		break;
 800720e:	4770      	bx	lr
	case TIM_OC4:
		TIM_CCR4(timer_peripheral) = value;
 8007210:	6402      	str	r2, [r0, #64]	; 0x40
 8007212:	4770      	bx	lr

08007214 <timer_enable_break_main_output>:
*/

void timer_enable_break_main_output(uint32_t timer_peripheral)
{
#if ADVANCED_TIMERS
	if (TIMER_IS_ADVANCED(timer_peripheral)) {
 8007214:	4b05      	ldr	r3, [pc, #20]	; (800722c <timer_enable_break_main_output+0x18>)
 8007216:	4298      	cmp	r0, r3
 8007218:	d003      	beq.n	8007222 <timer_enable_break_main_output+0xe>
 800721a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800721e:	4298      	cmp	r0, r3
 8007220:	d103      	bne.n	800722a <timer_enable_break_main_output+0x16>
		TIM_BDTR(timer_peripheral) |= TIM_BDTR_MOE;
 8007222:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8007224:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007228:	6443      	str	r3, [r0, #68]	; 0x44
 800722a:	4770      	bx	lr
 800722c:	40012c00 	.word	0x40012c00

08007230 <timer_generate_event>:
@param[in] event Unsigned int32. Event specification @ref tim_event_gen
*/

void timer_generate_event(uint32_t timer_peripheral, uint32_t event)
{
	TIM_EGR(timer_peripheral) |= event;
 8007230:	6943      	ldr	r3, [r0, #20]
 8007232:	4319      	orrs	r1, r3
 8007234:	6141      	str	r1, [r0, #20]
 8007236:	4770      	bx	lr

08007238 <usart_set_baudrate>:
	if ((usart == USART1) ||
	    (usart == USART6)) {
		clock = rcc_ppre2_frequency;
	}
#else
	if (usart == USART1) {
 8007238:	4a06      	ldr	r2, [pc, #24]	; (8007254 <usart_set_baudrate+0x1c>)
@param[in] baud unsigned 32 bit. Baud rate specified in Hz.
*/

void usart_set_baudrate(uint32_t usart, uint32_t baud)
{
	uint32_t clock = rcc_ppre1_frequency;
 800723a:	4b07      	ldr	r3, [pc, #28]	; (8007258 <usart_set_baudrate+0x20>)
	if ((usart == USART1) ||
	    (usart == USART6)) {
		clock = rcc_ppre2_frequency;
	}
#else
	if (usart == USART1) {
 800723c:	4290      	cmp	r0, r2
@param[in] baud unsigned 32 bit. Baud rate specified in Hz.
*/

void usart_set_baudrate(uint32_t usart, uint32_t baud)
{
	uint32_t clock = rcc_ppre1_frequency;
 800723e:	681b      	ldr	r3, [r3, #0]
	    (usart == USART6)) {
		clock = rcc_ppre2_frequency;
	}
#else
	if (usart == USART1) {
		clock = rcc_ppre2_frequency;
 8007240:	bf04      	itt	eq
 8007242:	4b06      	ldreq	r3, [pc, #24]	; (800725c <usart_set_baudrate+0x24>)
 8007244:	681b      	ldreq	r3, [r3, #0]
	 * simple divider to generate the correct baudrate.
	 *
	 * Note: We round() the value rather than floor()ing it, for more
	 * accurate divisor selection.
	 */
	USART_BRR(usart) = ((2 * clock) + baud) / (2 * baud);
 8007246:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 800724a:	0049      	lsls	r1, r1, #1
 800724c:	fbb3 f3f1 	udiv	r3, r3, r1
 8007250:	6083      	str	r3, [r0, #8]
 8007252:	4770      	bx	lr
 8007254:	40013800 	.word	0x40013800
 8007258:	2000000c 	.word	0x2000000c
 800725c:	20000010 	.word	0x20000010

08007260 <usart_set_databits>:
*/

void usart_set_databits(uint32_t usart, uint32_t bits)
{
	if (bits == 8) {
		USART_CR1(usart) &= ~USART_CR1_M; /* 8 data bits */
 8007260:	68c3      	ldr	r3, [r0, #12]
@param[in] bits unsigned 32 bit. Word length in bits 8 or 9.
*/

void usart_set_databits(uint32_t usart, uint32_t bits)
{
	if (bits == 8) {
 8007262:	2908      	cmp	r1, #8
		USART_CR1(usart) &= ~USART_CR1_M; /* 8 data bits */
 8007264:	bf0c      	ite	eq
 8007266:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
	} else {
		USART_CR1(usart) |= USART_CR1_M;  /* 9 data bits */
 800726a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800726e:	60c3      	str	r3, [r0, #12]
 8007270:	4770      	bx	lr

08007272 <usart_set_stopbits>:

void usart_set_stopbits(uint32_t usart, uint32_t stopbits)
{
	uint32_t reg32;

	reg32 = USART_CR2(usart);
 8007272:	6903      	ldr	r3, [r0, #16]
	reg32 = (reg32 & ~USART_CR2_STOPBITS_MASK) | stopbits;
 8007274:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8007278:	4319      	orrs	r1, r3
	USART_CR2(usart) = reg32;
 800727a:	6101      	str	r1, [r0, #16]
 800727c:	4770      	bx	lr

0800727e <usart_set_parity>:

void usart_set_parity(uint32_t usart, uint32_t parity)
{
	uint32_t reg32;

	reg32 = USART_CR1(usart);
 800727e:	68c3      	ldr	r3, [r0, #12]
	reg32 = (reg32 & ~USART_PARITY_MASK) | parity;
 8007280:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8007284:	4319      	orrs	r1, r3
	USART_CR1(usart) = reg32;
 8007286:	60c1      	str	r1, [r0, #12]
 8007288:	4770      	bx	lr

0800728a <usart_set_mode>:

void usart_set_mode(uint32_t usart, uint32_t mode)
{
	uint32_t reg32;

	reg32 = USART_CR1(usart);
 800728a:	68c3      	ldr	r3, [r0, #12]
	reg32 = (reg32 & ~USART_MODE_MASK) | mode;
 800728c:	f023 030c 	bic.w	r3, r3, #12
 8007290:	4319      	orrs	r1, r3
	USART_CR1(usart) = reg32;
 8007292:	60c1      	str	r1, [r0, #12]
 8007294:	4770      	bx	lr

08007296 <usart_set_flow_control>:

void usart_set_flow_control(uint32_t usart, uint32_t flowcontrol)
{
	uint32_t reg32;

	reg32 = USART_CR3(usart);
 8007296:	6943      	ldr	r3, [r0, #20]
	reg32 = (reg32 & ~USART_FLOWCONTROL_MASK) | flowcontrol;
 8007298:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800729c:	4319      	orrs	r1, r3
	USART_CR3(usart) = reg32;
 800729e:	6141      	str	r1, [r0, #20]
 80072a0:	4770      	bx	lr

080072a2 <usart_enable>:
usart_reg_base
*/

void usart_enable(uint32_t usart)
{
	USART_CR1(usart) |= USART_CR1_UE;
 80072a2:	68c3      	ldr	r3, [r0, #12]
 80072a4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80072a8:	60c3      	str	r3, [r0, #12]
 80072aa:	4770      	bx	lr

080072ac <usart_enable_rx_interrupt>:
usart_reg_base
*/

void usart_enable_rx_interrupt(uint32_t usart)
{
	USART_CR1(usart) |= USART_CR1_RXNEIE;
 80072ac:	68c3      	ldr	r3, [r0, #12]
 80072ae:	f043 0320 	orr.w	r3, r3, #32
 80072b2:	60c3      	str	r3, [r0, #12]
 80072b4:	4770      	bx	lr

080072b6 <usart_enable_tx_interrupt>:
usart_reg_base
*/

void usart_enable_tx_interrupt(uint32_t usart)
{
	USART_CR1(usart) |= USART_CR1_TXEIE;
 80072b6:	68c3      	ldr	r3, [r0, #12]
 80072b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80072bc:	60c3      	str	r3, [r0, #12]
 80072be:	4770      	bx	lr

080072c0 <usart_disable_tx_interrupt>:
usart_reg_base
*/

void usart_disable_tx_interrupt(uint32_t usart)
{
	USART_CR1(usart) &= ~USART_CR1_TXEIE;
 80072c0:	68c3      	ldr	r3, [r0, #12]
 80072c2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80072c6:	60c3      	str	r3, [r0, #12]
 80072c8:	4770      	bx	lr

080072ca <usart_send>:
*/

void usart_send(uint32_t usart, uint16_t data)
{
	/* Send data. */
	USART_DR(usart) = (data & USART_DR_MASK);
 80072ca:	f3c1 0108 	ubfx	r1, r1, #0, #9
 80072ce:	6041      	str	r1, [r0, #4]
 80072d0:	4770      	bx	lr

080072d2 <usart_recv>:
*/

uint16_t usart_recv(uint32_t usart)
{
	/* Receive data. */
	return USART_DR(usart) & USART_DR_MASK;
 80072d2:	6840      	ldr	r0, [r0, #4]
}
 80072d4:	f3c0 0008 	ubfx	r0, r0, #0, #9
 80072d8:	4770      	bx	lr

080072da <usart_get_flag>:
@returns boolean: flag set.
*/

bool usart_get_flag(uint32_t usart, uint32_t flag)
{
	return ((USART_SR(usart) & flag) != 0);
 80072da:	6803      	ldr	r3, [r0, #0]
 80072dc:	420b      	tst	r3, r1
}
 80072de:	bf0c      	ite	eq
 80072e0:	2000      	moveq	r0, #0
 80072e2:	2001      	movne	r0, #1
 80072e4:	4770      	bx	lr

080072e6 <rcc_peripheral_enable_clock>:
 * @li If register is RCC_APB2ENR, from @ref rcc_apb2enr_en
 */

void rcc_peripheral_enable_clock(volatile uint32_t *reg, uint32_t en)
{
	*reg |= en;
 80072e6:	6803      	ldr	r3, [r0, #0]
 80072e8:	4319      	orrs	r1, r3
 80072ea:	6001      	str	r1, [r0, #0]
 80072ec:	4770      	bx	lr

080072ee <rcc_peripheral_disable_clock>:
 * @li If register is RCC_APB1ENR, from @ref rcc_apb1enr_en
 * @li If register is RCC_APB2ENR, from @ref rcc_apb2enr_en
 */
void rcc_peripheral_disable_clock(volatile uint32_t *reg, uint32_t en)
{
	*reg &= ~en;
 80072ee:	6803      	ldr	r3, [r0, #0]
 80072f0:	ea23 0101 	bic.w	r1, r3, r1
 80072f4:	6001      	str	r1, [r0, #0]
 80072f6:	4770      	bx	lr

080072f8 <rcc_periph_clock_enable>:
 * For available constants, see #periph_t (RCC_UART1 for example)
 */

void rcc_periph_clock_enable(enum rcc_periph_clken clken)
{
	_RCC_REG(clken) |= _RCC_BIT(clken);
 80072f8:	0943      	lsrs	r3, r0, #5
 80072fa:	2101      	movs	r1, #1
 80072fc:	f000 001f 	and.w	r0, r0, #31
 8007300:	fa01 f000 	lsl.w	r0, r1, r0
 8007304:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007308:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 800730c:	681a      	ldr	r2, [r3, #0]
 800730e:	4310      	orrs	r0, r2
 8007310:	6018      	str	r0, [r3, #0]
 8007312:	4770      	bx	lr

08007314 <rcc_periph_reset_pulse>:
 * For available constants, see #periph_t (RCC_UART1 for example)
 */

void rcc_periph_reset_pulse(enum rcc_periph_rst rst)
{
	_RCC_REG(rst) |= _RCC_BIT(rst);
 8007314:	0943      	lsrs	r3, r0, #5
 8007316:	2101      	movs	r1, #1
 8007318:	f000 001f 	and.w	r0, r0, #31
 800731c:	fa01 f000 	lsl.w	r0, r1, r0
 8007320:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8007324:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8007328:	681a      	ldr	r2, [r3, #0]
 800732a:	4302      	orrs	r2, r0
 800732c:	601a      	str	r2, [r3, #0]
	_RCC_REG(rst) &= ~_RCC_BIT(rst);
 800732e:	681a      	ldr	r2, [r3, #0]
 8007330:	ea22 0000 	bic.w	r0, r2, r0
 8007334:	6018      	str	r0, [r3, #0]
 8007336:	4770      	bx	lr

08007338 <flash_set_ws>:
@param[in] uint32_t ws: values from @ref flash_latency.
*/

void flash_set_ws(uint32_t ws)
{
	FLASH_ACR = (FLASH_ACR & ~FLASH_ACR_LATENCY) | ws;
 8007338:	4b03      	ldr	r3, [pc, #12]	; (8007348 <flash_set_ws+0x10>)
 800733a:	681a      	ldr	r2, [r3, #0]
 800733c:	f022 0207 	bic.w	r2, r2, #7
 8007340:	4310      	orrs	r0, r2
 8007342:	6018      	str	r0, [r3, #0]
 8007344:	4770      	bx	lr
 8007346:	bf00      	nop
 8007348:	40022000 	.word	0x40022000

0800734c <flash_unlock>:
*/

void flash_unlock(void)
{
	/* Clear the unlock state. */
	FLASH_CR |= FLASH_CR_LOCK;
 800734c:	4b06      	ldr	r3, [pc, #24]	; (8007368 <flash_unlock+0x1c>)
 800734e:	681a      	ldr	r2, [r3, #0]
 8007350:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8007354:	601a      	str	r2, [r3, #0]

	/* Authorize the FPEC access. */
	FLASH_KEYR = FLASH_KEYR_KEY1;
 8007356:	4a05      	ldr	r2, [pc, #20]	; (800736c <flash_unlock+0x20>)
 8007358:	f843 2c0c 	str.w	r2, [r3, #-12]
	FLASH_KEYR = FLASH_KEYR_KEY2;
 800735c:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8007360:	f843 2c0c 	str.w	r2, [r3, #-12]
{
	/* Clear the unlock state. */
	FLASH_CR |= FLASH_CR_LOCK;

	/* Authorize the FPEC access. */
	FLASH_KEYR = FLASH_KEYR_KEY1;
 8007364:	4770      	bx	lr
 8007366:	bf00      	nop
 8007368:	40022010 	.word	0x40022010
 800736c:	45670123 	.word	0x45670123

08007370 <flash_wait_for_last_operation>:
This loops indefinitely until an operation (write or erase) has completed by
testing the busy flag.
*/

void flash_wait_for_last_operation(void)
{
 8007370:	b508      	push	{r3, lr}
	while ((flash_get_status_flags() & FLASH_SR_BSY) == FLASH_SR_BSY);
 8007372:	f7ff fa0f 	bl	8006794 <flash_get_status_flags>
 8007376:	07c3      	lsls	r3, r0, #31
 8007378:	d4fb      	bmi.n	8007372 <flash_wait_for_last_operation+0x2>
}
 800737a:	bd08      	pop	{r3, pc}

0800737c <flash_program_word>:
@param[in] uint32_t address. Full address of flash word to be programmed.
@param[in] uint32_t data.
*/

void flash_program_word(uint32_t address, uint32_t data)
{
 800737c:	b538      	push	{r3, r4, r5, lr}
 800737e:	4605      	mov	r5, r0
 8007380:	460c      	mov	r4, r1
    flash_program_half_word(address,(uint16_t)data);
 8007382:	b289      	uxth	r1, r1
 8007384:	f7ff fa1a 	bl	80067bc <flash_program_half_word>
    flash_program_half_word(address+2,(uint16_t)(data>>16));
 8007388:	1ca8      	adds	r0, r5, #2
 800738a:	0c21      	lsrs	r1, r4, #16
}
 800738c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
*/

void flash_program_word(uint32_t address, uint32_t data)
{
    flash_program_half_word(address,(uint16_t)data);
    flash_program_half_word(address+2,(uint16_t)(data>>16));
 8007390:	f7ff ba14 	b.w	80067bc <flash_program_half_word>

08007394 <blocking_handler>:
	}

}

void blocking_handler(void)
{
 8007394:	e7fe      	b.n	8007394 <blocking_handler>

08007396 <null_handler>:
	while (1);
}

void null_handler(void)
{
 8007396:	4770      	bx	lr

08007398 <reset_handler>:
void WEAK __attribute__ ((naked)) reset_handler(void)
{
	volatile unsigned *src, *dest;
	funcp_t *fp;

	for (src = &_data_loadaddr, dest = &_data;
 8007398:	2200      	movs	r2, #0
 800739a:	4915      	ldr	r1, [pc, #84]	; (80073f0 <reset_handler+0x58>)
 800739c:	4815      	ldr	r0, [pc, #84]	; (80073f4 <reset_handler+0x5c>)
 800739e:	1853      	adds	r3, r2, r1
 80073a0:	4283      	cmp	r3, r0
 80073a2:	d204      	bcs.n	80073ae <reset_handler+0x16>
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
 80073a4:	4b14      	ldr	r3, [pc, #80]	; (80073f8 <reset_handler+0x60>)
 80073a6:	58d3      	ldr	r3, [r2, r3]
 80073a8:	5053      	str	r3, [r2, r1]
 80073aa:	3204      	adds	r2, #4
 80073ac:	e7f5      	b.n	800739a <reset_handler+0x2>
	}

	while (dest < &_ebss) {
 80073ae:	4a13      	ldr	r2, [pc, #76]	; (80073fc <reset_handler+0x64>)
 80073b0:	4293      	cmp	r3, r2
 80073b2:	d203      	bcs.n	80073bc <reset_handler+0x24>
		*dest++ = 0;
 80073b4:	2200      	movs	r2, #0
 80073b6:	601a      	str	r2, [r3, #0]
 80073b8:	3304      	adds	r3, #4
 80073ba:	e7f8      	b.n	80073ae <reset_handler+0x16>
		dest < &_edata;
		src++, dest++) {
		*dest = *src;
	}

	while (dest < &_ebss) {
 80073bc:	4c10      	ldr	r4, [pc, #64]	; (8007400 <reset_handler+0x68>)
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
 80073be:	4b11      	ldr	r3, [pc, #68]	; (8007404 <reset_handler+0x6c>)
 80073c0:	429c      	cmp	r4, r3
 80073c2:	d203      	bcs.n	80073cc <reset_handler+0x34>
		(*fp)();
 80073c4:	f854 3b04 	ldr.w	r3, [r4], #4
 80073c8:	4798      	blx	r3
 80073ca:	e7f8      	b.n	80073be <reset_handler+0x26>
	while (dest < &_ebss) {
		*dest++ = 0;
	}

	/* Constructors. */
	for (fp = &__preinit_array_start; fp < &__preinit_array_end; fp++) {
 80073cc:	4c0e      	ldr	r4, [pc, #56]	; (8007408 <reset_handler+0x70>)
		(*fp)();
	}
	for (fp = &__init_array_start; fp < &__init_array_end; fp++) {
 80073ce:	4b0f      	ldr	r3, [pc, #60]	; (800740c <reset_handler+0x74>)
 80073d0:	429c      	cmp	r4, r3
 80073d2:	d203      	bcs.n	80073dc <reset_handler+0x44>
		(*fp)();
 80073d4:	f854 3b04 	ldr.w	r3, [r4], #4
 80073d8:	4798      	blx	r3
 80073da:	e7f8      	b.n	80073ce <reset_handler+0x36>

	/* might be provided by platform specific vector.c */
	pre_main();

	/* Call the application's entry point. */
	main();
 80073dc:	f7f8 feb8 	bl	8000150 <main>

	/* Destructors. */
	for (fp = &__fini_array_start; fp < &__fini_array_end; fp++) {
 80073e0:	4c0b      	ldr	r4, [pc, #44]	; (8007410 <reset_handler+0x78>)
 80073e2:	4b0c      	ldr	r3, [pc, #48]	; (8007414 <reset_handler+0x7c>)
 80073e4:	429c      	cmp	r4, r3
 80073e6:	d203      	bcs.n	80073f0 <reset_handler+0x58>
		(*fp)();
 80073e8:	f854 3b04 	ldr.w	r3, [r4], #4
 80073ec:	4798      	blx	r3
 80073ee:	e7f8      	b.n	80073e2 <reset_handler+0x4a>
 80073f0:	20000000 	.word	0x20000000
 80073f4:	20000014 	.word	0x20000014
 80073f8:	080075b0 	.word	0x080075b0
 80073fc:	20005660 	.word	0x20005660
 8007400:	080075b0 	.word	0x080075b0
 8007404:	080075b0 	.word	0x080075b0
 8007408:	080075b0 	.word	0x080075b0
 800740c:	080075b0 	.word	0x080075b0
 8007410:	080075b0 	.word	0x080075b0
 8007414:	080075b0 	.word	0x080075b0

08007418 <systick_set_reload>:
 * @param[in] value uint32_t. 24 bit reload value.
 */

void systick_set_reload(uint32_t value)
{
	STK_RVR = (value & STK_RVR_RELOAD);
 8007418:	4b02      	ldr	r3, [pc, #8]	; (8007424 <systick_set_reload+0xc>)
 800741a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 800741e:	6018      	str	r0, [r3, #0]
 8007420:	4770      	bx	lr
 8007422:	bf00      	nop
 8007424:	e000e014 	.word	0xe000e014

08007428 <systick_set_clocksource>:
 * @param[in] clocksource uint8_t. Clock source from @ref systick_clksource.
 */

void systick_set_clocksource(uint8_t clocksource)
{
	STK_CSR = (STK_CSR & ~STK_CSR_CLKSOURCE) |
 8007428:	4b04      	ldr	r3, [pc, #16]	; (800743c <systick_set_clocksource+0x14>)
 800742a:	f000 0004 	and.w	r0, r0, #4
 800742e:	681a      	ldr	r2, [r3, #0]
 8007430:	f022 0204 	bic.w	r2, r2, #4
 8007434:	4302      	orrs	r2, r0
 8007436:	601a      	str	r2, [r3, #0]
 8007438:	4770      	bx	lr
 800743a:	bf00      	nop
 800743c:	e000e010 	.word	0xe000e010

08007440 <systick_interrupt_enable>:
 *
 */

void systick_interrupt_enable(void)
{
	STK_CSR |= STK_CSR_TICKINT;
 8007440:	4b02      	ldr	r3, [pc, #8]	; (800744c <systick_interrupt_enable+0xc>)
 8007442:	681a      	ldr	r2, [r3, #0]
 8007444:	f042 0202 	orr.w	r2, r2, #2
 8007448:	601a      	str	r2, [r3, #0]
 800744a:	4770      	bx	lr
 800744c:	e000e010 	.word	0xe000e010

08007450 <systick_counter_enable>:
 *
 */

void systick_counter_enable(void)
{
	STK_CSR |= STK_CSR_ENABLE;
 8007450:	4b02      	ldr	r3, [pc, #8]	; (800745c <systick_counter_enable+0xc>)
 8007452:	681a      	ldr	r2, [r3, #0]
 8007454:	f042 0201 	orr.w	r2, r2, #1
 8007458:	601a      	str	r2, [r3, #0]
 800745a:	4770      	bx	lr
 800745c:	e000e010 	.word	0xe000e010

08007460 <scb_reset_system>:
}
#endif

void scb_reset_system(void)
{
	SCB_AIRCR = SCB_AIRCR_VECTKEY | SCB_AIRCR_SYSRESETREQ;
 8007460:	4a01      	ldr	r2, [pc, #4]	; (8007468 <scb_reset_system+0x8>)
 8007462:	4b02      	ldr	r3, [pc, #8]	; (800746c <scb_reset_system+0xc>)
 8007464:	601a      	str	r2, [r3, #0]
 8007466:	e7fe      	b.n	8007466 <scb_reset_system+0x6>
 8007468:	05fa0004 	.word	0x05fa0004
 800746c:	e000ed0c 	.word	0xe000ed0c

08007470 <nvic_enable_irq>:
 * @param[in] irqn Unsigned int8. Interrupt number @ref nvic_stm32f1_userint
 */

void nvic_enable_irq(uint8_t irqn)
{
	NVIC_ISER(irqn / 32) = (1 << (irqn % 32));
 8007470:	0943      	lsrs	r3, r0, #5
 8007472:	2201      	movs	r2, #1
 8007474:	f000 001f 	and.w	r0, r0, #31
 8007478:	fa02 f000 	lsl.w	r0, r2, r0
 800747c:	009b      	lsls	r3, r3, #2
 800747e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8007482:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8007486:	6018      	str	r0, [r3, #0]
 8007488:	4770      	bx	lr
 800748a:	0000      	movs	r0, r0
 800748c:	63746157 	.word	0x63746157
 8007490:	676f6468 	.word	0x676f6468
 8007494:	6d6f4300 	.word	0x6d6f4300
 8007498:	696e756d 	.word	0x696e756d
 800749c:	69746163 	.word	0x69746163
 80074a0:	00736e6f 	.word	0x00736e6f
 80074a4:	656c6946 	.word	0x656c6946
 80074a8:	61654d00 	.word	0x61654d00
 80074ac:	65727573 	.word	0x65727573
 80074b0:	746e656d 	.word	0x746e656d
 80074b4:	6e6f4d00 	.word	0x6e6f4d00
 80074b8:	726f7469 	.word	0x726f7469
 80074bc:	61684300 	.word	0x61684300
 80074c0:	72656772 	.word	0x72656772
 80074c4:	00          	.byte	0x00
 80074c5:	0d          	.byte	0x0d
 80074c6:	000a      	.short	0x000a
 80074c8:	31300020 	.word	0x31300020
 80074cc:	35343332 	.word	0x35343332
 80074d0:	39383736 	.word	0x39383736
 80074d4:	44434241 	.word	0x44434241
 80074d8:	52004645 	.word	0x52004645
 80074dc:	74657365 	.word	0x74657365
 80074e0:	00444400 	.word	0x00444400
 80074e4:	74746142 	.word	0x74746142
 80074e8:	20797265 	.word	0x20797265
 80074ec:	616e614d 	.word	0x616e614d
 80074f0:	656d6567 	.word	0x656d6567
 80074f4:	5320746e 	.word	0x5320746e
 80074f8:	65747379 	.word	0x65747379
 80074fc:	3076206d 	.word	0x3076206d
 8007500:	6400312e 	.word	0x6400312e
 8007504:	44640053 	.word	0x44640053
 8007508:	00466600 	.word	0x00466600
 800750c:	66004566 	.word	0x66004566
 8007510:	52660057 	.word	0x52660057
 8007514:	00476600 	.word	0x00476600
 8007518:	66004466 	.word	0x66004466
 800751c:	2c73      	.short	0x2c73
 800751e:	00          	.byte	0x00
 800751f:	70          	.byte	0x70
 8007520:	48700051 	.word	0x48700051
 8007524:	00546400 	.word	0x00546400
 8007528:	64007364 	.word	0x64007364
 800752c:	49640064 	.word	0x49640064
 8007530:	6e6f4d00 	.word	0x6e6f4d00
 8007534:	726f7469 	.word	0x726f7469
 8007538:	73655220 	.word	0x73655220
 800753c:	74726174 	.word	0x74726174
 8007540:	6465      	.short	0x6465
 8007542:	00          	.byte	0x00
 8007543:	43          	.byte	0x43
 8007544:	67726168 	.word	0x67726168
 8007548:	52207265 	.word	0x52207265
 800754c:	61747365 	.word	0x61747365
 8007550:	64657472 	.word	0x64657472
 8007554:	00          	.byte	0x00
 8007555:	30          	.byte	0x30
 8007556:	3231      	.short	0x3231
 8007558:	36353433 	.word	0x36353433
 800755c:	00393837 	.word	0x00393837
 8007560:	0030002d 	.word	0x0030002d
 8007564:	003a      	.short	0x003a

08007566 <DaysInMonth>:
 8007566:	1d1f 1e1f 1e1f 1f1f 1f1e 1f1e 654d 7361     ............Meas
 8007576:	7275 6d65 6e65 2074 6552 7473 7261 6574     urement Restarte
 8007586:	0064 2a22 2c2b 3b3a 3d3c 3f3e 5d5b 7f7c     d."*+,:;<=>?[]|.
	...

08007597 <DaysInMonth>:
 8007597:	1d1f 1e1f 1e1f 1f1f 1f1e 1f1e 4449 454c     ............IDLE
 80075a7:	5400 726d 5320 6376 0d00                         .Tmr Svc.
